<?xml version="1.0" encoding="UTF-8"?><xs:schema elementFormDefault="qualified" xmlns:xs="http://www.w3.org/2001/XMLSchema">  <xs:annotation>    <xs:documentation>QEDEQ 1.01 Schema    This file is part of the project "Hilbert II" - http://www.qedeq.orgCopyright 2000-2013,  Michael Meyling &lt;mime@qedeq.org&gt;.</xs:documentation>  </xs:annotation>  <xs:element name="QEDEQ">    <xs:annotation>        <xs:documentation>          Root element. Any QEDEQ document has this structure.          If this XSD is changed don't forget to change also:             the visitor   org.qedeq.kernel.xml.mapper.Context2SimpleXPath,            the traverser org.qedeq.kernel.se.visitor.QedeqNotNullTraverser,            the builder   org.qedeq.kernel.bo.service.QedeqVoBuilder,            the visitor   org.qedeq.kernel.se.visitor.QedeqVisitor,            the visitor   org.qedeq.kernel.se.visitor.AbstractModuleVisitor          and the parsers.        </xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element name="HEADER">          <xs:annotation>            <xs:documentation>File specification, information about the authors, imports of other QEDEQ modules and so on are part of the header.</xs:documentation>          </xs:annotation>          <xs:complexType>            <xs:sequence>              <xs:element ref="SPECIFICATION">                <xs:annotation>                  <xs:documentation>File specification of this module. What is the name of this module and where to find it.</xs:documentation>                </xs:annotation>              </xs:element>              <xs:element ref="TITLE">                <xs:annotation>                  <xs:documentation>Title of this QEDEQ module.</xs:documentation>                </xs:annotation>              </xs:element>              <xs:element name="ABSTRACT">                <xs:annotation>                  <xs:documentation>Module contents description.</xs:documentation>                </xs:annotation>                <xs:complexType>                  <xs:sequence>                    <xs:element ref="LATEX" maxOccurs="unbounded"/>                  </xs:sequence>                </xs:complexType>              </xs:element>              <xs:element name="AUTHORS">                <xs:annotation>                  <xs:documentation>List of authors of this module.</xs:documentation>                </xs:annotation>                <xs:complexType>                  <xs:sequence>                    <xs:element name="AUTHOR">                      <xs:annotation>                        <xs:documentation>Name and email address of author.</xs:documentation>                      </xs:annotation>                      <xs:complexType>                        <xs:sequence>                          <xs:element name="NAME">                            <xs:annotation>                              <xs:documentation>Name of author.</xs:documentation>                            </xs:annotation>                            <xs:complexType>                              <xs:sequence>                                <xs:element ref="LATEX"/>                              </xs:sequence>                            </xs:complexType>                          </xs:element>                        </xs:sequence>                        <xs:attribute name="email" type="EMAILTYPE">                          <xs:annotation>                            <xs:documentation>Email address of author.</xs:documentation>                          </xs:annotation>                        </xs:attribute>                      </xs:complexType>                    </xs:element>                  </xs:sequence>                </xs:complexType>              </xs:element>              <xs:element name="IMPORTS" minOccurs="0">                <xs:annotation>                  <xs:documentation>References to other QEDEQ modules that are a precondition for this one.</xs:documentation>                </xs:annotation>                <xs:complexType>                  <xs:sequence>                    <xs:element name="IMPORT" maxOccurs="unbounded">                      <xs:annotation>                        <xs:documentation>A single reference to a QEDEQ module that must be imported.</xs:documentation>                      </xs:annotation>                      <xs:complexType>                        <xs:sequence>                          <xs:element ref="SPECIFICATION">                            <xs:annotation>                              <xs:documentation>File specification of QEDEQ module to import. What is the name of this module and where to find it.</xs:documentation>                            </xs:annotation>                          </xs:element>                        </xs:sequence>                        <xs:attribute name="label" type="xs:NMTOKEN" use="required">                          <xs:annotation>                            <xs:documentation>Prefix for labels from referenced QEDEQ module. References to labels in the referenced module must be extended with this prefix. This label must be unique within this module.</xs:documentation>                          </xs:annotation>                        </xs:attribute>                      </xs:complexType>                    </xs:element>                  </xs:sequence>                </xs:complexType>              </xs:element>              <xs:element name="USEDBY" minOccurs="0">                <xs:annotation>                  <xs:documentation>List of QEDEQ modules which use (import) this module. This information could be incorrect due to changes in the referenced modules. Also newly created modules could be missing. To keep these entries correct the external module administrator should email the module administrator of this module. This label must be unique within this module.</xs:documentation>                </xs:annotation>                <xs:complexType>                  <xs:sequence>                    <xs:element ref="SPECIFICATION">                      <xs:annotation>                        <xs:documentation>File specification of QEDEQ module that depends on this one. What is the name of this module and where to find it.</xs:documentation>                      </xs:annotation>                    </xs:element>                  </xs:sequence>                </xs:complexType>              </xs:element>            </xs:sequence>            <xs:attribute name="email" type="EMAILTYPE">              <xs:annotation>                <xs:documentation>Email address for administration services of this QEDEQ module.</xs:documentation>              </xs:annotation>                      </xs:attribute>          </xs:complexType>        </xs:element>        <xs:element name="CHAPTER" maxOccurs="unbounded">          <xs:annotation>            <xs:documentation>This part corresponds to the LaTeX item chapter.</xs:documentation>          </xs:annotation>          <xs:complexType>            <xs:sequence>              <xs:element ref="TITLE">                <xs:annotation>                  <xs:documentation>Chapter title.</xs:documentation>                </xs:annotation>              </xs:element>              <xs:element name="INTRODUCTION" minOccurs="0">                <xs:annotation>                  <xs:documentation>Chapter contents description.</xs:documentation>                </xs:annotation>                <xs:complexType>                  <xs:sequence>                    <xs:element ref="LATEX" minOccurs="1" maxOccurs="unbounded"/>                  </xs:sequence>                </xs:complexType>              </xs:element>              <xs:element name="SECTION" minOccurs="0" maxOccurs="unbounded">                <xs:annotation>                  <xs:documentation>Section of chapter.</xs:documentation>                </xs:annotation>                <xs:complexType>                  <xs:sequence>                    <xs:element ref="TITLE">                      <xs:annotation>                        <xs:documentation>Section title.</xs:documentation>                      </xs:annotation>                    </xs:element>                    <xs:element name="INTRODUCTION" minOccurs="0">                      <xs:annotation>                        <xs:documentation>Section contents description.</xs:documentation>                      </xs:annotation>                      <xs:complexType>                        <xs:sequence>                          <xs:element ref="LATEX" minOccurs="1" maxOccurs="unbounded"/>                        </xs:sequence>                      </xs:complexType>                    </xs:element>                    <xs:element name="SUBSECTIONS" minOccurs="0">                      <xs:annotation>                        <xs:documentation>List of subsections.</xs:documentation>                      </xs:annotation>                      <xs:complexType>                        <xs:sequence>                          <xs:element ref="SUBSECTIONTYPE" minOccurs="1" maxOccurs="unbounded"/>                        </xs:sequence>                      </xs:complexType>                    </xs:element>                  </xs:sequence>                  <xs:attribute name="noNumber" type="xs:boolean" use="optional">                    <xs:annotation>                      <xs:documentation>Should this section be numbered?.</xs:documentation>                    </xs:annotation>                  </xs:attribute>                </xs:complexType>              </xs:element>            </xs:sequence>            <xs:attribute name="noNumber" type="xs:boolean" use="optional">              <xs:annotation>                <xs:documentation>Should this section be numbered?.</xs:documentation>              </xs:annotation>            </xs:attribute>          </xs:complexType>        </xs:element>        <xs:element name="BIBLIOGRAPHY" minOccurs="0">          <xs:annotation>            <xs:documentation>Literature references.</xs:documentation>          </xs:annotation>          <xs:complexType>            <xs:sequence>              <xs:element name="ITEM" minOccurs="0" maxOccurs="unbounded">                <xs:annotation>                  <xs:documentation>Single literature reference.</xs:documentation>                </xs:annotation>                <xs:complexType>                  <xs:sequence>                    <xs:element ref="LATEX" maxOccurs="unbounded"/>                  </xs:sequence>                  <xs:attribute name="label" type="xs:NMTOKEN" use="required">                    <xs:annotation>                      <xs:documentation>Label for this reference. This label must be unique within this module.</xs:documentation>                    </xs:annotation>                  </xs:attribute>                </xs:complexType>              </xs:element>            </xs:sequence>          </xs:complexType>        </xs:element>      </xs:sequence>    </xs:complexType>  </xs:element>  <xs:element name="TITLE">    <xs:annotation>      <xs:documentation>Title of a text segment.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="LATEX" maxOccurs="unbounded"/>      </xs:sequence>    </xs:complexType>  </xs:element>  <xs:element name="LATEX">    <xs:annotation>      <xs:documentation>For each supported language entry one can find a LaTeX text here.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:simpleContent>        <xs:extension base="xs:string">          <xs:attribute name="language" type="xs:language" use="optional"/>        </xs:extension>      </xs:simpleContent>    </xs:complexType>  </xs:element>  <xs:element name="SPECIFICATION">    <xs:annotation>      <xs:documentation>File specification of this module. What is the name of this module and where to find it.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element name="LOCATIONS">          <xs:annotation>           <xs:documentation>List of locations to find the QEDEQ module.</xs:documentation>          </xs:annotation>          <xs:complexType>            <xs:sequence>              <xs:element name="LOCATION" maxOccurs="unbounded">                <xs:annotation>                  <xs:documentation>Location of a QEDEQ module.</xs:documentation>                </xs:annotation>                <xs:complexType>                <xs:attribute name="value" type="LOCATIONTYPE" use="required">                  <xs:annotation>                    <xs:documentation>URL to location of a QEDEQ module directory.</xs:documentation>                  </xs:annotation>                </xs:attribute>                </xs:complexType>              </xs:element>            </xs:sequence>          </xs:complexType>        </xs:element>      </xs:sequence>      <xs:attribute name="name" type="xs:string" use="required">        <xs:annotation>          <xs:documentation>Technical name of QEDEQ module. Also the main part of the file name. The complete name has ".xml" appended. Together with an LOCATION the complete path to a QEDEQ module can be build.</xs:documentation>        </xs:annotation>      </xs:attribute>      <xs:attribute name="ruleVersion" type="xs:string" use="required">        <xs:annotation>          <xs:documentation>Locical rule version that is needed to be able to make the derivations made in the QEDEQ module.</xs:documentation>        </xs:annotation>      </xs:attribute>    </xs:complexType>  </xs:element>  <xs:element name="TERMTYPE" abstract="true">    <xs:annotation>      <xs:documentation>Type for a term.</xs:documentation>    </xs:annotation>  </xs:element>    <xs:element name="TERM">    <xs:annotation>      <xs:documentation>Logical language: Term.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="TERMTYPE"/>      </xs:sequence>    </xs:complexType>  </xs:element>  <xs:element name="VAR" substitutionGroup="TERMTYPE">    <xs:annotation>      <xs:documentation>Logical language: Subject variable.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:attribute name="id" type="xs:string" use="required">        <xs:annotation>          <xs:documentation>Identifies a subject variable. Also used as a LaTeX expression for this variable.</xs:documentation>        </xs:annotation>      </xs:attribute>    </xs:complexType>  </xs:element>  <xs:element name="FUNCON" substitutionGroup="TERMTYPE">    <xs:annotation>      <xs:documentation>Logical language: Function constant.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="TERMTYPE" minOccurs="0" maxOccurs="unbounded"/>      </xs:sequence>      <xs:attribute name="ref" type="xs:string" use="required">        <xs:annotation>          <xs:documentation>References a function constant definition. The function constant must be defined within this or an imported module. For an external reference the name must begin with the appropiate label follwed by an dot. </xs:documentation>        </xs:annotation>      </xs:attribute>    </xs:complexType>  </xs:element>  <xs:element name="FUNVAR" substitutionGroup="TERMTYPE">    <xs:annotation>      <xs:documentation>Logical language: Function variable.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="TERMTYPE" maxOccurs="unbounded"/>      </xs:sequence>      <xs:attribute name="id" type="xs:string" use="required">        <xs:annotation>          <xs:documentation>Identifies a function variable. Also used as a LaTeX expression for this variable.</xs:documentation>        </xs:annotation>      </xs:attribute>    </xs:complexType>  </xs:element>  <xs:element name="CLASS" substitutionGroup="TERMTYPE">    <xs:annotation>      <xs:documentation>Logical language: Class described by property. For example {x | x = x }.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="VAR" minOccurs="1" maxOccurs="1"/>        <xs:element ref="FORMULATYPE" minOccurs="1" maxOccurs="1"/>      </xs:sequence>    </xs:complexType>  </xs:element>  <xs:element name="QUANTIFIER_INTERSECTION" substitutionGroup="TERMTYPE">    <xs:annotation>      <xs:documentation>Logical language: Intersection about all classes that fullfil a property.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="VAR" minOccurs="1" maxOccurs="1"/>        <xs:element ref="FORMULATYPE" minOccurs="1" maxOccurs="1"/>      </xs:sequence>    </xs:complexType>  </xs:element>  <xs:element name="QUANTIFIER_UNION" substitutionGroup="TERMTYPE">    <xs:annotation>      <xs:documentation>Logical language: Union about all classes that fullfil a property.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="VAR" minOccurs="1" maxOccurs="1"/>        <xs:element ref="FORMULATYPE" minOccurs="1" maxOccurs="1"/>      </xs:sequence>    </xs:complexType>  </xs:element>  <xs:element name="FORMULA">    <xs:annotation>      <xs:documentation>Logical language: Formula.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="FORMULATYPE"/>      </xs:sequence>    </xs:complexType>  </xs:element>    <xs:element name="FORMULATYPE" abstract="true">    <xs:annotation>      <xs:documentation>Type for a formula.</xs:documentation>    </xs:annotation>  </xs:element>  <xs:element name="PREDCON" substitutionGroup="FORMULATYPE">    <xs:annotation>      <xs:documentation>Logical language: Predicate constant.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="TERMTYPE" minOccurs="0" maxOccurs="unbounded"/>      </xs:sequence>      <xs:attribute name="ref" type="xs:string" use="required">        <xs:annotation>          <xs:documentation>References a predicate constant definition. The predicate constant must be defined within this or an imported module. For an external reference the name must begin with the appropiate label follwed by an dot. </xs:documentation>        </xs:annotation>      </xs:attribute>    </xs:complexType>  </xs:element>  <xs:element name="PREDVAR" substitutionGroup="FORMULATYPE">    <xs:annotation>      <xs:documentation>Logical language: Predicate variable.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="TERMTYPE" minOccurs="0" maxOccurs="unbounded"/>      </xs:sequence>      <xs:attribute name="id" type="xs:string" use="required">        <xs:annotation>          <xs:documentation>Identifies a predicate variable. Also used as a LaTeX expression for this variable.</xs:documentation>        </xs:annotation>      </xs:attribute>    </xs:complexType>  </xs:element>  <xs:element name="EXISTS" substitutionGroup="FORMULATYPE">    <xs:annotation>      <xs:documentation>Logical language: Logical existential quantifier.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="VAR" minOccurs="1"/>        <xs:element ref="FORMULATYPE"/>        <xs:element ref="FORMULATYPE" minOccurs="0"/>      </xs:sequence>    </xs:complexType>  </xs:element>  <xs:element name="EXISTSU" substitutionGroup="FORMULATYPE">    <xs:annotation>      <xs:documentation>Logical language: Logical uniqueness quantifier. Proposes the existence of an unique element.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="VAR" minOccurs="1"/>        <xs:element ref="FORMULATYPE"/>        <xs:element ref="FORMULATYPE" minOccurs="0"/>      </xs:sequence>    </xs:complexType>  </xs:element>  <xs:element name="FORALL" substitutionGroup="FORMULATYPE">    <xs:annotation>      <xs:documentation>Logical language: Logical universal quantifier.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="VAR" minOccurs="1"/>        <xs:element ref="FORMULATYPE"/>        <xs:element ref="FORMULATYPE" minOccurs="0"/>      </xs:sequence>    </xs:complexType>  </xs:element>  <xs:element name="AND" substitutionGroup="FORMULATYPE">    <xs:annotation>      <xs:documentation>Logical language: Logical conjunction.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="FORMULATYPE" maxOccurs="unbounded"/>      </xs:sequence>    </xs:complexType>  </xs:element>  <xs:element name="OR" substitutionGroup="FORMULATYPE">    <xs:annotation>      <xs:documentation>Logical language: Logical disjunction.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="FORMULATYPE" maxOccurs="unbounded"/>      </xs:sequence>    </xs:complexType>  </xs:element>  <xs:element name="EQUI" substitutionGroup="FORMULATYPE">    <xs:annotation>      <xs:documentation>Logical language: Logical equivalence.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="FORMULATYPE" maxOccurs="unbounded"/>      </xs:sequence>    </xs:complexType>  </xs:element>  <xs:element name="IMPL" substitutionGroup="FORMULATYPE">    <xs:annotation>      <xs:documentation>Logical language: Logical implication.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="FORMULATYPE"/>        <xs:element ref="FORMULATYPE"/>      </xs:sequence>    </xs:complexType>  </xs:element>  <xs:element name="NOT" substitutionGroup="FORMULATYPE">    <xs:annotation>      <xs:documentation>Logical language: Logical negation.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="FORMULATYPE"/>      </xs:sequence>    </xs:complexType>  </xs:element>  <xs:element name="SUBSECTIONTYPE" abstract="true">    <xs:annotation>      <xs:documentation>Type for a subsection.</xs:documentation>    </xs:annotation>  </xs:element>  <xs:element name="SUBSECTION" substitutionGroup="SUBSECTIONTYPE">    <xs:annotation>      <xs:documentation>This a normal LaTeX subsection of a section.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="TITLE" minOccurs="0">          <xs:annotation>            <xs:documentation>Subsection title.</xs:documentation>          </xs:annotation>        </xs:element>        <xs:element name="TEXT" minOccurs="0">          <xs:annotation>            <xs:documentation>The LaTeX text of this subsection.</xs:documentation>          </xs:annotation>          <xs:complexType>            <xs:sequence>              <xs:element ref="LATEX" minOccurs="0" maxOccurs="unbounded"/>            </xs:sequence>          </xs:complexType>        </xs:element>      </xs:sequence>      <xs:attribute name="id" type="xs:NMTOKEN" use="optional">        <xs:annotation>          <xs:documentation>Reference id for this subsection.</xs:documentation>        </xs:annotation>      </xs:attribute>      <xs:attribute name="level" type="xs:string">        <xs:annotation>          <xs:documentation>Detail level of this subsection.</xs:documentation>        </xs:annotation>      </xs:attribute>    </xs:complexType>  </xs:element>  <xs:element name="NODE" substitutionGroup="SUBSECTIONTYPE">    <xs:annotation>      <xs:documentation>This part is the smallest unit and corresponds to the LaTeX item subsection. But it also carries formal AXIOMs, THEOREMS or else.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element name="NAME" minOccurs="0">          <xs:annotation>            <xs:documentation>Short text to describe this item. Used when referencing to this.</xs:documentation>          </xs:annotation>          <xs:complexType>            <xs:sequence>              <xs:element ref="LATEX" maxOccurs="unbounded"/>            </xs:sequence>          </xs:complexType>        </xs:element>        <xs:element ref="TITLE" minOccurs="0">          <xs:annotation>            <xs:documentation>Subsection title.</xs:documentation>          </xs:annotation>        </xs:element>        <xs:element ref="PRECEDING" minOccurs="0"/>        <xs:element ref="NODETYPE">          <xs:annotation>            <xs:documentation>Mathematical meat. For example an axiom, proposition, definition etc.</xs:documentation>          </xs:annotation>        </xs:element>        <xs:element name="SUCCEEDING" minOccurs="0"/>      </xs:sequence>      <xs:attribute name="id" type="xs:string" use="required">        <xs:annotation>          <xs:documentation>Reference id for this node.</xs:documentation>        </xs:annotation>      </xs:attribute>            <xs:attribute name="level" type="xs:string">        <xs:annotation>          <xs:documentation>Detail level of this subsection.</xs:documentation>        </xs:annotation>      </xs:attribute>    </xs:complexType>  </xs:element>  <xs:element name="PRECEDING">    <xs:annotation>      <xs:documentation>Text that precedes the mathematical meat.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="LATEX" minOccurs="1" maxOccurs="unbounded"/>      </xs:sequence>    </xs:complexType>  </xs:element>  <xs:element name="SUCCEEDING">    <xs:annotation>      <xs:documentation>Text that succeeds mathematical meat.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="LATEX" minOccurs="1" maxOccurs="unbounded"/>      </xs:sequence>    </xs:complexType>  </xs:element>  <xs:element name="NODETYPE" abstract="true">    <xs:annotation>      <xs:documentation>Type for a node. This might be an AXIOM, THEOREM or something else.</xs:documentation>    </xs:annotation>  </xs:element>  <xs:element name="DEFINITION_PREDICATE" substitutionGroup="NODETYPE">    <xs:annotation>      <xs:documentation>Definition of a predicate constant. The attributes "name" and "arguments" must be unique within one QEDEQ module.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element name="LATEXPATTERN" type="xs:string">          <xs:annotation>            <xs:documentation>LaTeX pattern for predicate with arguments as #&lt;n&gt;.</xs:documentation>          </xs:annotation>        </xs:element>        <xs:element ref="FORMULA" minOccurs="1">          <xs:annotation>            <xs:documentation>Equivalence formula with two operands. First must be the predicate with pairwaise different subject variables as arguments. Second operand must be the defining formula for the predicate.</xs:documentation>          </xs:annotation>        </xs:element>        <xs:element name="DESCRIPTION" minOccurs="0">          <xs:annotation>            <xs:documentation>Additional description.</xs:documentation>          </xs:annotation>          <xs:complexType>            <xs:sequence>              <xs:element ref="LATEX" minOccurs="1" maxOccurs="unbounded"/>            </xs:sequence>          </xs:complexType>        </xs:element>      </xs:sequence>      <xs:attribute name="arguments" type="xs:NMTOKEN" use="required">        <xs:annotation>          <xs:documentation>Number of arguments for the new predicate.</xs:documentation>        </xs:annotation>      </xs:attribute>      <xs:attribute name="name" type="xs:string" use="required">        <xs:annotation>          <xs:documentation>Name for the new predicate. This name must not occur as a label within this module.</xs:documentation>        </xs:annotation>      </xs:attribute>    </xs:complexType>  </xs:element>  <xs:element name="DEFINITION_PREDICATE_INITIAL" substitutionGroup="NODETYPE">    <xs:annotation>      <xs:documentation>Definition of an initial predicate constant. The combination of attributes "name" and "arguments" must be unique within one QEDEQ module.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element name="LATEXPATTERN" type="xs:string">          <xs:annotation>            <xs:documentation>LaTeX pattern for predicate with arguments as #&lt;n&gt;.</xs:documentation>          </xs:annotation>        </xs:element>        <xs:element ref="PREDCON" minOccurs="1">          <xs:annotation>            <xs:documentation>Predicate constant we want to define. Arguments must be free subjectvariables.</xs:documentation>          </xs:annotation>        </xs:element>        <xs:element name="DESCRIPTION" minOccurs="0">          <xs:annotation>            <xs:documentation>Additional description.</xs:documentation>          </xs:annotation>          <xs:complexType>            <xs:sequence>              <xs:element ref="LATEX" minOccurs="1" maxOccurs="unbounded"/>            </xs:sequence>          </xs:complexType>        </xs:element>      </xs:sequence>      <xs:attribute name="arguments" type="xs:NMTOKEN" use="required">        <xs:annotation>          <xs:documentation>Number of arguments for the new predicate.</xs:documentation>        </xs:annotation>      </xs:attribute>      <xs:attribute name="name" type="xs:string" use="required">        <xs:annotation>          <xs:documentation>Name for the new predicate. This name must not occur as a label within this module.</xs:documentation>        </xs:annotation>      </xs:attribute>    </xs:complexType>  </xs:element>  <xs:element name="DEFINITION_FUNCTION_INITIAL" substitutionGroup="NODETYPE">    <xs:annotation>      <xs:documentation>Definition of an basic function constant. The combination of the attributes "name" and "arguments" must be unique within one QEDEQ module."</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element name="LATEXPATTERN" type="xs:string">          <xs:annotation>            <xs:documentation>LaTeX pattern for function with arguments as #&lt;n&gt;.</xs:documentation>          </xs:annotation>        </xs:element>        <xs:element ref="FUNCON" minOccurs="1">          <xs:annotation>            <xs:documentation>Basic function constant that will be defined. Must have free subject variables as arguments (or none at all).</xs:documentation>          </xs:annotation>        </xs:element>        <xs:element name="DESCRIPTION" minOccurs="0">          <xs:annotation>            <xs:documentation>Additional description.</xs:documentation>          </xs:annotation>          <xs:complexType>            <xs:sequence>              <xs:element ref="LATEX" minOccurs="1" maxOccurs="unbounded"/>            </xs:sequence>          </xs:complexType>        </xs:element>      </xs:sequence>      <xs:attribute name="arguments" type="xs:string" use="required">        <xs:annotation>          <xs:documentation>Number of arguments for the new function.</xs:documentation>        </xs:annotation>      </xs:attribute>      <xs:attribute name="name" type="xs:string" use="required">        <xs:annotation>          <xs:documentation>Name for the new function. This name must not occur as a label within this module.</xs:documentation>        </xs:annotation>      </xs:attribute>    </xs:complexType>  </xs:element>  <xs:element name="DEFINITION_FUNCTION" substitutionGroup="NODETYPE">    <xs:annotation>      <xs:documentation>Definition of a function constant. The combination of the attributes "name" and "arguments" must be unique within one QEDEQ module.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element name="LATEXPATTERN" type="xs:string">          <xs:annotation>            <xs:documentation>LaTeX pattern for function with arguments as #&lt;n&gt;.</xs:documentation>          </xs:annotation>        </xs:element>        <xs:element ref="FORMULA" minOccurs="1">          <xs:annotation>            <xs:documentation>Defining formula for function constant. This must be an equals releation with the new function constant as first argument.</xs:documentation>          </xs:annotation>        </xs:element>        <xs:element name="DESCRIPTION" minOccurs="0">          <xs:annotation>            <xs:documentation>Additional description.</xs:documentation>          </xs:annotation>          <xs:complexType>            <xs:sequence>              <xs:element ref="LATEX" minOccurs="1" maxOccurs="unbounded"/>            </xs:sequence>          </xs:complexType>        </xs:element>      </xs:sequence>      <xs:attribute name="arguments" type="xs:string" use="required">        <xs:annotation>          <xs:documentation>Number of arguments for the new function.</xs:documentation>        </xs:annotation>      </xs:attribute>      <xs:attribute name="name" type="xs:string" use="required">        <xs:annotation>          <xs:documentation>Name for the new function. This name must not occur as a label within this module.</xs:documentation>        </xs:annotation>      </xs:attribute>    </xs:complexType>  </xs:element>  <xs:element name="AXIOM" substitutionGroup="NODETYPE">    <xs:annotation>      <xs:documentation>Mathematical axiom.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="FORMULA">          <xs:annotation>            <xs:documentation>An axiom formula.</xs:documentation>          </xs:annotation>        </xs:element>        <xs:element name="DESCRIPTION" minOccurs="0">          <xs:annotation>            <xs:documentation>Additional description.</xs:documentation>          </xs:annotation>          <xs:complexType>            <xs:sequence>              <xs:element ref="LATEX" minOccurs="1" maxOccurs="unbounded"/>            </xs:sequence>          </xs:complexType>        </xs:element>      </xs:sequence>      <xs:attribute name="definedOperator" type="xs:string">        <xs:annotation>          <xs:documentation>Axiom defines an operator. This operator can be elimnated by using this axiom. So this axiom is not neccessary for the theory. It leads just to a conservative language extension.</xs:documentation>        </xs:annotation>      </xs:attribute>    </xs:complexType>  </xs:element>  <xs:element name="RULE" substitutionGroup="NODETYPE">    <xs:annotation>      <xs:documentation>A new meta rule.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>          <xs:element name="LINK" minOccurs="0" maxOccurs="unbounded">          <xs:annotation>            <xs:documentation>References to theorems or axioms.</xs:documentation>          </xs:annotation>          <xs:complexType>                <xs:attribute name="id" type="xs:string" use="required"/>          </xs:complexType>          </xs:element>        <xs:element name="DESCRIPTION" minOccurs="1">          <xs:annotation>            <xs:documentation>Additional description.</xs:documentation>          </xs:annotation>          <xs:complexType>            <xs:sequence>              <xs:element ref="LATEX" minOccurs="1" maxOccurs="unbounded"/>            </xs:sequence>          </xs:complexType>        </xs:element>        <xs:element name="CHANGED_RULE" minOccurs="0" maxOccurs="unbounded">          <xs:annotation>            <xs:documentation>Modifications to other existing rules.</xs:documentation>          </xs:annotation>          <xs:complexType>            <xs:sequence>              <xs:element ref="LATEX" minOccurs="1" maxOccurs="unbounded"/>            </xs:sequence>            <xs:attribute name="name" type="xs:string" use="required"/>            <xs:attribute name="version" type="xs:string" use="required">              <xs:annotation>                <xs:documentation>Version of this rule. In combination with the name it identifies a previous rule.</xs:documentation>              </xs:annotation>            </xs:attribute>          </xs:complexType>        </xs:element>        <xs:element name="PROOF" minOccurs="0" maxOccurs="unbounded">          <xs:annotation>            <xs:documentation>Informal proof for this rule.</xs:documentation>          </xs:annotation>          <xs:complexType>            <xs:sequence>              <xs:element ref="LATEX" minOccurs="1" maxOccurs="unbounded"/>            </xs:sequence>            <xs:attribute name="kind" type="xs:NMTOKEN" use="required"/>            <xs:attribute name="level" type="xs:string" use="required"/>          </xs:complexType>        </xs:element>      </xs:sequence>      <xs:attribute name="name" type="xs:string" use="required"/>      <xs:attribute name="version" type="xs:string" use="required">        <xs:annotation>          <xs:documentation>Version of this rule. In combination with the name a rule must be unique.</xs:documentation>        </xs:annotation>      </xs:attribute>    </xs:complexType>  </xs:element>  <xs:element name="THEOREM" substitutionGroup="NODETYPE">    <xs:annotation>      <xs:documentation>A theorem and it's proof.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="FORMULA">          <xs:annotation>            <xs:documentation>This formula is the theorem.</xs:documentation>          </xs:annotation>        </xs:element>        <xs:element name="DESCRIPTION" minOccurs="0">          <xs:annotation>            <xs:documentation>Additional description.</xs:documentation>          </xs:annotation>          <xs:complexType>            <xs:sequence>              <xs:element ref="LATEX" minOccurs="1" maxOccurs="unbounded"/>            </xs:sequence>          </xs:complexType>        </xs:element>        <xs:element ref="PROOF" minOccurs="0" maxOccurs="unbounded"/>        <xs:element ref="FORMAL_PROOF" minOccurs="0" maxOccurs="unbounded"/>      </xs:sequence>    </xs:complexType>  </xs:element>  <xs:element name="PROOF">    <xs:annotation>      <xs:documentation>An informal proof.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="LATEX" minOccurs="1" maxOccurs="unbounded"/>      </xs:sequence>      <xs:attribute name="kind" type="xs:NMTOKEN" use="required"/>      <xs:attribute name="level" type="xs:string" use="required"/>    </xs:complexType>  </xs:element>  <xs:element name="FORMAL_PROOF">    <xs:annotation>      <xs:documentation>A formal proof.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="PRECEDING" minOccurs="0" maxOccurs="1"/>        <xs:element ref="LINES" />        <xs:element ref="SUCCEEDING" minOccurs="0" maxOccurs="1"/>      </xs:sequence>    </xs:complexType>  </xs:element>  <xs:element name="LINES">    <xs:annotation>      <xs:documentation>List of proof lines.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="LINETYPE" minOccurs="1" maxOccurs="unbounded"/>      </xs:sequence>    </xs:complexType>  </xs:element>  <xs:element name="LINETYPE" abstract="true">    <xs:annotation>      <xs:documentation>Type for a proof line of a formal proof.</xs:documentation>    </xs:annotation>  </xs:element>  <xs:element name="L" substitutionGroup="LINETYPE">    <xs:annotation>      <xs:documentation>A proofline that derives from previous derived formulas.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="FORMULA" minOccurs="1" maxOccurs="1">          <xs:annotation>            <xs:documentation>New derived formula.</xs:documentation>          </xs:annotation>        </xs:element>        <xs:element ref="REASONTYPE" minOccurs="1" maxOccurs="1">          <xs:annotation>            <xs:documentation>References the rule and extra parameters that we need to get the new proof line.</xs:documentation>          </xs:annotation>        </xs:element>      </xs:sequence>      <xs:attribute name="label" type="xs:NMTOKEN">        <xs:annotation>          <xs:documentation>May be needed for back references.</xs:documentation>        </xs:annotation>      </xs:attribute>    </xs:complexType>  </xs:element>  <xs:element name="CP" substitutionGroup="LINETYPE">    <xs:annotation>      <xs:documentation>A proofline that includes a conditional proof. This is a usage of the deduction theorem. If the hypothesis formulas are H1, H2 and H3 and the last proof is A the proved formula is H1 &amp; H2 &amp; H3 -&gt; A      Can be used with rule version 0.02.00.      </xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element name="HYPOTHESIS" minOccurs="1" maxOccurs="unbounded">          <xs:annotation>            <xs:documentation>We assume this formula.</xs:documentation>          </xs:annotation>          <xs:complexType>            <xs:sequence>              <xs:element ref="FORMULA" minOccurs="0" maxOccurs="1">                <xs:annotation>                  <xs:documentation>Replacement formula.</xs:documentation>                </xs:annotation>              </xs:element>            </xs:sequence>            <xs:attribute name="label" type="xs:NMTOKEN">              <xs:annotation>                <xs:documentation>May be needed for back references.</xs:documentation>              </xs:annotation>            </xs:attribute>          </xs:complexType>        </xs:element>        <xs:element ref="LINES" minOccurs="1" maxOccurs="1">          <xs:annotation>            <xs:documentation>Formal proof lines that can also make references to proof lines at higher level.</xs:documentation>          </xs:annotation>        </xs:element>        <xs:element name="CONCLUSION" minOccurs="1" maxOccurs="1">          <xs:annotation>            <xs:documentation>We derive this formula as a conclusion.</xs:documentation>          </xs:annotation>          <xs:complexType>            <xs:sequence>              <xs:element ref="FORMULA" minOccurs="0" maxOccurs="1">                <xs:annotation>                  <xs:documentation>Replacement formula.</xs:documentation>                </xs:annotation>              </xs:element>            </xs:sequence>            <xs:attribute name="label" type="xs:NMTOKEN">              <xs:annotation>                <xs:documentation>May be needed for back references.</xs:documentation>              </xs:annotation>            </xs:attribute>          </xs:complexType>        </xs:element>      </xs:sequence>    </xs:complexType>  </xs:element>  <xs:element name="REASONTYPE" abstract="true">    <xs:annotation>      <xs:documentation>Type for a rule that can derive a new formula.</xs:documentation>    </xs:annotation>  </xs:element>    <xs:element name="MP" substitutionGroup="REASONTYPE">    <xs:annotation>      <xs:documentation>The rule Modus Ponens (or for short MP) is the sole rule of inference in propositional calculus. For rule version 0.01.00.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:attribute name="ref1" type="xs:string">        <xs:annotation>          <xs:documentation>Identifies a previous a proof line, axiom, definition or proposition. Must be of the form A -&gt; B.</xs:documentation>        </xs:annotation>      </xs:attribute>      <xs:attribute name="ref2" type="xs:string">        <xs:annotation>          <xs:documentation>Identifies a previous a proof line, axiom, definition or proposition. Must be same as B in ref1</xs:documentation>        </xs:annotation>      </xs:attribute>    </xs:complexType>  </xs:element>  <xs:element name="ADD" substitutionGroup="REASONTYPE">    <xs:annotation>      <xs:documentation>Add already proven formula. For rule version 0.01.00.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:attribute name="ref" type="xs:string">        <xs:annotation>          <xs:documentation>Identifies a previous a proof line, axiom, definition or proposition.</xs:documentation>        </xs:annotation>      </xs:attribute>    </xs:complexType>  </xs:element>  <xs:element name="RENAME" substitutionGroup="REASONTYPE">    <xs:annotation>      <xs:documentation>Rename of bound subject variable at given occurrence by another one. For rule version 0.01.00.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="VAR" minOccurs="0" maxOccurs="2">          <xs:annotation>            <xs:documentation>Replace this bound subject variable, by the second one.</xs:documentation>          </xs:annotation>        </xs:element>      </xs:sequence>      <xs:attribute name="ref" type="xs:string">        <xs:annotation>          <xs:documentation></xs:documentation>        </xs:annotation>      </xs:attribute>      <xs:attribute name="occurrence" type="xs:int">        <xs:annotation>          <xs:documentation>Marks the occurence of the bound subject variable.</xs:documentation>        </xs:annotation>      </xs:attribute>    </xs:complexType>  </xs:element>  <xs:element name="SUBST_FREE" substitutionGroup="REASONTYPE">    <xs:annotation>      <xs:documentation>Substitute of free subject variable by term. For rule version 0.01.00.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="VAR" minOccurs="0" maxOccurs="1">          <xs:annotation>            <xs:documentation>Replace this free subject variable.</xs:documentation>          </xs:annotation>        </xs:element>        <xs:element ref="TERM" minOccurs="0" maxOccurs="1">          <xs:annotation>            <xs:documentation>Replacement term.</xs:documentation>          </xs:annotation>        </xs:element>      </xs:sequence>      <xs:attribute name="ref" type="xs:string">        <xs:annotation>          <xs:documentation></xs:documentation>        </xs:annotation>      </xs:attribute>    </xs:complexType>  </xs:element>  <xs:element name="SUBST_FUNVAR" substitutionGroup="REASONTYPE">    <xs:annotation>      <xs:documentation>Substitute of function variable by term. For rule version 0.01.00.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="FUNVAR" minOccurs="0" maxOccurs="1">          <xs:annotation>            <xs:documentation>Replace this function variable.</xs:documentation>          </xs:annotation>        </xs:element>        <xs:element ref="TERM" minOccurs="0" maxOccurs="1">          <xs:annotation>            <xs:documentation>Replacement term.</xs:documentation>          </xs:annotation>        </xs:element>      </xs:sequence>      <xs:attribute name="ref" type="xs:string">        <xs:annotation>          <xs:documentation></xs:documentation>        </xs:annotation>      </xs:attribute>    </xs:complexType>  </xs:element>  <xs:element name="SUBST_PREDVAR" substitutionGroup="REASONTYPE">    <xs:annotation>      <xs:documentation>Substitute of predicate variable by formula. For rule version 0.01.00.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="PREDVAR" minOccurs="0" maxOccurs="1">          <xs:annotation>            <xs:documentation>Replace this predicate variable.</xs:documentation>          </xs:annotation>        </xs:element>        <xs:element ref="FORMULA" minOccurs="0" maxOccurs="1">          <xs:annotation>            <xs:documentation>Replacement formula.</xs:documentation>          </xs:annotation>        </xs:element>      </xs:sequence>      <xs:attribute name="ref" type="xs:string">        <xs:annotation>          <xs:documentation></xs:documentation>        </xs:annotation>      </xs:attribute>    </xs:complexType>  </xs:element>  <xs:element name="EXISTENTIAL" substitutionGroup="REASONTYPE">    <xs:annotation>      <xs:documentation>Rule of existential generalization. For rule version 0.01.00.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="VAR" minOccurs="0" maxOccurs="1">          <xs:annotation>            <xs:documentation>Replace this free subject variable.</xs:documentation>          </xs:annotation>        </xs:element>      </xs:sequence>      <xs:attribute name="ref" type="xs:string">        <xs:annotation>          <xs:documentation></xs:documentation>        </xs:annotation>      </xs:attribute>    </xs:complexType>  </xs:element>  <xs:element name="UNIVERSAL" substitutionGroup="REASONTYPE">    <xs:annotation>      <xs:documentation>Rule of universal generalization. For rule version 0.01.00.</xs:documentation>    </xs:annotation>    <xs:complexType>      <xs:sequence>        <xs:element ref="VAR" minOccurs="0" maxOccurs="1">          <xs:annotation>            <xs:documentation>Replace this free subject variable.</xs:documentation>          </xs:annotation>        </xs:element>      </xs:sequence>      <xs:attribute name="ref" type="xs:string">        <xs:annotation>          <xs:documentation></xs:documentation>        </xs:annotation>      </xs:attribute>    </xs:complexType>  </xs:element>  <xs:simpleType name="EMAILTYPE">    <xs:annotation>      <xs:documentation>Type for an email. An email address.</xs:documentation>    </xs:annotation>    <xs:restriction base="xs:token">      <xs:minLength value="0" />      <xs:maxLength value="200" />    </xs:restriction>  </xs:simpleType>  <xs:simpleType name="LOCATIONTYPE">    <xs:annotation>      <xs:documentation>Type for a location. Location directory of module.</xs:documentation>    </xs:annotation>    <xs:restriction base="xs:anyURI">    </xs:restriction>  </xs:simpleType>  <xs:simpleType name="LEVELTYPE">    <xs:annotation>      <xs:documentation>Type for a level. Detail level.</xs:documentation>    </xs:annotation>    <xs:restriction base="xs:byte">    </xs:restriction>  </xs:simpleType></xs:schema>