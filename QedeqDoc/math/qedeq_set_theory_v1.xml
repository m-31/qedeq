<?xml version="1.0" encoding="UTF-8"?>
<QEDEQ
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="http://www.qedeq.org/0_04_07/xml/qedeq.xsd">
  <HEADER email="mime@qedeq.org">
    <SPECIFICATION name="qedeq_set_theory_v1" ruleVersion="1.00.00">
      <LOCATIONS>
        <LOCATION value="http://www.qedeq.org/0_04_07/doc/math"/>
      </LOCATIONS>
    </SPECIFICATION>
    <TITLE>
      <LATEX language="en">
         Axiomatic Set Theory
      </LATEX>
      <LATEX language="de">
         Axiomatische Mengenlehre
      </LATEX>
    </TITLE>
    <ABSTRACT>
      <LATEX language="en">
        <![CDATA[
          This document contains the mathematical foundation of set theory. Goal is the presentation of elementary results which are needed within other mathematical disciplines. After the basics the {\emph boolean algebra of classes} is in focus. Next are some thoughts about \emph{relations} and \emph{functions}. An important achivement is the definition of the \emph{natural~numbers} and their fulfillment of the \emph{Peano axioms}. Also the word \emph{recursion} is discussed.
          
          \par
          Although the presentation is axiomatic the results shall match the mathematical usage. For that reason the set theoretic axiom system of \emph{A.~P.~Morse} and \emph{J.~L.~Kelley} (MK\index{MK})was chosen.

          \par
          This document is not finished and is updated from time to time.
        ]]>
      </LATEX>
      <LATEX language="de">
        <![CDATA[
         Dieses Dokument beschreibt die mathematischen Grundlagen der Mengenlehre. Ziel ist dabei die Bereitstellung von elementaren Ergebnissen der Mengenlehre, die in anderen mathematischen Disziplinen benötigt werden. Nach den Anfangsgründen wird die {\emph Boolsche Algebra der Klassen} betrachtet. Es schliessen sich Betrachtungen über {\emph Relationen} und {\emph Funktionen} an. Ein wichtiges Ergebnis sind die Definition der {\emph natürlichen Zahlen} und die Erfüllung der {\emph Peano-Axiome} durch diese. Auch auf den Begriff der {\emph Rekursion} wird eingegangen.

         \par
         Die Darstellung erfolgt in axiomatischer Weise soll aber im Ergebnis der mathematischen Praxis entsprechen. Aus diesem Grunde wird auch das Axiomensystem der Mengenlehre von \emph{A.~P.~Morse} und  \emph{J.~L.~Kelley} (MK\index{MK}) verwendet.

         \par
         Dieses Dokument ist noch nicht fertiggestellt und wird von Zeit zu Zeit aktualisiert.
        ]]>
      </LATEX>
    </ABSTRACT>
    <AUTHORS>
      <AUTHOR email="michael@meyling.com">
        <NAME>
          <LATEX language="de">
            Michael Meyling
          </LATEX>
        </NAME>
      </AUTHOR>
    </AUTHORS>
    <IMPORTS>
      <IMPORT label="l">
        <SPECIFICATION name="qedeq_logic_v1" ruleVersion="1.00.00">
          <LOCATIONS>
            <LOCATION value="."/>
            <LOCATION value="http://www.qedeq.org/0_04_07/doc/math"/>
          </LOCATIONS>
        </SPECIFICATION>
      </IMPORT>
    </IMPORTS>
  </HEADER>


  <CHAPTER noNumber="true">
    <TITLE>
      <LATEX language="en">
        Preface\label{ch:preface}
      </LATEX>
      <LATEX language="de">
        Vorwort\label{ch:preface}
      </LATEX>
    </TITLE>
    <INTRODUCTION>
      <LATEX language="en">
        <![CDATA[
          Mathematics is a science with a structure that achieved enormous dimensions in the course of time. This huge stronghold has only a small set theoretic foundation and its firmness rests upon simple predicate calculus mortar. In principle the assembly could be comprehended by any mathematician. From every newest turret of mathematical cognition each path of logical dependency could be followed all the way down to its set theoretic roots.
          
          \par
          This document wants to provide some help to accomplish this task. What we aim at is to get an understandable
          presentation of the set theoretic roots. But despite all comprehensibility it is possible to drill very deep into details. Even into the level of a formal proof. For that purpose this document will exist in different detail levels. The original source of this document is written in a formal language. So it is possible to prove the propositions automatically with a computer program.
          
          \par
          Lets start by the roots\ldots

          \par
          This document is not finished and is updated from time to time. Especially at the locations marked with {``+++''} additions or changes will be made.

          \par
          I am deeply grateful to my wife \emph{Gesine~Dräger} and our son \emph{Lennart} for their support and patience.

          \par
          \vspace*{1cm} Hamburg, January 2013 \\
          \hspace*{\fill} Michael Meyling
        ]]>
      </LATEX>
      <LATEX language="de">
        <![CDATA[
          Mathematik ist eine Wissenschaft mit einer Struktur, die im Laufe der Zeit riesige Dimensionen erreicht hat. Diese unglaublich hohe Burg besitzt nur ein ganz schmales Fundament und ihre Festigkeit gründet sich auf einfachem prädikatenlogischen Mörtel. Im Prinzip kann der Aufbau von jeder Mathematikerin verstanden werden. Von dem neuesten Gipfel mathematischer Erkenntnis kann jeder Pfad logisch folgerichtig bis in die mengentheoretischen Wurzeln nachvollzogen werden.
          
          \par
          Bei diesem Unternehmen will dieses Dokument Hilfestellung geben. Ziel ist eine Präsentation der mengentheoretischen Wurzeln in verständlicher Weise. Bei aller Verständlichkeit soll es jedoch jederzeit möglich sein, tief in die Details einzusteigen, ja sogar bis auf die Ebene eines formal korrekten Beweises hinab. Dazu soll es dieses Dokument in verschiedenen Detaillierungen geben. Für alle aber gilt, dass die Formeln in Axiomen, Definitionen und Propositionen in formal korrekter Form vorliegen.

          \par
          Wir wollen bei den Wurzeln anfangen\ldots

          \par
          Dieses Dokument ist im Entstehen begriffen und wird von Zeit zu Zeit aktualisiert. Insbesondere werden an den durch {\glqq+++\grqq} gekennzeichneten Stellen noch Ergänzungen oder Änderungen vorgenommen.
          
          \par
          Besonderer Dank geht an meine Frau \emph{Gesine~Dräger} und unseren Sohn \emph{Lennart} für ihre Unterstützung und ihr Verständnis für ihnen fehlende Zeit.

          \par
          \vspace*{1cm} Hamburg, Januar 2013 \\
          \hspace*{\fill} Michael Meyling
        ]]>
      </LATEX>
          
    </INTRODUCTION>
  </CHAPTER>


  <CHAPTER noNumber="true">
    <TITLE>
      <LATEX language="en">
        Introduction\label{ch:introduction}
      </LATEX>
      <LATEX language="de">
        Einleitung\label{ch:introduction}
      </LATEX>
    </TITLE>
    <INTRODUCTION>
      <LATEX language="en">
        <![CDATA[
          Within this document we use the results of \qref{l}.
          After mathematical logic has provided us with the methods of reasoning we start with a very basic theory. Set theory deals with objects and their collections. This theory is interesting for two reasons. First, nearly all mathematical fields use it. Second, every mathematical statement or proof could be cast into formulas within set theory. Number theory, algebra, analysis an all other theories could be constructed within.

          \par          
          This document contains the mathematical foundation of set theory. Goal is the presentation of elementary results which are needed in other mathematical disciplines. After the basics the {\emph boolean algebra of classes} is in focus. Next are some thoughts about \emph{relations} and \emph{functions}. An important achievement is the definition of the \emph{natural~ numbers} and their fulfillment of the \emph{Peano axioms}. Also the concept of \emph{recursion} is discussed. Furthermore the axiom of choice is examined. At the end the continuum is thematised.
          
          \par
          Although the presentation is axiomatic the results shall match the mathematical usage. Therefore the set theoretic axiom system of \emph{A.~P.~Morse} and \emph{J.~L.~Kelley} (MK\index{MK}) was chosen. The presentation is very much along the lines of \emph{E.~J.~Lemmon}s excellent and strongly recommended book~\cite{lemmon}.
        ]]>
      </LATEX>
      <LATEX language="de">
        <![CDATA[
          In diesem Dokument nutzen wir die Ergebnisse aus \qref{l}.
          Nachdem durch die Logik die Art der mathematischen Argumentation vorgegeben wird, wird in der Mengenlehre ganz allgemein über Objekte und ihre Zusammenfassungen gesprochen. Besonders interessant ist die Mengenlehre dadurch, dass sie zum einen von eigentlich allen mathematischen Disziplinen verwendet wird. Zum anderen lässt sich jede mathematische Disziplin innerhalb der Mengenlehre definieren. Zahlentheorie, Algebra, Analysis und alle weiteren Gebiete lassen sich darauf aufbauen.
        
          \par
          Dieses Dokument beschreibt die mathematischen Grundlagen der Mengenlehre. Ziel ist dabei die Bereitstellung von elementaren Ergebnissen der Mengenlehre, die in anderen mathematischen Disziplinen benötigt werden. Nach den Grundlagen wird die Boolsche Algebra der Klassen betrachtet. Es schliessen sich Betrachtungen über Relationen und Funktionen an. Ein weiteres wichtiges Ergebnis sind die Definition der natürlichen Zahlen und die Erfüllung der Peano-Axiome durch diese, auch auf den Begriff der Rekursion wird eingegangen. Anschließend wird das Auswahlaxiom behandelt. Am Schluss geht es um das Kontinuum.
         
          \par
          Die Darstellung erfolgt in axiomatischer Weise, soll aber im Ergebnis der mathematischen Praxis entsprechen. Daher wird auch das Axiomensystem der Mengenlehre von \emph{A.~P.~Morse} und  \emph{J.~L.~Kelley} (MK\index{MK}) verwendet. Der Aufbau lehnt sich stark an das exzellente und sehr empfehlenswerte Buch von \emph{E.~J.~Lemmon}~\cite{lemmon} an.
         
        ]]>
      </LATEX>
    </INTRODUCTION>
  </CHAPTER>

  <CHAPTER>
    <TITLE>
      <LATEX language="en">
        Basics
      </LATEX>
      <LATEX language="de">
        Anfangsgründe
      </LATEX>
    </TITLE>
    <INTRODUCTION>
      <LATEX language="en">
        <![CDATA[
          In this chapter we start with the very basic axioms and definitions of set theory. We shall make no attempt to introduce a formal language\footnote{Despite of this, in the original text of this document the formulas of axioms, definitions and propositions are written in a formal language. The original text is a XML file with a syntax defined by the XSD \url{http://www.qedeq.org/current/xml/qedeq.xsd}. A more detailed description of the formula language is given in \url{http://www.qedeq.org/current/doc/project/qedeq_logic_language_en.pdf}.} but shall be content with the common logical operators. To be more precise: precondition is a first-order predicate calculus with identity.
          
          \par\index{Cantor}\index{set!definition}
          \emph{G.~Cantor}, who is considered the founder of set theory, gave in a publication in 1895 a description of the term \emph{set}.
          
          \begin{quote}
           By a ``set'' we are to understand any collection into a whole $M$ of definite and separate objects $m$ of our intuition or our thought. These objects are called the ``elements'' of $M$.
          \end{quote}
          
          \par
          This collection can be specified by giving a \emph{condition for membership}. Around 1900 various paradoxes in this naive set theory were discovered. These paradoxes base on giving tricky conditions for membership.
          
          \par
          There exist different ways out of those contradictions. In this text we don't restrict the condition for membership but we call the result a \emph{class}. Additional axioms allow us to call certain classes sets again. All sets are classes, but not all classes are sets. Sets are classes which are themselves members of classes, whilst a class which is not a set is a class which is not a member of any class.
          
        ]]>
      </LATEX>
      <LATEX language="de">
        <![CDATA[
          In diesem Kapitel beginnen wir mit den ganz elementaren Axiomen und Definitionen der Mengenlehre. Wir versuchen nicht, eine formale Sprache einzuführen,\footnote{Dessen ungeachtet sind die Formeln der Axiome, Definitionen und Propositionen in dem Ursprungstext dieses Dokuments in einer formalen Sprache notiert. Der Ursprungstext ist eine XML-Datei, deren Syntax mittels der XSD \url{http://www.qedeq.org/current/xml/qedeq.xsd} definiert wird. Eine nähere Beschreibung der Formelsprache ist unter \url{http://www.qedeq.org/current/doc/project/qedeq_logic_language_de.pdf} zu finden.} und setzen das Wissen um den Gebrauch von logischen Symbolen voraus. Noch genauer formuliert: wir arbeiten mit einer Prädikatenlogik erster Stufe mit Identität.

          \par\index{Cantor}\index{Menge!Definition}
          \emph{G.~Cantor}, der als Begründer der Mengenlehre gilt, hat in einer Veröffentlichung im Jahre 1895 eine Beschreibung des Begriffs \emph{Menge} gegeben.
          
          \begin{quote}
           Unter einer {\glqq Menge\grqq} verstehen wir jede Zusammenfassung $M$ von bestimmten wohlunterscheidbaren Objekten $m$ unserer Anschauung oder unseres Denkens (welche die {\glqq Elemente\grqq} von $M$ genannt werden) zu einem Ganzen.
          \end{quote}
          
          \par
          Diese Zusammenfassung kann über die Angabe einer Eigenschaft dieser Elemente erfolgen. Um 1900 wurden verschiedene Widersprüche dieser naiven Mengenlehre entdeckt. Diese Widersprüche lassen sich auf trickreich gewählte Eigenschaften zurückführen.
          
          \par
          Es gibt verschiedene Möglichkeiten diese Widersprüche zu verhindern. In diesem Text schränken wir zwar die Angabe von Eigenschaften in keiner Weise ein, aber wir nennen das Ergebnis der Zusammenfassung zunächst einmal \emph{Klasse}. Zusätzliche Axiome regeln dann, wann eine bestimmte Klasse auch eine Menge ist. Alle Mengen sind Klassen, aber nicht alle Klassen sind Mengen. Eine Menge ist eine Klasse, die selbst Element einer anderen Klasse ist. Eine Klasse, die keine Menge ist, ist nicht Element irgend einer anderen Klasse.
        ]]>
      </LATEX>
    </INTRODUCTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">Classes and Sets</LATEX>
        <LATEX language="de">Klassen und Mengen</LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            Although we want to speak about \emph{sets}\index{set} at the very beginning we have \emph{classes}\index{classes}. No formal definition of a class will be given. Informally, a class is a collection of objects, the involved objects are called the \emph{elements}\index{element} or \emph{members}\index{member} of the class. 
            Sets will be construed as a special kind of class.
            
            \par
            The following definitions and axioms are due to a strengthened version of \emph{von~Neumann-Bernays-Gödel's} set theory (\emph{NBG}\index{NBG}). This version is called \emph{MK}\index{MK} which is short for \emph{Morse-Kelley}. 
          ]]>
        </LATEX>
        <LATEX language="de">
          <![CDATA[
            Obgleich wir im Wesentlichen über \emph{Mengen}\index{Menge} sprechen wollen, haben wir am Anfang nur \emph{Klassen}\index{Klasse}. Dieser Begriff wird nicht formal definiert. Anschaulich gesprochen, ist eine Klasse eine Zusammenfassung von Objekten. Die beteiligten Objekte heißen auch \emph{Elemente}\index{Element} der Klasse.
            Mengen werden dann als eine besondere Art von Klassen charakterisiert.
            
            \par
            Die folgenden Definitionen und Axiome folgen dem Aufbau einer vereinfachten Version der Mengenlehre nach \emph{von~Neumann-Bernays-Gödel} (\emph{NBG}\index{NBG}). Die genaue Bezeichnung lautet \emph{MK}\index{MK} nach \emph{Morse-Kelley}.
          ]]>
        </LATEX>
      </INTRODUCTION>
      <SUBSECTIONS>
        <NODE id="definition:in">
          <NAME>
            <LATEX language="en">is a member of</LATEX>
            <LATEX language="de">ist enthalten in</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Membership Operator</LATEX>
            <LATEX language="de">Elementbeziehung</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                The theory of sets introduced here has initial objects, called \emph{classes}. Furthermore the only predefined symbol is for a binary relation called \emph{membership}.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Die hier vorgestellte Mengenlehre hat als Ausgangsobjekte \emph{Klassen}.
                Weiterhin wird nur ein einziges Symbol für eine binäre Relation vorausgesetzt: der \emph{Enthaltenseinoperator}.
              ]]>
            </LATEX>
          </PRECEDING>
          <DEFINITION_PREDICATE_INITIAL arguments="2" name="in">
            <LATEXPATTERN>#1 \in #2</LATEXPATTERN>
            <PREDCON ref="in">
              <VAR id="x"/>
              <VAR id="y"/>
            </PREDCON>
          </DEFINITION_PREDICATE_INITIAL>
          <SUCCEEDING>
            <LATEX language="en">
              <![CDATA[
                We also say ``$x$ \emph{is element of} $y$'', ``$x$ \emph{belongs to} $y$'', ``$x$ \emph{is a member of} $y$'' or ``$x$ \emph{is in} $y$''.
                Beside identity this is the only predicate we start with. All other will be defined. Also no function constants are initially given. Later on we will successively fix their meaning.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Wir sagen auch \glqq$x$ \emph{ist Element von} $y$\grqq, \glqq$x$ \emph{gehört zu} $y$\grqq, \glqq$x$ \emph{liegt in} $y$\grqq oder auch \glqq$x$ \emph{ist in} $y$\grqq.
                Neben der Identität ist dies das einzige Prädikat welches wir zu Beginn haben. Alle anderen werden definiert. Auch Funktionskonstanten haben wir zu Anfang nicht, ihre Bedeutung wird sukzessive im weiteren Verlauf festgelegt.
              ]]>
            </LATEX>
          </SUCCEEDING>
        </NODE>
        <NODE id="definition:notIn">
          <NAME>
            <LATEX language="en">is not a member of</LATEX>
            <LATEX language="de">ist nicht enthalten in</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Non Membership Operator</LATEX>
            <LATEX language="de">Negation der Elementbeziehung</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                Although we simply can negate the membership predicate we also want to define a shorthand notation for it.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Obgleich wir die Elementbeziehung einfach negieren können, möchten wir dafür eine Abkürzung definieren.
              ]]>
            </LATEX>
          </PRECEDING>
          <DEFINITION_PREDICATE arguments="2" name="notIn">
            <LATEXPATTERN>#1 \notin #2</LATEXPATTERN>
            <FORMULA>
              <EQUI>
                <PREDCON ref="notIn">
                  <VAR id="x"/>
                  <VAR id="y"/>
                </PREDCON>
                <NOT>
                  <PREDCON ref="in">
                    <VAR id="x"/>
                    <VAR id="y"/>
                  </PREDCON>
                </NOT>
              </EQUI>
            </FORMULA>
          </DEFINITION_PREDICATE>
        </NODE>
        <NODE id="axiom:extensionality">
          <NAME>
            <LATEX language="en">axiom of extensionality</LATEX>
            <LATEX language="de">Extensionalitätsaxiom</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Extensionality\index{axiom!of extensionality}</LATEX>
            <LATEX language="de">Extensionalität\index{Extensionalitätsaxiom}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                 Our first axiom states that, for any classes $x$ and $y$, if the membership of $x$ and $y$ are the same, then $x$ and $y$ are the same.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Unser erstes Axiom besagt, dass beliebige Klassen $x$ und $y$ identisch sind, wenn sie dieselben Elemente enthalten.
              ]]>
            </LATEX>
          </PRECEDING>
          <AXIOM>
            <FORMULA>
              <IMPL>
                <FORALL>
                  <VAR id="z"/>
                  <EQUI>
                    <PREDCON ref="in">
                      <VAR id="z"/>
                      <VAR id="x"/>
                    </PREDCON>
                    <PREDCON ref="in">
                      <VAR id="z"/>
                      <VAR id="y"/>
                    </PREDCON>
                  </EQUI>
                </FORALL>
                <PREDCON ref="l.equal">
                  <VAR id="x"/>
                  <VAR id="y"/>
                </PREDCON>
              </IMPL>
            </FORMULA>
          </AXIOM>
          <SUCCEEDING>
            <LATEX language="en">
              <![CDATA[
                The classes $x$ and $y$ may be defined in entirely different ways, for example:
                \par
                \begin{tabularx}{\linewidth}{rcX}
                  $x$ & = & class of all nonnegative integers, \\
                  $y$ & = & class of all integers, that can be written as sum of four squares,
                \end{tabularx}
                \par
                but if they have the same members, they are the same class.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Die Klassen $x$ und $y$ können verschieden definiert sein, beispielsweise:
                \par
                \begin{tabularx}{\linewidth}{rcX}
                  $x$ & = & Klasse aller nichtnegativen ganzen Zahlen, \\
                  $y$ & = & Klasse aller ganzen Zahlen, die als Summe von vier Quadraten geschrieben werden können,
                \end{tabularx}
                \par
                aber wenn sie dieselben Elemente besitzen, sind sie identisch.
              ]]>
            </LATEX>
          </SUCCEEDING>
        </NODE>

        <NODE id="theorem:extensonalityEquivalence" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                Now to our first proposition.
                We can reverse the implication in the axiom of extensionality.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Nun zu unserer ersten Proposition.
                In dem Extensionalitätsaxiom können wir die Implikation umkehren.
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <EQUI>
                <FORALL>
                  <VAR id="z"/>
                  <EQUI>
                    <PREDCON ref="in">
                      <VAR id="z"/>
                      <VAR id="x"/>
                    </PREDCON>
                    <PREDCON ref="in">
                      <VAR id="z"/>
                      <VAR id="y"/>
                    </PREDCON>
                  </EQUI>
                </FORALL>
                <PREDCON ref="l.equal">
                  <VAR id="x"/>
                  <VAR id="y"/>
                </PREDCON>
              </EQUI>
            </FORMULA>
            <PROOF kind="informal" level="1">
              <LATEX language="en">
                 This a simple consequence of the second identity axiom. We assume $x=y$. Then follows $\phi(x) \leftrightarrow \phi(y)$ for any predicate $\phi$. So follows $z \in x \leftrightarrow z \in y$ for any $z$. Therefore we have $\forall \ z \ z  \in x \leftrightarrow \ z \in y$. So we derived $x = y \ \rightarrow \ \forall \ z \ z  \in x \leftrightarrow \ z \in y$. Together with \qref{axiom:extensionality} we get the desired result.
              </LATEX>
              <LATEX language="de">
                 Dies ist eine einfache Anwendung des zweiten identitätslogischen Axioms. Wir setzen $x=y$ voraus. Nun folgt $\phi(x) \leftrightarrow \phi(y)$ für jedes Prädikat $\phi$. So bekommen wir $z \in x \leftrightarrow z \in y$ für beliebiges $z$. Also haben wir $\forall \ z \ z  \in x \leftrightarrow \ z \in y$. Damit zeigten wir $x = y \ \rightarrow \ \forall \ z \ z  \in x \leftrightarrow \ z \in y$. Zusammen mit dem \qref{axiom:extensionality} erhalten wir das gewünschte Ergebnis.
              </LATEX>
            </PROOF>
          </THEOREM>
          <SUCCEEDING>
            <LATEX language="en">
              <![CDATA[
                If identity were not part of our underlying logic, then we should need to take this as a definition of identity. But then another axiom is needed and the theory presentation is not so smooth for technical reasons (derivation of the identity axioms).\footnote{
                  Additional to the identity definition we need the following form of the extensionality axiom: $(x = y \land x \in z) \ \rightarrow y \in z$. This is a special case of the Leibniz's replacement rule that we know already as \qref{l.axiom:leibnizReplacement}. The correctness of the general rule can be proved by recursion over formula building. See also \cite{schmidt} \S 6.
                  
                  \par
                  Alternatively one can define $(x = y \leftrightarrow (\forall z \ (x \in z \ \rightarrow \ y \in z)) \land \forall z \ (z \in x \ \rightarrow \ z \in y))$.}
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Falls wir das Identitätsprädikat nicht als logisches Symbol voraussetzen würden, dann würden wir es hiermit definieren. Aber dann wird auch ein weiteres Axiom benötigt und es ergeben sich technischen Schwierigkeiten bei der Herleitung der Identitätsaxiome.\footnote{
                  Zusätzlich zur Definition der Identität muss das Axiom der Extensionalität in folgender Formulierung treten: $(x = y \land x \in z) \ \rightarrow y \in z$. Das ist ein Spezialfall der Leibnizschen Ersetzbarkeit, die wir bereits als \qref{l.axiom:leibnizReplacement} kennen. Die Gültigkeit im allgemeinen Fall kann durch Rekursion über den Aufbau der Formeln nachgewiesen werden. Siehe auch \cite{schmidt} \S 6.
                  
                  \par
                  Alternativ können wir definieren $(x = y \leftrightarrow (\forall z \ (x \in z \ \rightarrow \ y \in z)) \land \forall z \ (x \in z \ \rightarrow \ z \in y))$.}
              ]]>
            </LATEX>
          </SUCCEEDING>
        </NODE>

        <NODE id="definition:isSet">
          <NAME>
            <LATEX language="en">is set</LATEX>
            <LATEX language="de">ist Menge</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Set\index{set!definition}</LATEX>
            <LATEX language="de">Menge\index{Menge!Definition}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              Now we specify \emph{sets}.
            </LATEX>
            <LATEX language="de">
              Jetzt legen wir fest, was eine \emph{Menge} ist.
            </LATEX>
          </PRECEDING>
          <DEFINITION_PREDICATE arguments="1" name="isSet">
            <LATEXPATTERN>\mathfrak{M}(#1)</LATEXPATTERN>
            <FORMULA>
              <EQUI>
                <PREDCON ref="isSet">
                  <VAR id="x"/>
                </PREDCON>
                <EXISTS>
                  <VAR id="y"/>
                  <PREDCON ref="in">
                    <VAR id="x"/>
                    <VAR id="y"/>
                  </PREDCON>
                </EXISTS>
              </EQUI>
            </FORMULA>
          </DEFINITION_PREDICATE>
          <SUCCEEDING>
            <LATEX language="en">
              <![CDATA[
                So sets are nothing else than special classes. A class is a set iff it is a member of any class.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Mengen sind also nichts anderes als Klassen mit einer besonderen Eigenschaft. Eine Klasse ist genau dann eine Menge, wenn sie Element irgendeiner Klasse ist.
              ]]>
            </LATEX>
          </SUCCEEDING>
        </NODE>

        <NODE id="theorem:inSetEqualInSetAndIsSet" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                A trivial consequence of this definition is the following equivalence.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Eine triviale Folgerung aus dieser Definition ist die folgende Äquivalenz.
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <EQUI>
                <PREDCON ref="in">
                  <VAR id="x"/>
                  <VAR id="y"/>
                </PREDCON>
                <AND>
                  <PREDCON ref="isSet">
                    <VAR id="x"/>
                  </PREDCON>
                  <PREDCON ref="in">
                    <VAR id="x"/>
                    <VAR id="y"/>
                  </PREDCON>
                </AND>
              </EQUI>
            </FORMULA>
            <PROOF kind="informal" level="1">
              <LATEX language="en">
                <![CDATA[
                  `$\Rightarrow$': Assume $x \in y$. It follows $\exists \ u \ x \in u$ and therefore $\mathfrak{M}(x)$ and logically $\mathfrak{M}(x) \land x \in y$.

                  \par
                  `$\Leftarrow$': From $\mathfrak{M}(x) \land x \in y$ we conclude $x \in y$.
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  `$\Rightarrow$': Sei $x \in y$. Es folgt $\exists \ u \ x \in u$ und daher $\mathfrak{M}(x)$ und logisch $\mathfrak{M}(x) \land x \in y$.

                  \par
                  `$\Leftarrow$': Aus $\mathfrak{M}(x) \land x \in y$ schließen wir $x \in y$.
                ]]>
              </LATEX>
            </PROOF>
          </THEOREM>
        </NODE>

        <NODE id="theorem:extensionalitySetRestricted" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                Now we can rewrite the axiom of extensionality as follows.\footnote{The quantification over $z$ is restricted to sets.}
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Nun können wir das Extensionalitätsaxiom wie folgt schreiben.\footnote{Es wird ein eingeschränkter Allquantor benutzt, $z$ läuft nur über Mengen.}
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <EQUI>
                <PREDCON ref="l.equal">
                  <VAR id="x"/>
                  <VAR id="y"/>
                </PREDCON>
                <FORALL>
                  <VAR id="z"/>
                  <PREDCON ref="isSet">
                    <VAR id="z"/>
                  </PREDCON>
                  <EQUI>
                    <PREDCON ref="in">
                      <VAR id="z"/>
                      <VAR id="x"/>
                    </PREDCON>
                    <PREDCON ref="in">
                      <VAR id="z"/>
                      <VAR id="y"/>
                    </PREDCON>
                  </EQUI>
                </FORALL>
              </EQUI>
            </FORMULA>
            <PROOF kind="informal" level="1">
              <LATEX language="en">
                <![CDATA[
                  `$\Rightarrow$': Simulary to proof of \qref{theorem:extensonalityEquivalence} we get the first implication by the second identity axiom.
                  
                  \par
                  `$\Leftarrow$': 
                  Assume $\forall \ \mathfrak{M}(z) \ ( z \in x \ \leftrightarrow \ z \in y)$. Let $u$ be an arbitrary class. If $u \in x$ then $u$ is a set by \qref{definition:isSet}, and hence by the assumption, $u \in y$. similarly $u \in y \ \rightarrow \ u \in x$. Since $u$ is arbitrary, it follows that $\forall u \ (u \in x \ \leftrightarrow \ u \in y)$. Thus by the \qref{axiom:extensionality}, $x = y$.
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  `$\Rightarrow$': Genauso wie im Beweis zu \qref{theorem:extensonalityEquivalence} erhalten wir die erste Implikation mit dem zweiten identitätslogischen Axiom.
                  
                  \par
                  `$\Leftarrow$': 
                  Angenommen es gelte $\forall \ \mathfrak{M}(z) \ ( z \in x \ \leftrightarrow \ z \in y)$. Sei $u$ eine beliebige Klasse. Falls $u \in x$ dann gilt $u$ ist eine Menge nach \qref{definition:isSet}, und daraus folgt mit der Annahme $u \in y$. Analog folgt $u \in y \ \rightarrow \ u \in x$. Da $u$ beliebig, haben wir $\forall u \ (u \in x \ \leftrightarrow \ u \in y)$. Und mit dem \qref{axiom:extensionality} erhalten wir daraus $x = y$. 
                ]]>
              </LATEX>
            </PROOF>
            <PROOF kind="informal" level="2">
              <LATEX language="en">
                <![CDATA[
                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{rclX}
                    $x = y$ & $\leftrightarrow$ & $\forall \ z \ ( z \in x \ \leftrightarrow \ z \in y)$
                      & this is \qref{theorem:extensonalityEquivalence} \\
                            & $\leftrightarrow$ & $\forall \ z \ ( \mathfrak{M}(z) \land z \in x \ \leftrightarrow \ \mathfrak{M}(z) \land z \in y)$ 
                      & \qref{theorem:inSetEqualInSetAndIsSet} \\
                            & $\leftrightarrow$ & $\forall \ z \ ( \mathfrak{M}(z) \rightarrow (z \in x \ \leftrightarrow \ z \in y))$ 
                      & \qref{l.theorem:propositionalCalculus/bh} \\
                            & $\leftrightarrow$ & $\forall \ \mathfrak{M}(z) \ z \in x \ \leftrightarrow \ z \in y)$ 
                      & \qref{l.axiom:restrictedUniversalQuantifier} \\
                  \end{tabularx}
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{rclX}
                    $x = y$ & $\leftrightarrow$ & $\forall \ z \ ( z \in x \ \leftrightarrow \ z \in y)$
                      & dies ist \qref{theorem:extensonalityEquivalence} \\
                            & $\leftrightarrow$ & $\forall \ z \ ( \mathfrak{M}(z) \land z \in x \ \leftrightarrow \ \mathfrak{M}(z) \land z \in y)$ 
                      & \qref{theorem:inSetEqualInSetAndIsSet} \\
                            & $\leftrightarrow$ & $\forall \ z \ ( \mathfrak{M}(z) \rightarrow (z \in x \ \leftrightarrow \ z \in y))$ 
                      & \qref{l.theorem:propositionalCalculus/bh} \\
                            & $\leftrightarrow$ & $\forall \ \mathfrak{M}(z) \ z \in x \ \leftrightarrow \ z \in y)$ 
                      & \qref{l.axiom:restrictedUniversalQuantifier} \\
                  \end{tabularx}
                ]]>
              </LATEX>
            </PROOF>
          </THEOREM>
        </NODE>

        <NODE id="axiom:comprehension">
          <NAME>
            <LATEX language="en">axiom of comprehension</LATEX>
            <LATEX language="de">Komprehensionsaxiom</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Comprehension</LATEX>
            <LATEX language="de">Komprehension</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                Our next set theoretic axiom makes it simple to create new classes. A class could be characterized by a predicate calculus formula.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Unser nächstes Axiom der Mengenlehre ermöglicht uns in simpler Art und Weise neue Klassen zu bilden. Eine Klasse wird ganz einfach durch die Angabe einer prädikatenlogischen Formel charakterisiert. 
              ]]>
            </LATEX>
          </PRECEDING>
          <AXIOM>
            <FORMULA>
              <EXISTS>
                <VAR id="x"/>
                <FORALL>
                  <VAR id="y"/>
                  <EQUI>
                    <PREDCON ref="in">
                      <VAR id="y"/>
                      <VAR id="x"/>
                    </PREDCON>
                    <AND>
                      <PREDCON ref="isSet">
                        <VAR id="y"/>
                      </PREDCON>
                      <PREDVAR id="\phi">
                        <VAR id="y"/>
                      </PREDVAR>
                    </AND>
                  </EQUI>
                </FORALL>
              </EXISTS>
            </FORMULA>
          </AXIOM>
          <SUCCEEDING>
            <LATEX language="en">
              <![CDATA[
                \index{NBG}By a small modification of the above axiom we could get a \emph{NBG} axiom system of set theory due to \emph{John von Neumann}, \emph{Isaak Bernays} and \emph{Kurt Gödel}.\index{predicative}\index{Formula, predicative}
                For that purpose we call a formula \emph{predicative}, if all of its bound subject variables are restricted to sets.
                Therefore predicative formulas formalize `set properties'.\footnote{A little bit more formal: within a predicative formula all quantifier variables run over sets: $\forall \ \mathfrak{M}(x) \ \exists \ \mathfrak{M}(y) \ldots$}
                If we postulate $\phi$ to be predicative we achieve a NBG~system\footnote{Some other axioms --- similar to the following --- are needed as well.}
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                \index{NBG}Durch eine kleine Änderung dieses Axioms würden wir im Folgenden ein \emph{NBG}-Axiomensystem der Mengenlehre erhalten, welches auf \emph{John von Neumann}, \emph{Isaak Bernays} und \emph{Kurt Gödel} zurückgeht.\index{prädikativ}\index{Formel, prädikative}
                Dazu definieren wir: eine Formel, in der alle gebundenen Subjektvariablen auf Mengen restringiert sind, wird \emph{prädikative Formel} genannt. Prädikative Formeln formalisieren also diejenigen Eigenschaften, die man als {\glqq Eigenschaften von Mengen\grqq} bezeichnen kann.\footnote{Noch etwas formaler: in einer prädikativen Formel laufen alle Quantorenvariablen nur über Mengen: $\forall \ \mathfrak{M}(x) \ \exists \ \mathfrak{M}(y) \ldots$}
                Fordern wir nun also zusätzlich, dass $\phi$ prädikativ sein muss, dann erhalten wir ein NBG-System\footnote{Dazu werden noch einige andere Axiome --- analog zu den folgenden --- benötigt}.
              ]]>
            </LATEX>
          </SUCCEEDING>
        </NODE>

        <NODE id="theorem:comprehension" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                By the comprehension axiom and the axiom of extensionality a relationship between a formula $\phi(y)$ and the class defined by this formula is described. The comprehension axiom proposes the existence of at least one class, where the proposition $\mathfrak{M}(y) \land \phi(y)$ holds for all of its elements. The axiom of extensionality and the identity axioms make sure, that there is maximal one class of this kind: two classes with the same elements are equal in the sense of replacement in all appropriate propositions. In other words: there is one and only one such class.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Durch das Komprehensionsaxiom und die Extensionalität wird nun der Zusammenhang zwischen einer Aussage $\phi(y)$ und der durch sie definierten Klasse festgelegt. Dabei behauptet das Komprehensionsaxiom die Existenz mindestens einer Klasse, deren Elemente die Aussage $\mathfrak{M}(y) \land \phi(y)$ erfüllen. Das Extensionalitätsaxiom und die Identitätsaxiome sichern ab, dass es höchstens eine solche Klasse gibt: irgend zwei Klassen, welche dieselben Elemente besitzen, sind gleich im Sinne der Ersetzbarkeit in allen einschlägigen Aussagen. Mit anderen Worten: es gibt nur genau eine solche Klasse.
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <EXISTSU>
                <VAR id="x"/>
                <FORALL>
                  <VAR id="y"/>
                  <EQUI>
                    <PREDCON ref="in">
                      <VAR id="y"/>
                      <VAR id="x"/>
                    </PREDCON>
                    <AND>
                      <PREDCON ref="isSet">
                        <VAR id="y"/>
                      </PREDCON>
                      <PREDVAR id="\phi">
                        <VAR id="y"/>
                      </PREDVAR>
                    </AND>
                  </EQUI>
                </FORALL>
              </EXISTSU>
            </FORMULA>
            <PROOF kind="informal" level="1">
              <LATEX language="en">
                <![CDATA[
                  We must show:
                  $$
                  \begin{array}{rl}
                  \exists x                      & \forall y \ (y \in x \leftrightarrow  \ \mathfrak{M}(y) \land \phi(y)) \\
                  \land \ \forall u \ \forall v  & (\forall y \ (y \in u \leftrightarrow \mathfrak{M}(y) \land \phi(y)) \ \land  \ \forall y \ ( y \in v \leftrightarrow \ \mathfrak{M}(y) \land \phi(y))) \\
                         & \qquad \rightarrow u = v)
                  \end{array}
                  $$
                  Let $u$ and $v$ be arbitrary. Furthermore let us assume:

                  \par
                  $\forall y \ (y \in u \leftrightarrow \ \mathfrak{M}(y) \land \phi(y)) \land \ \forall y \ ( y \in v \leftrightarrow \mathfrak{M}(y)
                  \land \phi(y)))$

                  \par
                  Now with \qref{l.theorem:predicateCalculus/h}: $\forall y \ ((y \in u \leftrightarrow \mathfrak{M}(y) \land \phi(y)) \land (y \in v \leftrightarrow \mathfrak{M}(y) \land \phi(y)))$

                  \par
                  With \qref{l.theorem:propositionalCalculus/bg} we derive: $\forall y \ ((y \in u \leftrightarrow y \in v ))$. And with \qref{theorem:extensonalityEquivalence} follows $u = v$. So we have shown:

                  \par
                  $\forall u \ \forall v \ (\forall y \ (y \in u \leftrightarrow \mathfrak{M}(y) \land \phi(y)) \land \ \forall y \ (y \in v \leftrightarrow \mathfrak{M}(y) \land \phi(y))) \rightarrow u = v)$

                  \par
                  Together with \qref{axiom:comprehension} we get the proposition.
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  Zu zeigen ist:
                  $$
                  \begin{array}{rl}
                  \exists x                      & \forall y \ (y \in x \leftrightarrow  \ \mathfrak{M}(y) \land \phi(y)) \\
                  \land \ \forall u \ \forall v  & (\forall y \ (y \in u \leftrightarrow \mathfrak{M}(y) \land \phi(y)) \ \land  \ \forall y \ ( y \in v \leftrightarrow \ \mathfrak{M}(y) \land \phi(y))) \\
                         & \qquad \rightarrow u = v)
                  \end{array}
                  $$
                  Seien $u$ und $v$ beliebig. Es gelte weiterhin:

                  \par
                  $\forall y \ (y \in u \leftrightarrow \ \mathfrak{M}(y) \land \phi(y)) \land \ \forall y \ ( y \in v \leftrightarrow \mathfrak{M}(y)
                  \land \phi(y)))$

                  \par
                  Dann folgt mit \qref{l.theorem:predicateCalculus/h}: $\forall y \ ((y \in u \leftrightarrow \mathfrak{M}(y) \land \phi(y)) \land (y \in v \leftrightarrow \mathfrak{M}(y) \land \phi(y)))$

                  \par
                  Daraus erhalten wir mit \qref{l.theorem:propositionalCalculus/bg}: $\forall y \ ((y \in u \leftrightarrow y \in v ))$. Und mit \qref{theorem:extensonalityEquivalence} folgt nun $u = v$. Also haben wir gezeigt:

                  \par
                  $\forall u \ \forall v \ (\forall y \ (y \in u \leftrightarrow \mathfrak{M}(y) \land \phi(y)) \land \ \forall y \ (y \in v \leftrightarrow \mathfrak{M}(y) \land \phi(y))) \rightarrow u = v)$

                  \par
                  Zusammen mit dem \qref{axiom:comprehension} folgt nun die Behauptung.
                ]]>
              </LATEX>
            </PROOF>
          </THEOREM>
        </NODE>

        <NODE id="rule:classDefinition">
          <NAME>
            <LATEX language="en">class definition</LATEX>
            <LATEX language="de">Klassenschreibweise</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Class definition</LATEX>
            <LATEX language="de">Klassenschreibweise</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                Starting with \qref{theorem:comprehension} we can extend the syntax and provide a new abbreviation.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Ausgehend von \qref{theorem:comprehension} können wir die Sprachsyntax erweitern und eine neue abkürzende Schreibweise einführen.
              ]]>
            </LATEX>
          </PRECEDING>
          <RULE name="CLASS_DEFINITION_BY_FORMULA" version="1.00.00">
            <LINK id="theorem:comprehension"/>
            <DESCRIPTION>
              <LATEX language="en">
                <![CDATA[
                  For every formula $\alpha(x_1)$ we define the term expression $\{ x_1 \ | \ \alpha(x_1)\}$ where $x_1$ is a subject variable that is not bound within $\alpha(x_1)$. The free variables of $\{ x_1 \ | \ \alpha(x_1)\}$ are the are the free variables of $\alpha(x_1)$. The bound variables correspond to the bound variables of $\alpha(x_1)$ enhanced by $x_1$. 
                  \par
                  All deduction rules are accordingly extended.
                  
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  Für jede Formel $\alpha(x_1)$ definieren wir den Termausdruck $\{ x_1 \ | \ \alpha(x_1)\}$, wobei $x_1$ eine Subjektvariable ist, die in $\alpha(x_1)$ nicht gebunden ist. Die freien Variablen von $\{ x_1 \ | \ \alpha(x_1)\}$ sind die freien Variablen von $\alpha(x_1)$. Die gebundenen Variablen entsprechen den gebundenen Variablen von $\alpha(x_1)$ ergänzt um $x_1$.
                  
                  \par
                  Alle Ableitungsregeln werden entsprechend erweitert.
                  
                ]]>
              </LATEX>
            </DESCRIPTION>
          </RULE>
          <SUCCEEDING>
            <LATEX language="en">
              <![CDATA[
                In particular the substitution rules must be adapted because now a term can have bound subject variables.\footnote{Luckily we formulated the substitution rules with this extension already in our mind, so we have nothing to do.}
                In the following this new notation is used.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Insbesondere müssen die Substitutionsregeln überprüft werden, weil ein Term nun auch gebundene Subjektvariablen enthalten kann.\footnote{Glücklicherweise haben wir das jedoch schon bei der Formulierung unserer Substitutionsregeln berücksichtigt, so dass wir nichts tun müssen.}
                Im Folgenden wird auf diese neue Schreibweise zurückgegriffen.
              ]]>
            </LATEX>
          </SUCCEEDING>
        </NODE>

        <NODE id="axiom:classDefinition" level="formal">
          <NAME>
            <LATEX language="en">class definition axiom</LATEX>
            <LATEX language="de">Klassenschreibweisenaxiom</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Class Definition Axiom\index{axiom!class definition}</LATEX>
            <LATEX language="de">Axiom der Klassenschreibweise\index{Axiom!der Klassenschreibweise}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                We want to give the new syntax a meaning and by looking at \qref{theorem:comprehension} we introduce the following axiom.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Wir wollen der neu eingeführten Syntax eine Bedeutung geben, und nach einem Blick auf \qref{theorem:comprehension} führen wir das folgende Axiom ein.
              ]]>
            </LATEX>
          </PRECEDING>
          <AXIOM>
            <FORMULA>
              <EQUI>
                <PREDCON ref="in">
                  <VAR id="y"/>
                  <CLASS>
                    <VAR id="x"/>
                    <PREDVAR id="\phi">
                      <VAR id="x"/>
                    </PREDVAR>
                  </CLASS>
                </PREDCON>
                <AND>
                  <PREDCON ref="isSet">
                    <VAR id="y"/>
                  </PREDCON>
                  <PREDVAR id="\phi">
                    <VAR id="y"/>
                  </PREDVAR>
                </AND>
              </EQUI>
            </FORMULA>
          </AXIOM>
          <SUCCEEDING>
            <LATEX language="en">
              <![CDATA[
                This axiom together with \qref{rule:classDefinition} is a \emph{conservative} extension of our formal language. This means that no additional formulas that fulfill the old syntax can be derived. It is just convenient to have an elegant new notation.\footnote{
                A conservative extension is defined by the following.
                Let $\mathfrak{L}$ be a language and $\mathfrak{L'}$ an extension of $\mathfrak{L}$. Because $\mathfrak{L'} \supset \mathfrak{L}$ it follows $\mbox{Formula}_\mathfrak{L'} \supset \mbox{Formula}_\mathfrak{L}$. If now for every set of formulas $\Gamma \subseteq \mbox{Formula}_\mathfrak{L}$ and each formula $\alpha \in \mbox{Formula}_\mathfrak{L}$ this proposition holds: $\Gamma \vdash_\mathfrak{L'} \alpha \ \Rightarrow \ \Gamma \vdash_\mathfrak{L} \alpha$, then $\mathfrak{L'}$ is called a \emph{conservative} extension of $\mathfrak{L}$.} 
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                 Dies Axiom zusammen mit \qref{rule:classDefinition} führt nur zu einer \emph{konservativen} Erweiterung unserer formalen Sprache. Das bedeutet, dass mit der Erweiterung nicht mehr Formeln, die der alten Syntax genügen, abgeleitet werden können. Es ist nur bequem, eine neue elegante Schreibweise zu besitzen.\footnote{
                 Unter einer konservativen Erweiterung  verstehen wir das Folgende:
                 Sei $\mathfrak{L}$ eine Sprache und $\mathfrak{L'}$ eine Erweiterung von $\mathfrak{L}$. Da $\mathfrak{L'} \supset \mathfrak{L}$ gilt auch $\mbox{Formel}_\mathfrak{L'} \supset \mbox{Formel}_\mathfrak{L}$. Falls nun für jede Formelmenge $\Gamma \subseteq \mbox{Formel}_\mathfrak{L}$ und jede Formel $\alpha \in \mbox{Formel}_\mathfrak{L}$ gilt: $\Gamma \vdash_\mathfrak{L'} \alpha \ \Rightarrow \ \Gamma \vdash_\mathfrak{L} \alpha$, dann heißt $\mathfrak{L'}$ eine \emph{konservative} Erweiterung von $\mathfrak{L}$.}.
              ]]>
            </LATEX>
          </SUCCEEDING>
        </NODE>

        <NODE id="theorem:setNotation" level="1">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                This new notation can be easily transformed in the old syntax. Using the new term type with the initial predicates can be expressed as follows.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Die neue Schreibweise kann auch in einfacher Weise in die alte Syntax transformiert werden.
                Die Gültigkeit der Ausgangsprädikate drückt sich für diese neue Termart wie folgt aus.
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <AND>
                <EQUI>
                  <PREDCON ref="in">
                    <VAR id="z"/>
                    <CLASS>
                      <VAR id="x"/>
                      <PREDVAR id="\phi">
                        <VAR id="x"/>
                      </PREDVAR>
                    </CLASS>
                  </PREDCON>
                  <AND>
                    <PREDCON ref="isSet">
                      <VAR id="z"/>
                    </PREDCON>
                    <PREDVAR id="\phi">
                      <VAR id="z"/>
                    </PREDVAR>
                  </AND>
                </EQUI>
                <EQUI>
                  <PREDCON ref="l.equal">
                    <VAR id="z"/>
                    <CLASS>
                      <VAR id="x"/>
                      <PREDVAR id="\phi">
                        <VAR id="x"/>
                      </PREDVAR>
                    </CLASS>
                  </PREDCON>
                  <FORALL>
                    <VAR id="u"/>
                    <EQUI>
                      <PREDCON ref="in">
                        <VAR id="u"/>
                        <VAR id="z"/>
                      </PREDCON>
                      <PREDCON ref="in">
                        <VAR id="u"/>
                        <CLASS>
                          <VAR id="x"/>
                          <PREDVAR id="\phi">
                            <VAR id="x"/>
                          </PREDVAR>
                        </CLASS>
                      </PREDCON>
                    </EQUI>
                  </FORALL>
                </EQUI>
                <EQUI>
                  <PREDCON ref="l.equal">
                    <CLASS>
                      <VAR id="x"/>
                      <PREDVAR id="\phi">
                        <VAR id="x"/>
                      </PREDVAR>
                    </CLASS>
                    <CLASS>
                      <VAR id="y"/>
                      <PREDVAR id="\psi">
                        <VAR id="y"/>
                      </PREDVAR>
                    </CLASS>
                  </PREDCON>
                  <FORALL>
                    <VAR id="u"/>
                    <EQUI>
                      <PREDCON ref="in">
                        <VAR id="u"/>
                        <CLASS>
                          <VAR id="x"/>
                          <PREDVAR id="\phi">
                            <VAR id="x"/>
                          </PREDVAR>
                        </CLASS>
                      </PREDCON>
                      <PREDCON ref="in">
                        <VAR id="u"/>
                        <CLASS>
                          <VAR id="y"/>
                          <PREDVAR id="\psi">
                            <VAR id="y"/>
                          </PREDVAR>
                        </CLASS>
                      </PREDCON>
                    </EQUI>
                  </FORALL>
                </EQUI>
                <EQUI>
                  <PREDCON ref="in">
                    <CLASS>
                      <VAR id="x"/>
                      <PREDVAR id="\phi">
                        <VAR id="x"/>
                      </PREDVAR>
                    </CLASS>
                    <CLASS>
                      <VAR id="y"/>
                      <PREDVAR id="\psi">
                        <VAR id="y"/>
                      </PREDVAR>
                    </CLASS>
                  </PREDCON>
                  <FORALL>
                    <VAR id="u"/>
                    <FORALL>
                      <VAR id="v"/>
                      <IMPL>
                        <AND>
                          <PREDCON ref="l.equal">
                            <VAR id="u"/>
                            <CLASS>
                              <VAR id="x"/>
                              <PREDVAR id="\phi">
                                <VAR id="x"/>
                              </PREDVAR>
                            </CLASS>
                          </PREDCON>
                          <PREDCON ref="l.equal">
                            <VAR id="v"/>
                            <CLASS>
                              <VAR id="y"/>
                              <PREDVAR id="\psi">
                                <VAR id="y"/>
                              </PREDVAR>
                            </CLASS>
                          </PREDCON>
                        </AND>
                        <PREDCON ref="in">
                          <VAR id="u"/>
                          <VAR id="v"/>
                        </PREDCON>
                      </IMPL>
                    </FORALL>
                  </FORALL>
                </EQUI>
                <EQUI>
                  <PREDCON ref="in">
                    <CLASS>
                      <VAR id="x"/>
                      <PREDVAR id="\phi">
                        <VAR id="x"/>
                      </PREDVAR>
                    </CLASS>
                    <VAR id="z"/>
                  </PREDCON>
                  <FORALL>
                    <VAR id="u"/>
                    <IMPL>
                      <PREDCON ref="l.equal">
                        <VAR id="u"/>
                        <CLASS>
                          <VAR id="x"/>
                          <PREDVAR id="\phi">
                            <VAR id="x"/>
                          </PREDVAR>
                        </CLASS>
                      </PREDCON>
                      <PREDCON ref="in">
                        <VAR id="u"/>
                        <VAR id="z"/>
                      </PREDCON>
                    </IMPL>
                  </FORALL>
                </EQUI>
              </AND>
            </FORMULA>
            <DESCRIPTION>
              <LATEX language="en">
                <![CDATA[
                  +++ if the formula would be rendered correctly it should look like this: \\
                  \begin{align}
                  z \in \{ x~|~\phi(x) \} & \leftrightarrow  \mathfrak{M}(z) \land \phi(z) \tag{a} \\
                  y = \{ x~|~ \phi(x) \} & \leftrightarrow  \forall z \ (z \in y \leftrightarrow z \in \{ x~|~\phi(x) \}) \tag{b} \\
                  \{ x~|~\phi(x) \} = \{ y~|~\psi(y) \} & \leftrightarrow \forall u \ (u \in \{ x~|~\phi(x) \} \tag{c} \\
                  \begin{split}
                    & \qquad \leftrightarrow u \in \{y~|~\psi(y) \}) \nonumber \\
                  \{ x~|~\phi(x) \} \in \{ y~|~\psi(y) \} & \leftrightarrow  \forall u \ \forall
                  v \ ((u  = \{ x~|~\phi(x) \} \\
                    & \qquad \land \ v = \{ y~|~\psi(y) \}) \rightarrow u \in v) 
                  \end{split} \tag{d} \\
                  \{ x~|~\phi(x) \} \in z & \leftrightarrow  \forall u \ (u  = \{ x~|~\phi(x) \}  \rightarrow u \in z) \tag{e} 
                  \end{align}
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  +++ wenn diese Formel richtig gesetzt würde, sollte sie so aussehen:
                  \begin{align}
                  y \in \{ x~|~\phi(x) \} & \leftrightarrow  \mathfrak{M}(y) \land \phi(y) \tag{a} \\
                  y = \{ x~|~ \phi(x) \} & \leftrightarrow  \forall z \ (z \in y \leftrightarrow z \in \{ x~|~\phi(x) \}) \tag{b} \\
                  \{ x~|~\phi(x) \} = \{ x~|~\psi(x) \} & \leftrightarrow \forall z \ (z \in \{ x~|~\phi(x) \} \tag{c} \\
                  \begin{split}
                    & \qquad \leftrightarrow z \in \{x~|~\psi(x) \}) \nonumber \\
                  \{ x~|~\phi(x) \} \in \{ x~|~\psi(x) \} & \leftrightarrow  \forall u \ \forall
                  v \ ((u  = \{ x~|~\phi(x) \} \\
                    & \qquad \land \ v = \{ x~|~\psi(x) \}) \rightarrow u \in v) 
                  \end{split} \tag{d} \\
                  \{ x~|~\phi(x) \} \in y & \leftrightarrow  \forall u \ (u  = \{ x~|~\phi(x) \}  \rightarrow u \in y) \tag{e} 
                  \end{align}
                ]]>
              </LATEX>
            </DESCRIPTION>
            <PROOF kind="informal" level="1">
              <LATEX language="en">
                <![CDATA[
                  The formula a) is simply \qref{axiom:classDefinition}. We get b) and c) with \qref{theorem:extensonalityEquivalence}. And d) and e) come from identity theorms. 
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  Die Formel in a) ist einfach \qref{axiom:classDefinition}. Mit \qref{theorem:extensonalityEquivalence} erhalten wir b) und c). Mit den Identitätsgesetzen bekommen wir d) und e). 
                ]]>
              </LATEX>
            </PROOF>
          </THEOREM>
          <SUCCEEDING>
            <LATEX language="en">
              <![CDATA[
                Therefore the new syntax can be eliminated by successively applying the above theorems.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Durch sukzessives Anwenden des obigen Satzes kann also die neue Syntax in die alte überführt werden.
              ]]>
            </LATEX>
          </SUCCEEDING>
        </NODE>
        
        <NODE id="theorem:setDefinitionUnique" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                Because the new notation fixes a term completely the following must be true.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Da durch die neue Schreibweise ein Term eindeutig festgelegt wird, muss natürlich auch das Folgende gelten.
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <EXISTSU>
                <VAR id="x" />
                <PREDCON ref="l.equal">
                  <VAR id="x" />
                  <CLASS>
                    <VAR id="y" />
                    <PREDVAR id="\phi">
                      <VAR id="y"/>
                    </PREDVAR>
                  </CLASS>
                </PREDCON>
              </EXISTSU>
            </FORMULA>
            <PROOF kind="informal" level="1">
              <LATEX language="en">
                <![CDATA[
                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{lX}
                    $\exists! \ x \ \forall \ z \ ( z \in x \ \leftrightarrow \ \mathfrak{M}(z) \land \phi(z))$
                      & this is \qref{theorem:comprehension} \\
                    $\exists! \ x \ \forall \ z \ ( z \in x \ \leftrightarrow z \in \{ y \ | \  \phi(y) \}$
                      & \qref{theorem:setNotation/a} \\
                    $\exists! \ x \ x = \{ y \ | \  \phi(y) \}$
                      & \qref{theorem:extensonalityEquivalence}
                  \end{tabularx}
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{lX}
                    $\exists! \ x \ \forall \ z \ ( z \in x \ \leftrightarrow \ \mathfrak{M}(z) \land \phi(z))$
                      & dies ist \qref{theorem:comprehension} \\
                    $\exists! \ x \ \forall \ z \ ( z \in x \ \leftrightarrow z \in \{ y \ | \  \phi(y) \}$
                      & \qref{theorem:setNotation/a} \\
                    $\exists! \ x \ x = \{ y \ | \  \phi(y) \}$
                      & \qref{theorem:extensonalityEquivalence}
                  \end{tabularx}
                ]]>
              </LATEX>
            </PROOF>
          </THEOREM>
        </NODE>
        
        <NODE id="theorem:propositionEqualImplClassEqual" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                
                The equivalence of properties enables us to conclude the identity of the associated classes.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                
                Aus der Äquivalenz von Aussageformen kann auf die Gleichheit der daraus gebildeten Klassen geschlossen werden.
                
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <IMPL>
                <FORALL>
                  <VAR id="x" />
                  <EQUI>
                    <PREDVAR id="\phi">
                      <VAR id="x" />
                    </PREDVAR>
                    <PREDVAR id="\psi">
                      <VAR id="x" />
                    </PREDVAR>
                  </EQUI>
                </FORALL>
                <PREDCON ref="l.equal">
                  <CLASS>
                    <VAR id="x" />
                    <PREDVAR id="\phi">
                      <VAR id="x" />
                    </PREDVAR>
                  </CLASS>
                  <CLASS>
                    <VAR id="x" />
                    <PREDVAR id="\psi">
                      <VAR id="x" />
                    </PREDVAR>
                  </CLASS>
                </PREDCON>
              </IMPL>
            </FORMULA>
            <PROOF kind="informal" level="2">
              <LATEX language="en">
                <![CDATA[
                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{rlX}
%%                  \begin{longtable}[h!]{r@{\extracolsep{\fill}}p{9cm}@{\extracolsep{\fill}}p{4cm}}
                    $(\phi(x) \leftrightarrow \psi(x))$ $\rightarrow$  & $(\phi(x) \land \mathfrak{M}(x) \leftrightarrow \psi(x) \land \mathfrak{M}(x))$ & {\tiny \qref{l.theorem:propositionalCalculus/bl}} \\
                    $\forall x \ ((\phi(x) \leftrightarrow \psi(x))$ $\rightarrow$  & $(\phi(x) \land \mathfrak{M}(x) \leftrightarrow \psi(x) \land \mathfrak{M}(x)))$ & {\tiny \qref{l.rule:derivedQuantification}} \\                    
                    $\forall x \ (\phi(x) \leftrightarrow \psi(x))$ $\rightarrow$  & $\forall x \ (\phi(x) \land \mathfrak{M}(x) \leftrightarrow \psi(x) \land \mathfrak{M}(x))$ & {\tiny \qref{l.theorem:predicateCalculus/a}} \\
                    $\rightarrow$ & $\forall x ( x \in \{ y | \phi(y) \} \leftrightarrow x \in \{ y | \psi(y) \})$ 
                      & {\tiny \qref{theorem:setNotation/a}} \\
                    $\rightarrow$ & $ \{ y \ | \ \phi(y) \} = \{ y \ | \ \psi(y) \}$ 
                      & {\tiny \qref{theorem:setNotation/c}}
                  \end{tabularx}
%%                  \end{longtable}
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{rlX}
%%                  \begin{longtable}[h!]{r@{\extracolsep{\fill}}p{9cm}@{\extracolsep{\fill}}p{4cm}}
                    $(\phi(x) \leftrightarrow \psi(x))$ $\rightarrow$  & $(\phi(x) \land \mathfrak{M}(x) \leftrightarrow \psi(x) \land \mathfrak{M}(x))$ & {\tiny \qref{l.theorem:propositionalCalculus/bl}} \\
                    $\forall x \ ((\phi(x) \leftrightarrow \psi(x))$ $\rightarrow$  & $(\phi(x) \land \mathfrak{M}(x) \leftrightarrow \psi(x) \land \mathfrak{M}(x)))$ & {\tiny \qref{l.rule:derivedQuantification}} \\                    
                    $\forall x \ (\phi(x) \leftrightarrow \psi(x))$ $\rightarrow$  & $\forall x \ (\phi(x) \land \mathfrak{M}(x) \leftrightarrow \psi(x) \land \mathfrak{M}(x))$ & {\tiny \qref{l.theorem:predicateCalculus/a}} \\
                    $\rightarrow$ & $\forall x ( x \in \{ y | \phi(y) \} \leftrightarrow x \in \{ y | \psi(y) \})$ 
                      & {\tiny \qref{theorem:setNotation/a}} \\
                    $\rightarrow$ & $ \{ y \ | \ \phi(y) \} = \{ y \ | \ \psi(y) \}$ 
                      & {\tiny \qref{theorem:setNotation/c}}
                  \end{tabularx}
%%                  \end{longtable}
                ]]>
              </LATEX>
            </PROOF>
          </THEOREM>
          <SUCCEEDING>
            <LATEX language="en">
              <![CDATA[
                We remark that the reverse implication is false. This is due to the fact that the class notation embraces only sets. For example: if $\phi(x) \leftrightarrow x \neq x$ and $\psi(x) \leftrightarrow \forall y \ (y \in x \rightarrow y \notin y)$ then the associated classes are identical to the empty class (\qref{definition:emptySet}). No class fulfills $\phi(x)$ but Russells class (\qref{definition:RussellClass}) satifies $\psi(x)$.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Die Umkehrung gilt jedoch nicht. Das liegt daran, dass mit der Klassenschreibweise nur Mengen zusammengefasst werden. Beispiel: wenn $\phi(x) \leftrightarrow x \neq x$ und $\psi(x) \leftrightarrow \forall y \ (y \in x \rightarrow y \notin y)$, dann sind die durch beide Aussageformen erzeugten Klassen identisch mit der leeren Klasse (\qref{definition:emptySet}). Keine Klasse erfüllt $\phi(x)$, allerdings erfüllt die Russellsche Klasse (\qref{definition:RussellClass}) die Bedingung $\psi(x)$.
              ]]>
            </LATEX>
          </SUCCEEDING>
        </NODE>

        <NODE id="theorem:classDescriptionPossible" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                Every class can be described by a property: being a member of the class.

              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Jede Klasse lässt sich durch eine Aussage beschreiben, indem auf ihre Elemente Bezug genommen wird.

              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <PREDCON ref="l.equal">
                 <VAR id="x" />
                 <CLASS>
                   <VAR id="y" />
                   <PREDCON ref="in">
                     <VAR id="y" />
                     <VAR id="x" />
                   </PREDCON>
                 </CLASS>
              </PREDCON>
            </FORMULA>
            <PROOF kind="informal" level="2">
              <LATEX language="en">
                <![CDATA[
                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{rclX}
                    $z \in x$ & $\leftrightarrow$ & $z \in x \land \mathfrak{M}(z)$ & \qref{theorem:inSetEqualInSetAndIsSet} \\
                    $z \in x$ & $\leftrightarrow$ & $z \in \{y \ | \ y \}$ & \qref{theorem:setNotation/a} \\
                    $\forall z \ (z \in x$ & $\leftrightarrow$ & $z \in \{y \ | \ y \})$ & \qref{l.rule:derivedQuantification} \\
                    $x$ & $=$ & $\{y \ | \ y \}$ & \qref{theorem:extensonalityEquivalence}
                  \end{tabularx}
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{rclX}
                    $z \in x$ & $\leftrightarrow$ & $z \in x \land \mathfrak{M}(z)$ & \qref{theorem:inSetEqualInSetAndIsSet} \\
                    $z \in x$ & $\leftrightarrow$ & $z \in \{y \ | \ y \}$ & \qref{theorem:setNotation/a} \\
                    $\forall z \ (z \in x$ & $\leftrightarrow$ & $z \in \{y \ | \ y \})$ & \qref{l.rule:derivedQuantification} \\
                    $x$ & $=$ & $\{y \ | \ y \}$ & \qref{theorem:extensonalityEquivalence}
                  \end{tabularx}                ]]>
              </LATEX>
            </PROOF>
          </THEOREM>
        </NODE>
        
      </SUBSECTIONS>
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">
           Special Classes
        </LATEX>
        <LATEX language="de">
           Spezielle Klassen
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[

            In this section we define our first classes.
            
          ]]>
        </LATEX>
        <LATEX language="de">
          <![CDATA[

            In diesem Abschnitt definieren wir die ersten Klassen.
            
          ]]>
        </LATEX>
      </INTRODUCTION>
      
      <SUBSECTIONS>
        <NODE id="definition:RussellClass" level="formal">
          <NAME>
            <LATEX language="en">Russell class</LATEX>
            <LATEX language="de">Russellsche Klasse</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Russell Class\index{Russell!class of}\index{class!Russell}</LATEX>
            <LATEX language="de">Russell-Klasse\index{Russell!-sche Klasse}\index{Klasse!Russellsche}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                Russells class can now be simply defined.

              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Die Russellsche Klasse kann nun einfach definiert werden.

              ]]>
            </LATEX>
          </PRECEDING>
          <DEFINITION_FUNCTION arguments="0" name="RussellClass">
            <LATEXPATTERN>\mathfrak{Ru}</LATEXPATTERN>
            <FORMULA>
              <PREDCON ref="l.equal">
                <FUNCON ref="RussellClass" />
                <CLASS>
                  <VAR id="x" />
                  <PREDCON ref="notIn">
                    <VAR id="x" />
                    <VAR id="x" />
                   </PREDCON>
                </CLASS>
              </PREDCON>
            </FORMULA>
          </DEFINITION_FUNCTION>
        </NODE>

        <NODE id="theorem:RussellClassIsClass" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                The Russell class is a \emph{proper}\index{proper}\index{class!proper} class. This means it is no set.

              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Die Russellsche Klasse ist eine \emph{echte}\index{echt}\index{Klasse!echte} Klasse, d.~h. sie ist keine Menge.

              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <NOT>
                <PREDCON ref="isSet">
                  <FUNCON ref="RussellClass" />
                </PREDCON>
              </NOT>
            </FORMULA>
            <PROOF kind="informal" level="1">
              <LATEX language="en">
                <![CDATA[
                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{rclX}
                    $y \in \{ x \ | \ \phi(x) \}$
                     & $\leftrightarrow$ 
                     & $\mathfrak{M}(y) \land \phi(y)$ 
                     & this is \qref{theorem:setNotation/a} \\
                    $y \in \{ x \ | \ x \notin x \}$  
                     & $\leftrightarrow$ 
                     & $\mathfrak{M}(y) \land y \notin y$ 
                     & substitution for $\phi$ \\
                    $y \in \mathfrak{Ru}$         
                     & $\leftrightarrow$ 
                     & $\mathfrak{M}(y) \land y \notin y$ 
                     & \qref{definition:RussellClass} \\
                    $\mathfrak{Ru} \in \mathfrak{Ru}$ 
                     & $\leftrightarrow$ 
                     & $\mathfrak{M}(\mathfrak{Ru}) \land \mathfrak{Ru} \notin \mathfrak{Ru}$ 
                     & substitution for $y$ \\
                    $\mathfrak{M}(\mathfrak{Ru}) \land \mathfrak{Ru} \in \mathfrak{Ru}$ 
                     & $\leftrightarrow$ 
                     & $\mathfrak{M}(\mathfrak{Ru}) \land \mathfrak{Ru} \notin \mathfrak{Ru}$ 
                     & \qref{theorem:inSetEqualInSetAndIsSet} \\
                     
                     & $\neg \mathfrak{M}(\mathfrak{Ru})$ 
                     &  
                     & \qref{l.theorem:propositionalCalculus/bi}
                  \end{tabularx}
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{rclX}
                    $y \in \{ x \ | \ \phi(x) \}$
                     & $\leftrightarrow$ 
                     & $\mathfrak{M}(y) \land \phi(y)$ 
                     & das ist \qref{theorem:setNotation/a} \\
                    $y \in \{ x \ | \ x \notin x \}$  
                     & $\leftrightarrow$ 
                     & $\mathfrak{M}(y) \land y \notin y$ 
                     & Substitution für $\phi$ \\
                    $y \in \mathfrak{Ru}$         
                     & $\leftrightarrow$ 
                     & $\mathfrak{M}(y) \land y \notin y$ 
                     & \qref{definition:RussellClass} \\
                    $\mathfrak{Ru} \in \mathfrak{Ru}$ 
                     & $\leftrightarrow$ 
                     & $\mathfrak{M}(\mathfrak{Ru}) \land \mathfrak{Ru} \notin \mathfrak{Ru}$ 
                     & Substitution für $y$ \\
                    $\mathfrak{M}(\mathfrak{Ru}) \land \mathfrak{Ru} \in \mathfrak{Ru}$ 
                     & $\leftrightarrow$ 
                     & $\mathfrak{M}(\mathfrak{Ru}) \land \mathfrak{Ru} \notin \mathfrak{Ru}$ 
                     & \qref{theorem:inSetEqualInSetAndIsSet} \\
                     
                     & $\neg \mathfrak{M}(\mathfrak{Ru})$ 
                     &  
                     & \qref{l.theorem:propositionalCalculus/bi}
                  \end{tabularx}
                ]]>
              </LATEX>
            </PROOF>
          </THEOREM>
        </NODE>


        <NODE id="definition:universalClass" level="formal">
          <NAME>
            <LATEX language="en">universal class</LATEX>
            <LATEX language="de">Allklasse</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Universal Class\index{class!universal}\index{universal class}</LATEX>
            <LATEX language="de">Allklasse\index{Klasse!All-}\index{Allklasse}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                The \emph{universal class} should contain everything.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Die \emph{Allklasse} soll alles mögliche umfassen.
                
              ]]>
            </LATEX>
          </PRECEDING>
          <DEFINITION_FUNCTION arguments="0" name="universalClass">
            <LATEXPATTERN>\mathfrak{V}</LATEXPATTERN>
            <FORMULA>
              <PREDCON ref="l.equal">
                <FUNCON ref="universalClass" />
                <CLASS>
                  <VAR id="x" />
                  <PREDCON ref="l.equal">
                    <VAR id="x" />
                    <VAR id="x" />
                   </PREDCON>
                </CLASS>
              </PREDCON>
            </FORMULA>
          </DEFINITION_FUNCTION>
        </NODE>

        <NODE id="theorem:isInUniversalClass" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                It is no wonder that the following is true because a class has only sets as elements.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Da in einer Klasse nur Mengen als Elemente vorkommen, verwundert es nicht, dass folgendes gilt.

              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <EQUI>
                <PREDCON ref="in">
                  <VAR id="x" />
                  <FUNCON ref="universalClass" />
                </PREDCON>
                <PREDCON ref="isSet">
                  <VAR id="x" />
                </PREDCON>
              </EQUI>
            </FORMULA>
            <PROOF kind="informal" level="1">
              <LATEX language="en">
                <![CDATA[
                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{rclX}
                    $x \in \{ y \ | \ \phi(y) \} $ & $\leftrightarrow$ & $\mathfrak{M}(x) \land \phi(x)$
                      & this is \qref{theorem:setNotation/a} \\
                    $x \in \{ y \ | \ y = y \} $ & $\leftrightarrow$ & $\mathfrak{M}(x) \land y = y$
                      & substitution for $\phi$ \\
                    $x \in \mathfrak{V} $ & $\leftrightarrow$ & $\mathfrak{M}(x) \land y = y$
                      & \qref{definition:universalClass} \\
                    $x \in \mathfrak{V} $ & $\leftrightarrow$ & $\mathfrak{M}(x)$
                      & \qref{l.theorem:propositionalCalculus/au} and \qref{l.axiom:identityIsReflexive}
                  \end{tabularx}
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{rclX}
                    $x \in \{ y \ | \ \phi(y) \} $ & $\leftrightarrow$ & $\mathfrak{M}(x) \land \phi(x)$
                      & dies ist \qref{theorem:setNotation/a} \\
                    $x \in \{ y \ | \ y = y \} $ & $\leftrightarrow$ & $\mathfrak{M}(x) \land y = y$
                      & Substitution für $\phi$ \\
                    $x \in \mathfrak{V} $ & $\leftrightarrow$ & $\mathfrak{M}(x) \land y = y$
                      & \qref{definition:universalClass} \\
                    $x \in \mathfrak{V} $ & $\leftrightarrow$ & $\mathfrak{M}(x)$
                      & \qref{l.theorem:propositionalCalculus/au} und \qref{l.axiom:identityIsReflexive}
                  \end{tabularx}                ]]>
              </LATEX>
            </PROOF>
          </THEOREM>
          <SUCCEEDING>
            <LATEX language="en">
              <![CDATA[

                Being in the universal class is therefore the same as being a set.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Mitgliedschaft in der Allklasse ist daher gleichbedeutend mit der 
                Eigenschaft, eine Menge zu sein.
                
              ]]>
            </LATEX>
          </SUCCEEDING>
        </NODE>

        <NODE id="theorem:universalClassContainsAllSets" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                The universal class contains all sets.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Die Allklasse umfasst alle Mengen.
                
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <PREDCON ref="l.equal">
                <FUNCON ref="universalClass" />
                <CLASS>
                  <VAR id="x" />
                  <PREDCON ref="isSet">
                    <VAR id="x" />
                  </PREDCON>
                </CLASS>
              </PREDCON>
            </FORMULA>
            <PROOF kind="informal" level="1">
              <LATEX language="en">
                <![CDATA[
                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{rclX}
                    $\mathfrak{V}$ & $=$ & $\{ x \ | \ x = x\}$
                      & \qref{definition:universalClass} \\
                    $\forall y \ (y \in \mathfrak{V}$ & $\leftrightarrow$ & $y \in \{ x \ | \ x = x\}$
                      & \qref{theorem:extensonalityEquivalence} \\
                    $\forall y \ (y \in \mathfrak{V}$ & $\leftrightarrow$ & $\mathfrak{M}(y) \land y = y$
                      & \qref{theorem:setNotation/a} \\
                    $\forall y \ (y \in \mathfrak{V}$ & $\leftrightarrow$ & $\mathfrak{M}(y) \land \top$
                      & \qref{l.rule:replaceTrueFormulaByTrue} \\
                    $\forall y \ (y \in \mathfrak{V}$ & $\leftrightarrow$ & $\mathfrak{M}(y)$
                      & \qref{l.theorem:propositionalCalculus/au} \\
                    $\forall y \ (y \in \mathfrak{V}$ & $\leftrightarrow$ & $ \mathfrak{M}(y) \land \mathfrak{M}(y)$
                      & \qref{l.theorem:propositionalCalculus/al} \\
                    $\forall y \ (y \in \mathfrak{V}$ & $\leftrightarrow$ & $y \in \{ x \ | \ \mathfrak{M}(x)\}$
                      & \qref{theorem:setNotation} \\
                    $\mathfrak{V}$ & $=$ & $\{ x \ | \ \mathfrak{M}(x)\}$
                      & \qref{theorem:extensonalityEquivalence}
                  \end{tabularx}
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{rclX}
                    $\mathfrak{V}$ & $=$ & $\{ x \ | \ x = x\}$
                      & \qref{definition:universalClass} \\
                    $\forall y \ (y \in \mathfrak{V}$ & $\leftrightarrow$ & $y \in \{ x \ | \ x = x\}$
                      & \qref{theorem:extensonalityEquivalence} \\
                    $\forall y \ (y \in \mathfrak{V}$ & $\leftrightarrow$ & $\mathfrak{M}(y) \land y = y$
                      & \qref{theorem:setNotation/a} \\
                    $\forall y \ (y \in \mathfrak{V}$ & $\leftrightarrow$ & $\mathfrak{M}(y) \land \top$
                      & \qref{l.rule:replaceTrueFormulaByTrue} \\
                    $\forall y \ (y \in \mathfrak{V}$ & $\leftrightarrow$ & $\mathfrak{M}(y)$
                      & \qref{l.theorem:propositionalCalculus/au} \\
                    $\forall y \ (y \in \mathfrak{V}$ & $\leftrightarrow$ & $ \mathfrak{M}(y) \land \mathfrak{M}(y)$
                      & \qref{l.theorem:propositionalCalculus/al} \\
                    $\forall y \ (y \in \mathfrak{V}$ & $\leftrightarrow$ & $y \in \{ x \ | \ \mathfrak{M}(x)\}$
                      & \qref{theorem:setNotation} \\
                    $\mathfrak{V}$ & $=$ & $\{ x \ | \ \mathfrak{M}(x)\}$
                      & \qref{theorem:extensonalityEquivalence}
                  \end{tabularx}
                ]]>
              </LATEX>
            </PROOF>
          </THEOREM>
        </NODE>

        <NODE id="definition:emptySet" level="formal">
          <NAME>
            <LATEX language="en">empty class</LATEX>
            <LATEX language="de">Leere Klasse</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Empty Class\index{empty class}\index{empty set}\index{class!empty}\index{set!empty}</LATEX>
            <LATEX language="de">Leere Klasse\index{leere Klasse}\index{leere Menge}\index{Klasse!leere}\index{Menge!leere}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                Analogous we define the \emph{empty class}. Later on we will learn that the empty class
                is a set. To achieve this result we lack some other set axioms. Nevertheless we might already call this class \emph{empty set} sometime.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Entsprechend definieren wir die \emph{leere Klasse}. Später werden wir feststellen, dass die leere Klasse
                eine Menge ist. Dazu benötigen wir jedoch weitere Mengenaxiome. Wir bezeichnen diese Klasse jedoch
                schon jetzt mit den Worten \emph{leere Menge}.
                
              ]]>
            </LATEX>
          </PRECEDING>
          <DEFINITION_FUNCTION arguments="0" name="emptySet">
            <LATEXPATTERN>\emptyset</LATEXPATTERN>
            <FORMULA>
              <PREDCON ref="l.equal">
                <FUNCON ref="emptySet" />
                <CLASS>
                  <VAR id="x" />
                    <PREDCON ref="l.notEqual">
                      <VAR id="x" />
                      <VAR id="x" />
                   </PREDCON>
                </CLASS>
              </PREDCON>
            </FORMULA>
          </DEFINITION_FUNCTION>
        </NODE>

        <NODE id="theorem:noClassIsMemberOfEmptySet" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                No class is element of the empty class.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Keine Klasse ist Element der leeren Klasse.
                
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <FORALL>
                <VAR id="z" />
                <PREDCON ref="notIn">
                  <VAR id="z" />
                  <FUNCON ref="emptySet" />
                </PREDCON>
              </FORALL>
            </FORMULA>
            <PROOF kind="informal" level="1">
              <LATEX language="en">
                <![CDATA[
                  Asumption: $z \in \emptyset$
                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{cX}
                    $z \in \{ x \ | \ x \neq x\}$
                      & \qref{definition:emptySet} \\
                    $\mathfrak{M}(z) \ \land z \ \neq z$
                      & \qref{axiom:classDefinition} \\
                        $z \neq z$
                      & elementary logic \\
                        $\neg \ (z = z)$
                      & \qref{l.definition:notEqual}
                  \end{tabularx}
                  
                  \par
                  So we have a contradiction to \qref{l.axiom:identityIsReflexive} and our asumption must be false. So we have $\neg (z \in \emptyset)$ and can conclude the following.
                  
                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{cX}
                        $\neg \ ( z \in \emptyset)$
                      &  \\
                        $z \notin \emptyset$
                      & \qref{definition:notIn} \\
                        $\forall z \ z \notin \emptyset$
                      & \qref{l.rule:derivedQuantification}
                  \end{tabularx}
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  Annahme: $z \in \emptyset$
                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{cX}
                    $z \in \{ x \ | \ x \neq x\}$
                      & \qref{definition:emptySet} \\
                    $\mathfrak{M}(z) \ \land z \ \neq z$
                      & \qref{axiom:classDefinition} \\
                        $z \neq z$
                      & elementary logic \\
                        $\neg \ (z = z)$
                      & \qref{l.definition:notEqual}
                  \end{tabularx}
                  
                  \par
                  Damit haben wir einen Widerspruch zu \qref{l.axiom:identityIsReflexive} und unsere Annahme muss falsch sein. Also gilt $\neg (z \in \emptyset)$ und wir können weiter folgern.
                  
                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{cX}
                        $\neg \ ( z \in \emptyset)$
                      &  \\
                        $z \notin \emptyset$
                      & \qref{definition:notIn} \\
                        $\forall z \ z \notin \emptyset$
                      & \qref{l.rule:derivedQuantification}
                  \end{tabularx}
                ]]>
              </LATEX>
            </PROOF>
          </THEOREM>
        </NODE>

        <NODE id="theorem:noClassIsMemberIsEmptySet" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
              
                A class with no elements is the empty class.
  
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Eine Klasse, welche keine Elemente besitzt, ist die leere Klasse.
                
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <EQUI>
                <FORALL>
                  <VAR id="z" />
                  <PREDCON ref="notIn">
                    <VAR id="z" />
                    <VAR id="x" />
                  </PREDCON>
                </FORALL>
                <PREDCON ref="l.equal">
                  <VAR id="x" />
                  <FUNCON ref="emptySet" />
                </PREDCON>
              </EQUI>
            </FORMULA>
            <PROOF kind="informal" level="1">
              <LATEX language="en">
                <![CDATA[
                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{rclX}
                    $x = \emptyset$ & $\leftrightarrow$ & $\forall z \ (z \in x \leftrightarrow z \in \emptyset)$
                      & \qref{theorem:extensonalityEquivalence} \\
                    & $\leftrightarrow$ & $\forall z \ (z \notin x \leftrightarrow z \notin \emptyset)$
                      & \qref{l.rule:replaceEquiFormula} with \qref{l.theorem:propositionalCalculus/ao} \\
                    & $\leftrightarrow$ & $\forall z \ (z \notin x \leftrightarrow \ \top)$
                      & \qref{theorem:noClassIsMemberOfEmptySet} \\
                    & $\leftrightarrow$ & $\forall z \ z \notin x$
                      & \qref{l.rule:replaceEquiFormula} with \qref{l.theorem:propositionalCalculus/be}
                  \end{tabularx}
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{rclX}
                    $x = \emptyset$ & $\leftrightarrow$ & $\forall z \ (z \in x \leftrightarrow z \in \emptyset)$
                      & \qref{theorem:extensonalityEquivalence} \\
                    & $\leftrightarrow$ & $\forall z \ (z \notin x \leftrightarrow z \notin \emptyset)$
                      & \qref{l.rule:replaceEquiFormula} mit \qref{l.theorem:propositionalCalculus/ao} \\
                    & $\leftrightarrow$ & $\forall z \ (z \notin x \leftrightarrow \ \top)$
                      & \qref{theorem:noClassIsMemberOfEmptySet} \\
                    & $\leftrightarrow$ & $\forall z \ z \notin x$
                      & \qref{l.rule:replaceEquiFormula} mit \qref{l.theorem:propositionalCalculus/be}
                  \end{tabularx}
                ]]>
              </LATEX>
            </PROOF>
          </THEOREM>
        </NODE>

      </SUBSECTIONS>

    </SECTION>
  </CHAPTER>
  
  <CHAPTER>
    <TITLE>
      <LATEX language="en">
         Boolean Algebra of Classes\index{Boolean algebra!of classes}
      </LATEX>
      <LATEX language="de">
         Boolesche Algebra der Klassen\index{Boolesche Algebra!der Klassen}
      </LATEX>
    </TITLE>
    <INTRODUCTION>
      <LATEX language="en">
        <![CDATA[

          Now the elementary class operations and their properties are described.
          
          A \emph{boolean algebra} is an algebraic structure that abstracts from the
          logical operators \emph{and}, \emph{or}, \emph{not} and their set theoretic
          connectives \emph{intersection}, \emph{union}, \emph{complement}.
          
          \par
          The name is due to \emph{G. Boole} who defined this structure to be able to
          use algebraic methods within propositional calculus.

        ]]>
      </LATEX>
      <LATEX language="de">
        <![CDATA[

          Die elementaren Operationen von Klassen und ihre Eigenschaften werden nun beschrieben.

          Eine Boolesche Algebra, oft auch Boolescher Verband genannt, ist eine spezielle algebraische
          Struktur, die die Eigenschaften der logischen Operatoren \emph{und}, \emph{oder}, \emph{nicht}
          sowie die Eigenschaften der mengentheoretischen Verknüpfungen \emph{Durchschnitt},
          \emph{Vereinigung} und \emph{Komplement} abstrahiert.

          \par
          Sie ist benannt nach \emph{G. Boole}, der sie in der Mitte des 19. Jahrhunderts definierte, um
          algebraische Methoden in der Aussagenlogik anwenden zu können.

        ]]>
      </LATEX>
    </INTRODUCTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">
           Boolean Class Operators
        </LATEX>
        <LATEX language="de">
           Boolesche Klassenoperatoren
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[

            With the classs notation \qref{rule:classDefinition} we can define new class operators with the
            help of logical connectives.

          ]]>
        </LATEX>
        <LATEX language="de">
          <![CDATA[

            Die Klassenschreibweise \qref{rule:classDefinition} ermöglicht die Definition von Klassenoperatoren mithilfe
            logischer Verknüpfungen.

          ]]>
        </LATEX>
      </INTRODUCTION>
      <SUBSECTIONS>
        <NODE id="definition:union" level="formal">
          <NAME>
            <LATEX language="en">union</LATEX>
            <LATEX language="de">vereinigt mit</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Union Operator\index{union}\index{class!union}</LATEX>
            <LATEX language="de">Vereinigung\index{Vereinigung}\index{Klasse!Vereinigung}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                The union of two classes contains exactly all elements of both classes.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Die Vereinigung zweier Klassen besteht aus den Elementen beider Klassen.
                
              ]]>
            </LATEX>
          </PRECEDING>
          <DEFINITION_FUNCTION arguments="2" name="union">
            <LATEXPATTERN>(#1 \cup #2)</LATEXPATTERN>
            <FORMULA>
              <PREDCON ref="l.equal">
                <FUNCON ref="union">
                  <VAR id="x" />
                  <VAR id="y" />
                </FUNCON>
                <CLASS>
                  <VAR id="z" />
                  <OR>
                    <PREDCON ref="in">
                      <VAR id="z" />
                      <VAR id="x" />
                    </PREDCON>
                    <PREDCON ref="in">
                      <VAR id="z" />
                      <VAR id="y" />
                    </PREDCON>
                  </OR>
                </CLASS>
              </PREDCON>
            </FORMULA>
          </DEFINITION_FUNCTION>
        </NODE>

      
        <NODE id="definition:intersection" level="formal">
          <NAME>
            <LATEX language="en">intersection</LATEX>
            <LATEX language="de">geschnitten mit</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Intersection Operator\index{intersection}\index{class!intersection}</LATEX>
            <LATEX language="de">Durchschnitt\index{Durchschnitt}\index{Klasse!Durchschnitt}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                Analogous the intersection of two classes is defined as the class which 
                contains exactly those elements that are member of both classes.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Entsprechend wird der Durchschnitt zweier Klassen definiert, als die Klasse, die aus den Elementen besteht, die in beiden Klassen vorhanden sind.
                
              ]]>
            </LATEX>
          </PRECEDING>
          <DEFINITION_FUNCTION arguments="2" name="intersection">
            <LATEXPATTERN>(#1 \cap #2)</LATEXPATTERN>
            <FORMULA>
              <PREDCON ref="l.equal">
                <FUNCON ref="intersection">
                  <VAR id="x" />
                  <VAR id="y" />
                </FUNCON>
                <CLASS>
                  <VAR id="z" />
                  <AND>
                    <PREDCON ref="in">
                      <VAR id="z" />
                      <VAR id="x" />
                    </PREDCON>
                    <PREDCON ref="in">
                      <VAR id="z" />
                      <VAR id="y" />
                    </PREDCON>
                  </AND>
                </CLASS>
              </PREDCON>
            </FORMULA>
          </DEFINITION_FUNCTION>
        </NODE>

        <NODE id="definition:complement" level="formal">
          <NAME>
            <LATEX language="en">complement</LATEX>
            <LATEX language="de">Komplement von</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Complement Operator\index{complement}\index{class!complement}</LATEX>
            <LATEX language="de">Komplement\index{Komplement}\index{Klasse!Komplement}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                Also the complement of a class can be simply defined.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Auch das Komplement einer Klasse kann einfach definiert werden.
                
              ]]>
            </LATEX>
          </PRECEDING>
          <DEFINITION_FUNCTION arguments="1" name="complement">
            <LATEXPATTERN>\overline{#1}</LATEXPATTERN>
            <FORMULA>
              <PREDCON ref="l.equal">
                <FUNCON ref="complement">
                  <VAR id="x" />
                </FUNCON>
                <CLASS>
                  <VAR id="z" />
                  <PREDCON ref="notIn">
                    <VAR id="z" />
                    <VAR id="x" />
                  </PREDCON>
                </CLASS>
              </PREDCON>
            </FORMULA>
          </DEFINITION_FUNCTION>
        </NODE>

        <NODE id="theorem:unionMember" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                If a set is an element of the union of two classes can be checked directly.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Ob eine Menge ein Element der Vereinigung zweier Klassen ist, kann natürlich auch direkt angegeben werden.
                
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <EQUI>
                <PREDCON ref="in">
                  <VAR id="z" />
                  <FUNCON ref="union">
                    <VAR id="x" />
                    <VAR id="y" />
                  </FUNCON>
                </PREDCON>
                <OR>
                  <PREDCON ref="in">
                    <VAR id="z" />
                    <VAR id="x" />
                  </PREDCON>
                  <PREDCON ref="in">
                    <VAR id="z" />
                    <VAR id="y" />
                  </PREDCON>
                </OR>
              </EQUI>
            </FORMULA>
            <PROOF kind="informal" level="1">
              <LATEX language="en">
                <![CDATA[
                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{rclX}
                    $(x \cup y)$ & $=$ & $\{ z \ | \ (z \in x \lor z \in y ) \}$
                      & \qref{definition:union} \\
                    $u \in (x \cup y)$ & $\leftrightarrow$ & $u \in \{ z \ | \ (z \in x \lor z \in y ) \}$
                      & \qref{l.theorem:leibnizEquivalence} \\
                    $u \in (x \cup y)$ & $\leftrightarrow$ & $(\mathfrak{M}(u) \land (u \in x \lor u \in y))$
                      & \qref{axiom:classDefinition} \\
                    $u \in (x \cup y)$ & $\leftrightarrow$ & $((\mathfrak{M}(u) \land u \in x ) \lor (\mathfrak{M}(u) \land u \in y))$
                      & \qref{l.theorem:propositionalCalculus/at} \\
                    $u \in (x \cup y)$ & $\leftrightarrow$ & $(u \in x \lor u \in y)$
                      & \qref{theorem:inSetEqualInSetAndIsSet}
                  \end{tabularx}
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{rclX}
                    $(x \cup y)$ & $=$ & $\{ z \ | \ (z \in x \lor z \in y ) \}$
                      & \qref{definition:union} \\
                    $u \in (x \cup y)$ & $\leftrightarrow$ & $u \in \{ z \ | \ (z \in x \lor z \in y ) \}$
                      & \qref{l.theorem:leibnizEquivalence} \\
                    $u \in (x \cup y)$ & $\leftrightarrow$ & $(\mathfrak{M}(u) \land (u \in x \lor u \in y))$
                      & \qref{axiom:classDefinition} \\
                    $u \in (x \cup y)$ & $\leftrightarrow$ & $((\mathfrak{M}(u) \land u \in x ) \lor (\mathfrak{M}(u) \land u \in y))$
                      & \qref{l.theorem:propositionalCalculus/at} \\
                    $u \in (x \cup y)$ & $\leftrightarrow$ & $(u \in x \lor u \in y)$
                      & \qref{theorem:inSetEqualInSetAndIsSet}
                  \end{tabularx}
                ]]>
              </LATEX>
            </PROOF>
          </THEOREM>
        </NODE>

        <NODE id="theorem:intersectionMember" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                Membership of an intersection can be written down directly too.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Entsprechendes gilt für den Durchschnitt zweier Klassen.
                
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <EQUI>
                <PREDCON ref="in">
                  <VAR id="z" />
                  <FUNCON ref="intersection">
                    <VAR id="x" />
                    <VAR id="y" />
                  </FUNCON>
                </PREDCON>
                <AND>
                  <PREDCON ref="in">
                    <VAR id="z" />
                    <VAR id="x" />
                  </PREDCON>
                  <PREDCON ref="in">
                    <VAR id="z" />
                    <VAR id="y" />
                  </PREDCON>
                </AND>
              </EQUI>
            </FORMULA>
            <PROOF kind="informal" level="1">
              <LATEX language="en">
                <![CDATA[
                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{rclX}
                    $(x \cap y)$ & $=$ & $\{ z \ | \ (z \in x \land z \in y ) \}$
                      & \qref{definition:union} \\
                    $u \in (x \cap y)$ & $\leftrightarrow$ & $u \in \{ z \ | \ (z \in x \land z \in y ) \}$
                      & \qref{l.theorem:leibnizEquivalence} \\
                    $u \in (x \cap y)$ & $\leftrightarrow$ & $(\mathfrak{M}(u) \land (u \in x \land u \in y))$
                      & \qref{axiom:classDefinition} \\
                    $u \in (x \cap y)$ & $\leftrightarrow$ & $((\mathfrak{M}(u) \land u \in x ) \land u \in y))$
                      & \qref{l.theorem:propositionalCalculus/aj} \\
                    $u \in (x \cap y)$ & $\leftrightarrow$ & $(u \in x \land u \in y)$
                      & \qref{theorem:inSetEqualInSetAndIsSet}
                  \end{tabularx}
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{rclX}
                    $(x \cap y)$ & $=$ & $\{ z \ | \ (z \in x \land z \in y ) \}$
                      & \qref{definition:union} \\
                    $u \in (x \cap y)$ & $\leftrightarrow$ & $u \in \{ z \ | \ (z \in x \land z \in y ) \}$
                      & \qref{l.theorem:leibnizEquivalence} \\
                    $u \in (x \cap y)$ & $\leftrightarrow$ & $(\mathfrak{M}(u) \land (u \in x \land u \in y))$
                      & \qref{axiom:classDefinition} \\
                    $u \in (x \cap y)$ & $\leftrightarrow$ & $((\mathfrak{M}(u) \land u \in x ) \land u \in y))$
                      & \qref{l.theorem:propositionalCalculus/aj} \\
                    $u \in (x \cap y)$ & $\leftrightarrow$ & $(u \in x \land u \in y)$
                      & \qref{theorem:inSetEqualInSetAndIsSet}
                  \end{tabularx}
                ]]>
              </LATEX>
            </PROOF>
          </THEOREM>
        </NODE>

        <NODE id="theorem:complementMember" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                For the membership of the complement we have a similar result but here we must check
                the property \emph{is a set} explicitly.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Analoges gilt für das Komplement, dort muss jedoch die Mengeneigenschaft explizit abgeprüft werden.
                
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <EQUI>
                <PREDCON ref="in">
                  <VAR id="z" />
                  <FUNCON ref="complement">
                    <VAR id="x" />
                  </FUNCON>
                </PREDCON>
                <AND>
                  <PREDCON ref="isSet">
                    <VAR id="z" />
                  </PREDCON>
                  <PREDCON ref="notIn">
                    <VAR id="z" />
                    <VAR id="x" />
                  </PREDCON>
                </AND>
              </EQUI>
            </FORMULA>
            <PROOF kind="informal" level="1">
              <LATEX language="en">
                <![CDATA[
                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{rclX}
                    $\overline{x}$ & $=$ & $\{ z \ | \ z \notin x \}$
                      & \qref{definition:complement} \\
                    $u \in \overline{x}$ & $\leftrightarrow$ & $u \in \{ z \ | \ z \notin x \}$
                      & \qref{l.theorem:leibnizEquivalence} \\
                    $u \in \overline{x}$ & $\leftrightarrow$ & $(\mathfrak{M}(u) \land u \notin x)$
                      & \qref{axiom:classDefinition} 
                  \end{tabularx}
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{rclX}
                    $\overline{x}$ & $=$ & $\{ z \ | \ z \notin x \}$
                      & \qref{definition:complement} \\
                    $u \in \overline{x}$ & $\leftrightarrow$ & $u \in \{ z \ | \ z \notin x \}$
                      & \qref{l.theorem:leibnizEquivalence} \\
                    $u \in \overline{x}$ & $\leftrightarrow$ & $(\mathfrak{M}(u) \land u \notin x)$
                      & \qref{axiom:classDefinition} 
                  \end{tabularx}
                ]]>
              </LATEX>
            </PROOF>
          </THEOREM>
        </NODE>


        <NODE id="theorem:unionIntersectionComplement" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                By the previous propositions we learned how to transform the logical 
                operators $\lor$, $\land$ and $\neg$ into the class operators $\cup$, $\cap$ and $\bar{~}$. So we are now able to transform the logical laws into set theoretic
                propositions.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Die vorherigen Sätze zeigen die Übertragbarkeit der Eigenschaften der logischen Verknüpfungen $\lor$, $\land$ und $\neg$ auf die Klassenverknüpfungen $\cup$, $\cap$ und $\bar{~}$. Deshalb lassen sich die entsprechenden logischen Gesetzmässigkeiten direkt auf die Klassenverknüpfungen übertragen.
                
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <AND>

                <PREDCON ref="l.equal">
                  <FUNCON ref="union">
                    <VAR id="x" />
                    <VAR id="y" />
                  </FUNCON>
                  <FUNCON ref="union">
                    <VAR id="y" />
                    <VAR id="x" />
                  </FUNCON>
                </PREDCON>

                <PREDCON ref="l.equal">
                  <FUNCON ref="intersection">
                    <VAR id="x" />
                    <VAR id="y" />
                  </FUNCON>
                  <FUNCON ref="intersection">
                    <VAR id="y" />
                    <VAR id="x" />
                  </FUNCON>
                </PREDCON>

                <PREDCON ref="l.equal">
                  <FUNCON ref="union">
                    <FUNCON ref="union">
                      <VAR id="x" />
                      <VAR id="y" />
                    </FUNCON>
                    <VAR id="z" />
                  </FUNCON>
                  <FUNCON ref="union">
                    <VAR id="x" />
                    <FUNCON ref="union">
                      <VAR id="y" />
                      <VAR id="z" />
                    </FUNCON>
                  </FUNCON>
                </PREDCON>

                <PREDCON ref="l.equal">
                  <FUNCON ref="intersection">
                    <FUNCON ref="intersection">
                      <VAR id="x" />
                      <VAR id="y" />
                    </FUNCON>
                    <VAR id="z" />
                  </FUNCON>
                  <FUNCON ref="intersection">
                    <VAR id="x" />
                    <FUNCON ref="intersection">
                      <VAR id="y" />
                      <VAR id="z" />
                    </FUNCON>
                  </FUNCON>
                </PREDCON>

                <PREDCON ref="l.equal">
                  <VAR id="x" />
                  <FUNCON ref="union">
                    <VAR id="x" />
                    <VAR id="x" />
                  </FUNCON>
                </PREDCON>

                <PREDCON ref="l.equal">
                  <VAR id="x" />
                  <FUNCON ref="intersection">
                    <VAR id="x" />
                    <VAR id="x" />
                  </FUNCON>
                </PREDCON>

                <PREDCON ref="l.equal">
                  <FUNCON ref="complement">
                    <FUNCON ref="complement">
                      <VAR id="x" />
                    </FUNCON>
                  </FUNCON>
                  <VAR id="x" />
                </PREDCON>

                <PREDCON ref="l.equal">
                  <FUNCON ref="complement">
                    <FUNCON ref="union">
                      <VAR id="x" />
                      <VAR id="y" />
                    </FUNCON>
                  </FUNCON>
                  <FUNCON ref="intersection">
                    <FUNCON ref="complement">
                      <VAR id="x" />
                    </FUNCON>
                    <FUNCON ref="complement">
                      <VAR id="y" />
                    </FUNCON>
                  </FUNCON>
                </PREDCON>

                <PREDCON ref="l.equal">
                  <FUNCON ref="complement">
                    <FUNCON ref="intersection">
                      <VAR id="x" />
                      <VAR id="y" />
                    </FUNCON>
                  </FUNCON>
                  <FUNCON ref="union">
                    <FUNCON ref="complement">
                      <VAR id="x" />
                    </FUNCON>
                    <FUNCON ref="complement">
                      <VAR id="y" />
                    </FUNCON>
                  </FUNCON>
                </PREDCON>

                <PREDCON ref="l.equal">
                  <FUNCON ref="union">
                    <VAR id="x" />
                    <FUNCON ref="intersection">
                      <VAR id="y" />
                      <VAR id="z" />
                    </FUNCON>
                  </FUNCON>
                  <FUNCON ref="intersection">
                    <FUNCON ref="union">
                      <VAR id="x" />
                      <VAR id="y" />
                    </FUNCON>
                    <FUNCON ref="union">
                      <VAR id="x" />
                      <VAR id="z" />
                    </FUNCON>
                  </FUNCON>
                </PREDCON>

                <PREDCON ref="l.equal">
                  <FUNCON ref="intersection">
                    <VAR id="x" />
                    <FUNCON ref="union">
                      <VAR id="y" />
                      <VAR id="z" />
                    </FUNCON>
                  </FUNCON>
                  <FUNCON ref="union">
                    <FUNCON ref="intersection">
                      <VAR id="x" />
                      <VAR id="y" />
                    </FUNCON>
                    <FUNCON ref="intersection">
                      <VAR id="x" />
                      <VAR id="z" />
                    </FUNCON>
                  </FUNCON>
                </PREDCON>

                <PREDCON ref="l.equal">
                  <FUNCON ref="complement">
                    <FUNCON ref="emptySet" />
                  </FUNCON>
                  <FUNCON ref="universalClass" />
                </PREDCON>

                <PREDCON ref="l.equal">
                  <FUNCON ref="complement">
                    <FUNCON ref="universalClass" />
                  </FUNCON>
                  <FUNCON ref="emptySet" />
                </PREDCON>

                <PREDCON ref="l.equal">
                  <FUNCON ref="intersection">
                    <VAR id="x" />
                    <FUNCON ref="universalClass" />
                  </FUNCON>
                  <VAR id="x" />
                </PREDCON>

                <PREDCON ref="l.equal">
                  <FUNCON ref="intersection">
                    <VAR id="x" />
                    <FUNCON ref="emptySet" />
                  </FUNCON>
                  <FUNCON ref="emptySet" />
                </PREDCON>

                <PREDCON ref="l.equal">
                  <FUNCON ref="union">
                    <VAR id="x" />
                    <FUNCON ref="universalClass" />
                  </FUNCON>
                  <FUNCON ref="universalClass" />
                </PREDCON>

                <PREDCON ref="l.equal">
                  <FUNCON ref="union">
                    <VAR id="x" />
                    <FUNCON ref="emptySet" />
                  </FUNCON>
                  <VAR id="x" />
                </PREDCON>

                <PREDCON ref="l.equal">
                  <FUNCON ref="union">
                    <VAR id="x" />
                    <FUNCON ref="complement">
                      <VAR id="x" />
                    </FUNCON>
                  </FUNCON>
                  <FUNCON ref="universalClass" />
                </PREDCON>

                <PREDCON ref="l.equal">
                  <FUNCON ref="intersection">
                    <VAR id="x" />
                    <FUNCON ref="complement">
                      <VAR id="x" />
                    </FUNCON>
                  </FUNCON>
                  <FUNCON ref="emptySet" />
                </PREDCON>

              </AND>
            </FORMULA>
            <PROOF kind="informal" level="1">
              <LATEX language="en">
                <![CDATA[
                  We show the proof for (g) as an example.
                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{rclX}
                    $u \in x$ & $\leftrightarrow$ & $(\mathfrak{M}(u) \land u \in x)$
                      & \qref{definition:complement} \\
                              & $\leftrightarrow$ & $(\bot \lor (\mathfrak{M}(u) \land u \in x))$
                      & \qref{l.theorem:propositionalCalculus/ax} \\
                              & $\leftrightarrow$ & $((\mathfrak{M}(u) \land \neg \mathfrak{M}(u)) \lor (\mathfrak{M}(u) \land u \in x))$
                      & \qref{l.theorem:propositionalCalculus/az} \\
                              & $\leftrightarrow$ & $(\mathfrak{M}(u) \land (\neg \mathfrak{M}(u)) \land u \in x))$
                      & \qref{l.theorem:propositionalCalculus/at} \\
                              & $\leftrightarrow$ & $(\mathfrak{M}(u) \land (\neg \mathfrak{M}(u)) \land \neg \neg u \in x))$
                      & \qref{l.theorem:propositionalCalculus/am} \\
                              & $\leftrightarrow$ & $(\mathfrak{M}(u) \land (\neg \mathfrak{M}(u)) \land \neg u \notin x))$
                      & \qref{definition:notIn} \\
                              & $\leftrightarrow$ & $(\mathfrak{M}(u) \land \neg (\mathfrak{M}(u)) \lor u \notin x))$
                      & \qref{l.theorem:propositionalCalculus/aq} \\
                              & $\leftrightarrow$ & $(\mathfrak{M}(u) \land \neg (u \in \overline{x}))$
                      & \qref{theorem:complementMember} \\
                              & $\leftrightarrow$ & $(\mathfrak{M}(u) \land u \notin \overline{x})$
                      & \qref{definition:notIn} \\
                              & $\leftrightarrow$ & $u \in \overline{\overline{x}}$
                      & \qref{theorem:complementMember}
                  \end{tabularx}
                  
                  \par
                  So we have shown: $u \in x \leftrightarrow u \in \overline{\overline{x}}$
                  Now we can argue further on.

                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{rclX}

                    $u \in x$ & $\leftrightarrow$ & $u \in \overline{\overline{x}}$
                      &  \\
                    $\forall u \ (u \in x$ & $\leftrightarrow$ & $u \in \overline{\overline{x}})$
                      & \qref{l.rule:derivedQuantification} \\
                    $\forall u \ u \in x$ & $\leftrightarrow$ & $\forall u \ u \in \overline{\overline{x}}$
                      & \qref{l.theorem:predicateCalculus/c} \\
                    $x$ & $=$ & $\overline{\overline{x}}$
                      & \qref{theorem:extensionalitySetRestricted}
                  \end{tabularx}
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  Exemplarisch beweisen wir (g).
                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{rclX}
                    $u \in x$ & $\leftrightarrow$ & $(\mathfrak{M}(u) \land u \in x)$
                      & \qref{definition:complement} \\
                              & $\leftrightarrow$ & $(\bot \lor (\mathfrak{M}(u) \land u \in x))$
                      & \qref{l.theorem:propositionalCalculus/ax} \\
                              & $\leftrightarrow$ & $((\mathfrak{M}(u) \land \neg \mathfrak{M}(u)) \lor (\mathfrak{M}(u) \land u \in x))$
                      & \qref{l.theorem:propositionalCalculus/az} \\
                              & $\leftrightarrow$ & $(\mathfrak{M}(u) \land (\neg \mathfrak{M}(u)) \land u \in x))$
                      & \qref{l.theorem:propositionalCalculus/at} \\
                              & $\leftrightarrow$ & $(\mathfrak{M}(u) \land (\neg \mathfrak{M}(u)) \land \neg \neg u \in x))$
                      & \qref{l.theorem:propositionalCalculus/am} \\
                              & $\leftrightarrow$ & $(\mathfrak{M}(u) \land (\neg \mathfrak{M}(u)) \land \neg u \notin x))$
                      & \qref{definition:notIn} \\
                              & $\leftrightarrow$ & $(\mathfrak{M}(u) \land \neg (\mathfrak{M}(u)) \lor u \notin x))$
                      & \qref{l.theorem:propositionalCalculus/aq} \\
                              & $\leftrightarrow$ & $(\mathfrak{M}(u) \land \neg (u \in \overline{x}))$
                      & \qref{theorem:complementMember} \\
                              & $\leftrightarrow$ & $(\mathfrak{M}(u) \land u \notin \overline{x})$
                      & \qref{definition:notIn} \\
                              & $\leftrightarrow$ & $u \in \overline{\overline{x}}$
                      & \qref{theorem:complementMember}
                  \end{tabularx}
                  
                  \par
                  Also haben wir gezeigt: $u \in x \leftrightarrow u \in \overline{\overline{x}}$
                  Nun können wir weiter schließen.

                  \mbox{}
                  \par
                  \begin{tabularx}{\linewidth}{rclX}

                    $u \in x$ & $\leftrightarrow$ & $u \in \overline{\overline{x}}$
                      &  \\
                    $\forall u \ (u \in x$ & $\leftrightarrow$ & $u \in \overline{\overline{x}})$
                      & \qref{l.rule:derivedQuantification} \\
                    $\forall u \ u \in x$ & $\leftrightarrow$ & $\forall u \ u \in \overline{\overline{x}}$
                      & \qref{l.theorem:predicateCalculus/c} \\
                    $x$ & $=$ & $\overline{\overline{x}}$
                      & \qref{theorem:extensionalitySetRestricted}
                  \end{tabularx}
                ]]>
              </LATEX>
            </PROOF>
          </THEOREM>
        </NODE>

      </SUBSECTIONS>

    </SECTION>

    <SECTION>
      <TITLE>
        <LATEX language="en">
           Boolean Algebra\index{Boolean algebra}
        </LATEX>
        <LATEX language="de">
           Boolsche Algebra\index{Boolesche Algebra}
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[

            The classes build together with the operators $\cap$, $\cup$, $\bar{~}$ and the
            constants $\emptyset$ a Boolean algebra\index{Boolean algebra},
            
            \par
            +++
            References to commutative law, associative law, distributive law, idempotence, etc.
            
          ]]>
        </LATEX>
        <LATEX language="de">
          <![CDATA[

            Die Klassen bilden mit den Operatoren $\cap$, $\cup$, $\bar{~}$ und den Konstanten $\emptyset$,
            $\mathfrak{V}$ eine Boolesche Algebra\index{Boolesche Algebra}.
            \par
            +++ 
            Referenzen zu Kommutativität, Assoziativität, Distributivität, Idempotenz, etc.

          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>

    <SECTION>
      <TITLE>
        <LATEX language="en">
           Order\index{order}
        </LATEX>
        <LATEX language="de">
           Ordnung\index{Ordnung}
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
          
            For a boolean algebra a \emph{partial order}\index{order!partial} relation can be defined. Therefore we can do 
            the same for the boolean class algebra.
          
          ]]>
        </LATEX>
        <LATEX language="de">
          <![CDATA[
          
            Für eine Boolsche Algebra kann eine kanonische \emph{Teilordnung}\index{Teilordnung} definiert werden. Daher
            können wir auch für die Klassenalgebra eine Teilordnung festlegen.
          
          ]]>
        </LATEX>
      </INTRODUCTION>

      <SUBSECTIONS>
        <NODE id="definition:subclass" level="formal">
          <NAME>
            <LATEX language="en">subclass</LATEX>
            <LATEX language="de">Teilklasse von</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Subclass Predicate\index{subclass}\index{inclusion}</LATEX>
            <LATEX language="de">Teilklasse\index{Teilklasse}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                We define the \emph{subclass relation} (\emph{inclusion}) by an intersection.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Wir definieren die \emph{Teilklassenrelation} durch eine Schnittklassenbildung.
                
              ]]>
            </LATEX>
          </PRECEDING>
          <DEFINITION_PREDICATE arguments="2" name="subclass">
            <LATEXPATTERN>#1 \ \subseteq \ #2</LATEXPATTERN>
            <FORMULA>
              <EQUI>
                <PREDCON ref="subclass">
                  <VAR id="x" />
                  <VAR id="y" />
                </PREDCON>
                <PREDCON ref="l.equal">
                  <FUNCON ref="intersection">
                    <VAR id="x" />
                    <VAR id="y" />
                  </FUNCON>
                    <VAR id="x" />
                </PREDCON>
              </EQUI>
            </FORMULA>
          </DEFINITION_PREDICATE>
          <SUCCEEDING>
            <LATEX language="en">
              <![CDATA[

                If $x$ and $y$ are sets we also say: $x$ is \emph{subset}\index{subset} of $y$.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
              
                Sind $x$ und $y$ Mengen sagen wir auch: $x$ ist \emph{Teilmenge}\index{Teilmenge} von $y$.
                
              ]]>
            </LATEX>
          </SUCCEEDING>
        </NODE>
        
        <NODE id="theorem:subsetIfMemberschipImpl" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                Now we get the common subclass definition as a proposition. 

              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Die übliche Definition der Teilklassenrelation erhalten wir nun als Satz.

              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <EQUI>
                <PREDCON ref="subclass">
                  <VAR id="x" />
                  <VAR id="y" />
                </PREDCON>                
                <FORALL>
                  <VAR id="z" />
                  <IMPL>
                    <PREDCON ref="in">
                      <VAR id="z" />
                      <VAR id="x" />
                    </PREDCON>
                    <PREDCON ref="in">
                      <VAR id="z" />
                      <VAR id="y" />
                    </PREDCON>
                  </IMPL>
                </FORALL>
              </EQUI>
            </FORMULA>
          </THEOREM>
        </NODE>

        <NODE id="theorem:subsetIsPartialOrdered" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                This relation is reflexive, transitive and antisymmetric. As intended it is a partial order\index{order!partial} relation with $\emptyset$ as minimum and $\mathfrak{V}$ as maximum element.
             
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Diese Relation ist reflexiv, transitiv und antisymmetrisch, definiert also eine Teilordnung\index{Teilordnung} mit $\emptyset$ als kleinstem und $\mathfrak{V}$ als größtem Element.
             
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <AND>
              
                <PREDCON ref="subclass">
                  <VAR id="x" />
                  <VAR id="x" />
                </PREDCON>

                <IMPL>
                  <AND>
                    <PREDCON ref="subclass">
                      <VAR id="x" />
                      <VAR id="y" />
                    </PREDCON>
                    <PREDCON ref="subclass">
                      <VAR id="y" />
                      <VAR id="z" />
                    </PREDCON>
                  </AND>
                  <PREDCON ref="subclass">
                    <VAR id="x" />
                    <VAR id="z" />
                  </PREDCON>
                </IMPL>

                <EQUI>
                  <AND>
                    <PREDCON ref="subclass">
                      <VAR id="x" />
                      <VAR id="y" />
                    </PREDCON>
                    <PREDCON ref="subclass">
                      <VAR id="y" />
                      <VAR id="x" />
                    </PREDCON>
                  </AND>
                  <PREDCON ref="l.equal">
                    <VAR id="x" />
                    <VAR id="y" />
                  </PREDCON>
                </EQUI>

                <PREDCON ref="subclass">
                  <FUNCON ref="emptySet" />
                  <VAR id="x" />
                </PREDCON>

                <PREDCON ref="subclass">
                  <VAR id="x" />
                  <FUNCON ref="universalClass" />
                </PREDCON>

                <IMPL>
                  <PREDCON ref="subclass">
                    <VAR id="x" />
                    <FUNCON ref="emptySet" />
                  </PREDCON>
                  <PREDCON ref="l.equal">
                    <VAR id="x" />
                    <FUNCON ref="emptySet" />
                  </PREDCON>
                </IMPL>

                <IMPL>
                  <PREDCON ref="subclass">
                    <FUNCON ref="universalClass" />
                    <VAR id="x" />
                  </PREDCON>
                  <PREDCON ref="l.equal">
                    <VAR id="x" />
                    <FUNCON ref="universalClass" />
                  </PREDCON>
                </IMPL>     
              </AND>
            </FORMULA>
          </THEOREM>
        </NODE>

        <NODE id="theorem:intersectionIsSubset" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                An intersection is always a subclass of its original classes.
             
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Eine Schnittklasse ist immer Teilmenge ihrer Ausgangsklassen.
             
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <AND>
                <PREDCON ref="subclass">
                  <FUNCON ref="intersection">
                    <VAR id="x" />
                    <VAR id="y" />
                  </FUNCON>
                  <VAR id="x" />
                </PREDCON>

                <PREDCON ref="subclass">
                  <FUNCON ref="intersection">
                    <VAR id="x" />
                    <VAR id="y" />
                  </FUNCON>
                  <VAR id="y" />
                </PREDCON>
              </AND>
            </FORMULA>
          </THEOREM>
        </NODE>

        <NODE id="theorem:unionIsSuperset" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                A union has its original classes as subclasses.
             
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Eine Vereinigungsklasse hat ihre Ausgangsklassen als Teilklassen.
             
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <AND>
                <PREDCON ref="subclass">
                  <VAR id="x" />
                  <FUNCON ref="union">
                    <VAR id="x" />
                    <VAR id="y" />
                  </FUNCON>
                </PREDCON>

                <PREDCON ref="subclass">
                  <VAR id="y" />
                  <FUNCON ref="union">
                    <VAR id="x" />
                    <VAR id="y" />
                  </FUNCON>
                </PREDCON>
              </AND>
            </FORMULA>
          </THEOREM>
        </NODE>

        <NODE id="theorem:subsetAndAddition" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                With two classes the union of both is also subclass. And if a class is subclass of two other classes it is also subclass of their intersection. For both implications the reverse is also true.
             
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Für zwei Teilklassen ist auch die Vereinigungsklasse Teilklasse. Und falls eine Klasse Teilklasse von zwei Klassen ist, dann ist sie auch Teilklasse der Schnittklasse. Beide Beziehungen sind auch umkehrbar.
             
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <AND>
                <EQUI>
                  <AND>
                    <PREDCON ref="subclass">
                      <VAR id="x" />
                      <VAR id="z" />
                    </PREDCON>
                    <PREDCON ref="subclass">
                      <VAR id="y" />
                      <VAR id="z" />
                    </PREDCON>
                  </AND>
                  <PREDCON ref="subclass">
                    <FUNCON ref="union">
                      <VAR id="x" />
                      <VAR id="y" />
                    </FUNCON>
                    <VAR id="z" />
                  </PREDCON>
                </EQUI>

                <EQUI>
                  <AND>
                    <PREDCON ref="subclass">
                      <VAR id="z" />
                      <VAR id="x" />
                    </PREDCON>
                    <PREDCON ref="subclass">
                      <VAR id="z" />
                      <VAR id="y" />
                    </PREDCON>
                  </AND>
                  <PREDCON ref="subclass">
                    <VAR id="z" />
                    <FUNCON ref="intersection">
                      <VAR id="x" />
                      <VAR id="y" />
                    </FUNCON>
                  </PREDCON>
                </EQUI>              
              </AND>
            </FORMULA>
          </THEOREM>
        </NODE>

        <NODE id="theorem:subsetAddition" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                
                Intersection and union of a class does not change an existing subclass relation.

              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Bei Schnitt oder Vereinigung bleibt eine Teilklassenbeziehung erhalten.
             
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <AND>
                <IMPL>
                  <PREDCON ref="subclass">
                    <VAR id="x" />
                    <VAR id="y" />
                  </PREDCON>
                  <PREDCON ref="subclass">
                    <FUNCON ref="union">
                      <VAR id="x" />
                      <VAR id="z" />
                    </FUNCON>
                    <FUNCON ref="union">
                      <VAR id="y" />
                      <VAR id="z" />
                    </FUNCON>
                  </PREDCON>
                </IMPL>
                
                <IMPL>
                  <PREDCON ref="subclass">
                    <VAR id="x" />
                    <VAR id="y" />
                  </PREDCON>
                  <PREDCON ref="subclass">
                    <FUNCON ref="intersection">
                      <VAR id="x" />
                      <VAR id="z" />
                    </FUNCON>
                    <FUNCON ref="intersection">
                      <VAR id="y" />
                      <VAR id="z" />
                    </FUNCON>
                  </PREDCON>
                </IMPL>
              </AND>
            </FORMULA>
          </THEOREM>
        </NODE>

        <NODE id="theorem:subsetComplement" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                Complement building inverts the subclass relation.
             
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Bei der Bildung des Komplements kehrt sich die Teilklassenbeziehung um.
             
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <EQUI>
                <PREDCON ref="subclass">
                  <VAR id="x" />
                  <VAR id="y" />
                </PREDCON>
                <PREDCON ref="subclass">
                  <FUNCON ref="complement">
                    <VAR id="y" />
                  </FUNCON>
                  <FUNCON ref="complement">
                    <VAR id="x" />
                  </FUNCON>
                </PREDCON>
              </EQUI>
            </FORMULA>
          </THEOREM>
        </NODE>

        <NODE id="theorem:subsetComplementEquations" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                For the complement and subclass relation the following equivalences hold.
             
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Für das Komplement und die Teilklassenbeziehung gelten die folgenden Äquivalenzen.
             
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <AND>
              
                <EQUI>
                  <PREDCON ref="subclass">
                    <VAR id="x" />
                    <VAR id="y" />
                  </PREDCON>
                  <PREDCON ref="l.equal">
                    <FUNCON ref="intersection">
                      <VAR id="x" />
                      <FUNCON ref="complement">
                        <VAR id="y" />
                      </FUNCON>
                    </FUNCON>
                    <FUNCON ref="emptySet" />
                  </PREDCON>
                </EQUI>

                <EQUI>
                  <PREDCON ref="subclass">
                    <VAR id="x" />
                    <VAR id="y" />
                  </PREDCON>
                  <PREDCON ref="l.equal">
                    <FUNCON ref="union">
                      <FUNCON ref="complement">
                        <VAR id="x" />
                      </FUNCON>
                      <VAR id="y" />
                    </FUNCON>
                    <FUNCON ref="universalClass" />
                  </PREDCON>
                </EQUI>

                <EQUI>
                  <PREDCON ref="subclass">
                    <VAR id="x" />
                    <FUNCON ref="complement">
                      <VAR id="y" />
                    </FUNCON>
                  </PREDCON>
                  <PREDCON ref="l.equal">
                    <FUNCON ref="intersection">
                      <VAR id="x" />
                      <VAR id="y" />
                    </FUNCON>
                    <FUNCON ref="emptySet" />
                  </PREDCON>
                </EQUI>

                <EQUI>
                  <PREDCON ref="subclass">
                    <FUNCON ref="intersection">
                      <VAR id="x" />
                      <VAR id="y" />
                    </FUNCON>
                    <VAR id="z" />
                  </PREDCON>
                  <PREDCON ref="subclass">
                    <VAR id="x" />
                    <FUNCON ref="union">
                      <FUNCON ref="complement">
                        <VAR id="y" />
                      </FUNCON>
                      <VAR id="z" />
                    </FUNCON>
                  </PREDCON>
                </EQUI>              
              
              </AND>
            </FORMULA>
          </THEOREM>
        </NODE>
        
      </SUBSECTIONS>
 
    </SECTION>

    <SECTION>
      <TITLE>
        <LATEX language="en">
           Singletons and Class Pairs
        </LATEX>
        <LATEX language="de">
           Einerklassen und Klassenpaare
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            
            A class can be defined by explicitly listing its members. 

          ]]>
        </LATEX>
        <LATEX language="de">
          <![CDATA[
            
            Eine Klasse kann auch durch explizite Auflistung ihrer Elemente definiert werden.

          ]]>
        </LATEX>
      </INTRODUCTION>
      <SUBSECTIONS>
      
        <NODE id="definition:singleton">
          <NAME>
            <LATEX language="en">singleton</LATEX>
            <LATEX language="de">Einerklasse</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Singleton\index{singleton}</LATEX>
            <LATEX language="de">Einerklasse\index{Einerklasse}\index{Klasse!Einer-}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                Especially by saying that one element is inside the class we can define the so called \emph{singleton}.
                With \qref{theorem:comprehension} again we can extend the syntax and provide a new abbreviation.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Insbesondere kann durch Angabe eines Elements die sogenannte \emph{Einerklasse} 
              festgelegt werden.
                Wiederum mit \qref{rule:classDefinition} können wir die Sprachsyntax erweitern und eine neue abkürzende Schreibweise einführen.
              ]]>
            </LATEX>
          </PRECEDING>
          <DEFINITION_FUNCTION arguments="1" name="classList">
            <LATEXPATTERN>\{ #1 \}</LATEXPATTERN>
            <FORMULA>
              <PREDCON ref="l.equal">
                <FUNCON ref="classList">
                  <VAR id="x" />
                </FUNCON>
                <CLASS>
                  <VAR id="y"/>
                  <IMPL>
                    <PREDCON ref="isSet">
                      <VAR id="x"/>
                    </PREDCON>
                    <PREDCON ref="l.equal">
                      <VAR id="y"/>
                      <VAR id="x"/>
                    </PREDCON>
                  </IMPL>
                </CLASS>
              </PREDCON>
            </FORMULA>
          </DEFINITION_FUNCTION>
          <SUCCEEDING>
            <LATEX language="en">
              <![CDATA[
                If $x$ is a proper class the term $\{x\}$ is also defined. In this case all sets
                $y$ fulfill the condition 
                $\mathfrak{M}(y) \land (\mathfrak{M}(x) \rightarrow y = x)$ and the singleton is
                identical with the universal class. This leads to a smother handling of the
                singleton.\footnote{Other authors as K.~Gödel for example define 
                $\{x\} = \{y~|~y = x\}$.} 
                
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
              
                Da der Ausdruck $\{x\}$ für jegliches $x$ definiert ist, kann er auch für den Fall, 
                dass $x$ eine echte Klasse ist, gebildet werden. In diesem Fall erfüllen alle Mengen 
                $y$ die Bedingung 
                $\mathfrak{M}(y) \land (\mathfrak{M}(x) \rightarrow y = x)$ und die Einerklasse ist 
                mit der Allklasse identisch. Das führt zu einem technisch einfacheren Umgang mit der
                Einerklasse.\footnote{Andere Autoren wie z.~B. auch K.~Gödel, definieren $\{x\}$ durch
                $\{y~|~y = x\}$.}
                
              ]]>
            </LATEX>
          </SUCCEEDING>
        </NODE>
      
        <NODE id="theorem:setSingletonHasSetAsOnlyElement" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                For sets the singleton has only the set itself as a member.
             
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Für Mengen enthält die Einerklasse wie gewünscht nur die Menge selbst.
             
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <IMPL>
                <PREDCON ref="isSet">
                  <VAR id="x" />
                </PREDCON>
                <FORALL>
                  <VAR id="z" />
                  <EQUI>
                    <PREDCON ref="in">
                      <VAR id="z" />
                      <FUNCON ref="classList">
                        <VAR id="x" />
                      </FUNCON>
                    </PREDCON>
                    <PREDCON ref="l.equal">
                      <VAR id="z" />
                      <VAR id="x" />
                    </PREDCON>
                  </EQUI>
                </FORALL>
              </IMPL>
            </FORMULA>
          </THEOREM>
        </NODE>

        <NODE id="theorem:properSingletonIsUniversalClass" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                If we have a proper class the singleton is the universal class.
             
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Für echte Mengen ist die Einerklasse mit der Allklasse identisch.
             
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <IMPL>
                <NOT>
                  <PREDCON ref="isSet">
                    <VAR id="x" />
                  </PREDCON>
                </NOT>
                <PREDCON ref="l.equal">
                  <FUNCON ref="classList">
                    <VAR id="x" />
                  </FUNCON>
                  <FUNCON ref="universalClass" />
                </PREDCON>
              </IMPL>
            </FORMULA>
          </THEOREM>
        </NODE>

        <NODE id="theorem:setSingletonEqualHasItselfAsElement" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                Beeing a set singleton is equivalent to be member of its singleton. 
             
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Einerklasse einer Menge zu sein ist äquivalent dazu Element seiner
                Einerklasse zu sein.
             
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <EQUI>
                <PREDCON ref="isSet">
                  <VAR id="x" />
                </PREDCON>
                <PREDCON ref="in">
                  <VAR id="x" />
                  <FUNCON ref="classList">
                    <VAR id="x" />
                  </FUNCON>
                </PREDCON>
              </EQUI>
            </FORMULA>
          </THEOREM>
        </NODE>

        <NODE id="definition:pair">
          <NAME>
            <LATEX language="en">pair</LATEX>
            <LATEX language="de">Paar</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Pair\index{pair}</LATEX>
            <LATEX language="de">Paar\index{Paar}\index{Klasse!Paar-}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                Now we can simply define the \emph{pair} class as union of two singletons.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Nun kann einfach durch Vereinigung zweier Einerklassen das \emph{Paar}
                zweier Klassen definiert werden.
              ]]>
            </LATEX>
          </PRECEDING>
          <DEFINITION_FUNCTION arguments="2" name="classList">
            <LATEXPATTERN>\{ #1, #2 \}</LATEXPATTERN>
            <FORMULA>
              <PREDCON ref="l.equal">
                <FUNCON ref="classList">
                  <VAR id="x" />
                  <VAR id="y" />
                </FUNCON>
                <FUNCON ref="union">
                  <FUNCON ref="classList">
                    <VAR id="x"/>
                  </FUNCON>
                  <FUNCON ref="classList">
                    <VAR id="y"/>
                  </FUNCON>
                </FUNCON>
              </PREDCON>
            </FORMULA>
          </DEFINITION_FUNCTION>
        </NODE>
      
        <NODE id="theorem:classPairIsEqual" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                A class pair can be described directly without referencing singletons.
             
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Ein Klassenpaar kann auch direkt, d.~h. ohne Zuhilfenahme der Einerklassen
                beschrieben werden.
             
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <PREDCON ref="l.equal">
                <FUNCON ref="classList">
                  <VAR id="x" />
                  <VAR id="y" />
                </FUNCON>
                <CLASS>
                  <VAR id="z" />
                  <IMPL>
                    <AND>
                      <PREDCON ref="isSet">
                        <VAR id="x" />
                      </PREDCON>
                      <PREDCON ref="isSet">
                        <VAR id="y" />
                      </PREDCON>
                    </AND>
                    <OR>
                      <PREDCON ref="l.equal">
                        <VAR id="z" />
                        <VAR id="x" />
                      </PREDCON>
                      <PREDCON ref="l.equal">
                        <VAR id="z" />
                        <VAR id="y" />
                      </PREDCON>
                    </OR>
                  </IMPL>
                </CLASS>
              </PREDCON>
            </FORMULA>
          </THEOREM>
        </NODE>

        <NODE id="theorem:membershipOfClassPair" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                For set pairs beeing a member of a pair can canonically be simplified.
             
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Für Klassenpaare, die aus Mengen gebildet werden, kann die Eigenschaft, Element des Klassenpaares zu sein, einfacher ausgedrückt werden.
             
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <IMPL>
                <AND>
                  <PREDCON ref="isSet">
                    <VAR id="x" />
                  </PREDCON>
                  <PREDCON ref="isSet">
                    <VAR id="y" />
                  </PREDCON>
                </AND>
                <FORALL>
                  <VAR id="z" />
                  <EQUI>
                    <PREDCON ref="in">
                      <VAR id="z" />
                      <FUNCON ref="classList">
                        <VAR id="x" />
                        <VAR id="y" />
                      </FUNCON>
                    </PREDCON>
                    <OR>
                      <PREDCON ref="l.equal">
                        <VAR id="z" />
                        <VAR id="x" />
                      </PREDCON>
                      <PREDCON ref="l.equal">
                        <VAR id="z" />
                        <VAR id="y" />
                      </PREDCON>
                    </OR>
                  </EQUI>
                </FORALL>
              </IMPL>
            </FORMULA>
          </THEOREM>
        </NODE>

        <NODE id="theorem:properClassPairIsUniversalClass" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                If one of the classes for building a class pair is proper the resulting pair
                is identical to the universal set.
             
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Falls bei der Klassenpaarbildung eine echte Klasse dabei ist, dann ist das
                resultierende Klassenpaar mit der Allklasse identisch.
             
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <IMPL>
                <OR>
                  <NOT>
                    <PREDCON ref="isSet">
                      <VAR id="x" />
                    </PREDCON>
                  </NOT>
                  <NOT>
                    <PREDCON ref="isSet">
                      <VAR id="y" />
                    </PREDCON>
                  </NOT>
                </OR>
                <PREDCON ref="l.equal">
                  <FUNCON ref="classList">
                    <VAR id="x" />
                    <VAR id="y" />
                  </FUNCON>
                  <FUNCON ref="universalClass" />
                </PREDCON>
              </IMPL>
            </FORMULA>
          </THEOREM>
        </NODE>

        <NODE id="theorem:classPairBuildingIsCommutative" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                We note that building a class pair is commutative.
             
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Wir notieren, dass die Klassenpaarbildung kommutativ ist.
             
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <PREDCON ref="l.equal">
                <FUNCON ref="classList">
                  <VAR id="x" />
                  <VAR id="y" />
                </FUNCON>
                <FUNCON ref="classList">
                  <VAR id="y" />
                  <VAR id="x" />
                </FUNCON>
              </PREDCON>
            </FORMULA>
          </THEOREM>
        </NODE>

        <NODE id="theorem:singletonIsClassPair" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                The singleton can be expressed as a special case of a class pair.
             
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Die Einerklasse ist ein Spezialfall des Klassenpaares.
             
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <PREDCON ref="l.equal">
                <FUNCON ref="classList">
                  <VAR id="x" />
                </FUNCON>
                <FUNCON ref="classList">
                  <VAR id="x" />
                  <VAR id="x" />
                </FUNCON>
              </PREDCON>
            </FORMULA>
          </THEOREM>
        </NODE>

        <NODE id="theorem:setEquiInClassPair" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                Being a set is equivalent to being element of a class pair.
             
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Menge zu sein ist äquivalent dazu, Element eines Klassenpaares zu sein.
             
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <EQUI>
                <PREDCON ref="isSet">
                  <VAR id="x" />
                </PREDCON>
                <PREDCON ref="in">
                  <VAR id="x" />
                  <FUNCON ref="classList">
                    <VAR id="x" />
                    <VAR id="y" />
                  </FUNCON>
                </PREDCON>
              </EQUI>
            </FORMULA>
          </THEOREM>
        </NODE>

        <NODE id="theorem:elementEquiSingletonSubclass" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                For sets being an element is equal to being a subclass of its singleton.
             
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Für Mengen ist die Elementbeziehung äquivalent zur Teilklassenbeziehung
                für die zugehörige Einerklasse.
             
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <IMPL>
                <PREDCON ref="isSet">
                  <VAR id="x" />
                </PREDCON>
                <EQUI>
                  <PREDCON ref="in">
                    <VAR id="x" />
                    <VAR id="y" />
                  </PREDCON>
                  <PREDCON ref="subclass">
                    <FUNCON ref="classList">
                      <VAR id="x" />
                    </FUNCON>
                    <VAR id="y" />
                  </PREDCON>
                </EQUI>
              </IMPL>
            </FORMULA>
          </THEOREM>
        </NODE>

        <NODE id="theorem:pairIdentities" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                Identity of set pairs behaves as expected.
             
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Die Gleichheit von aus Mengen gebildeten Klassenpaaren ist wie erwartet.
             
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <IMPL>
                <AND>
                  <PREDCON ref="isSet">
                    <VAR id="x" />
                  </PREDCON>
                  <PREDCON ref="isSet">
                    <VAR id="y" />
                  </PREDCON>
                  <PREDCON ref="isSet">
                    <VAR id="u" />
                  </PREDCON>
                  <PREDCON ref="isSet">
                    <VAR id="v" />
                  </PREDCON>
                </AND>
                <IMPL>
                  <PREDCON ref="l.equal">
                    <FUNCON ref="classList">
                      <VAR id="x" />
                      <VAR id="y" />
                    </FUNCON>
                    <FUNCON ref="classList">
                      <VAR id="u" />
                      <VAR id="v" />
                    </FUNCON>
                  </PREDCON>
                  <OR>
                    <AND>
                      <PREDCON ref="l.equal">
                        <VAR id="x" />
                        <VAR id="u" />
                      </PREDCON>
                      <PREDCON ref="l.equal">
                        <VAR id="y" />
                        <VAR id="v" />
                      </PREDCON>
                    </AND>
                    <AND>
                      <PREDCON ref="l.equal">
                        <VAR id="x" />
                        <VAR id="v" />
                      </PREDCON>
                      <PREDCON ref="l.equal">
                        <VAR id="y" />
                        <VAR id="u" />
                      </PREDCON>
                    </AND>
                  </OR>
                </IMPL>
              </IMPL>
            </FORMULA>
          </THEOREM>
        </NODE>

      </SUBSECTIONS>
    </SECTION>
              
    <SECTION>
      <TITLE>
        <LATEX language="en">
          Infinite Boolean Operators
        </LATEX>
        <LATEX language="de">
          Unendliche Boolsche Operatoren
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[

            It is also possible to build infinite intersections and unions. It must only be declared which classes
            are used to build the result.

          ]]>
        </LATEX>
        <LATEX language="de">
          <![CDATA[

            Es können auch beliebige Schnittklassen und Vereinigungsklassen gebildet werden. Dazu muss nur
            festgelegt werden, über welche Klassen jeweils geschnitten bzw. vereinigt wird.

          ]]>
        </LATEX>
      </INTRODUCTION>
      <SUBSECTIONS>

        <NODE id="setProduct">
          <NAME>
            <LATEX language="en">set product</LATEX>
            <LATEX language="de">Mengenprodukt</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Set Product\index{set product}\index{product!of sets}</LATEX>
            <LATEX language="de">Mengenprodukt\index{Mengenprodukt}\index{Produkt!von Mengen}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                 For a class of sets a \emph{product} is defined: all sets that are elements of each set
                 are member of the product.

              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                 Für eine Klasse von Mengen wird ein \emph{Produkt} so definiert, dass genau die Elemente, 
                 die in allen Mengen enthalten sind, in dem Produkt liegen.

              ]]>
            </LATEX>
          </PRECEDING>
          <DEFINITION_FUNCTION arguments="1" name="setProduct">
            <LATEXPATTERN>\bigcap \ #1</LATEXPATTERN>
            <FORMULA>
              <PREDCON ref="l.equal">
                <FUNCON ref="setProduct">
                  <VAR id="x" />
                </FUNCON>
                <CLASS>
                  <VAR id="z" />
                  <FORALL>
                    <VAR id="y" />
                    <IMPL>
                      <PREDCON ref="in">
                        <VAR id="y" />
                        <VAR id="x" />
                      </PREDCON>
                      <PREDCON ref="in">
                        <VAR id="z" />
                        <VAR id="y" />
                      </PREDCON>
                    </IMPL>
                  </FORALL>
                </CLASS>
              </PREDCON>
            </FORMULA>
          </DEFINITION_FUNCTION>
          <SUCCEEDING>
            <LATEX language="en">
              <![CDATA[

                This function can be viewed as a generalization of the intersection operation.
                See also \qref{theorem:setPairSetSumProduct}.

                \par
                We also say the class $x$ defines a \emph{family of sets}\index{family!of sets}\index{set!family}. 
                Any element of $x$ is a member of the family.

              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
              
                Diese Funktion kann als Verallgemeinerung der Schnittklassenbildung angesehen werden.
                Siehe auch \qref{theorem:setPairSetSumProduct}.
                
                \par
                Wir sagen auch, dass die Klasse $x$ eine \emph{Mengenfamilie}\index{Familie}\index{Mengenfamilie}
                festlegt. Jedes Element von $x$ ist ein Mitglied der Familie.

              ]]>
            </LATEX>
          </SUCCEEDING>
        </NODE>
        
        <NODE id="theorem:setProductMembership" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                As usual we can describe the membership of the set product as follows.
             
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Wie üblich können wir die Elementbeziehung zum Mengenprodukt wie folgt beschreiben.
             
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <EQUI>
                <PREDCON ref="in">
                  <VAR id="z" />
                  <FUNCON ref="setProduct">
                    <VAR id="x" />
                  </FUNCON>
                </PREDCON>
                <AND>
                  <PREDCON ref="isSet">
                    <VAR id="z" />
                  </PREDCON>
                  <FORALL>
                    <VAR id="y" />
                    <IMPL>
                      <PREDCON ref="in">
                        <VAR id="y" />
                        <VAR id="x" />
                      </PREDCON>
                      <PREDCON ref="in">
                        <VAR id="z" />
                        <VAR id="y" />
                      </PREDCON>
                    </IMPL>
                  </FORALL>
                </AND>
              </EQUI>
            </FORMULA>
          </THEOREM>
        </NODE>

        <NODE id="theorem:emptySetProduct" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                We find for the special case of $x\,=\,\emptyset$.
             
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Für den Speziallfall $x\,=\,\emptyset$ erhalten wir.
             
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
                <PREDCON ref="l.equal">
                  <FUNCON ref="setProduct">
                    <FUNCON ref="emptySet" />
                  </FUNCON>
                <FUNCON ref="universalClass" />
              </PREDCON>
            </FORMULA>
          </THEOREM>
        </NODE>

        <NODE id="theorem:nonEmptySetProductMembership" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                If we build the set product of a non empty class we can
                drop the set condition.
             
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Falls wir das Mengenprodukt einer nichtleeren Klasse bilden,
                können wir die Mengenbedingung weglassen.
             
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <IMPL>
                <PREDCON ref="l.notEqual">
                  <VAR id="x" />
                  <FUNCON ref="emptySet"/>
                </PREDCON>
                <EQUI>
                  <PREDCON ref="in">
                    <VAR id="z" />
                    <FUNCON ref="setProduct">
                      <VAR id="x" />
                    </FUNCON>
                  </PREDCON>
                  <FORALL>
                    <VAR id="y" />
                    <IMPL>
                      <PREDCON ref="in">
                        <VAR id="y" />
                        <VAR id="x" />
                      </PREDCON>
                      <PREDCON ref="in">
                        <VAR id="z" />
                        <VAR id="y" />
                      </PREDCON>
                    </IMPL>
                  </FORALL>
                </EQUI>
              </IMPL>
            </FORMULA>
          </THEOREM>
        </NODE>

        <NODE id="definition:setSum">
          <NAME>
            <LATEX language="en">set sum</LATEX>
            <LATEX language="de">Mengensumme</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Set Sum\index{set sum}\index{sum!of sets}</LATEX>
            <LATEX language="de">Mengensumme\index{Mengensumme}\index{Summe!von Mengen}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                Analogous we  can define the \emph{set sum}.
                Exactly the elements, that are member of some set in the family, should be member of the set sum.
              
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

               Analog können wir die \emph{Mengensumme} definieren.
               Genau die Elemente, die in irgend einer der Mengen vorkommen, sollen in der Summe liegen.
              
              ]]>
            </LATEX>
          </PRECEDING>
          <DEFINITION_FUNCTION arguments="1" name="setSum">
            <LATEXPATTERN>\bigcup \ #1</LATEXPATTERN>
            <FORMULA>
              <PREDCON ref="l.equal">
                <FUNCON ref="setSum">
                  <VAR id="x" />
                </FUNCON>
                <CLASS>
                  <VAR id="z" />
                  <EXISTS>
                    <VAR id="y" />
                    <AND>
                      <PREDCON ref="in">
                        <VAR id="y" />
                        <VAR id="x" />
                      </PREDCON>
                      <PREDCON ref="in">
                        <VAR id="z" />
                        <VAR id="y" />
                      </PREDCON>
                    </AND>
                  </EXISTS>
                </CLASS>
              </PREDCON>
            </FORMULA>
          </DEFINITION_FUNCTION>
        </NODE>

        <NODE id="theorem:setSumMembership" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                The set sum membership can be expressed by the following formula.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Die Zugehörigkeit zur Mengensumme kann wie folgt ausgedrückt werden.
                
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <EQUI>
                <PREDCON ref="in">
                  <VAR id="z" />
                  <FUNCON ref="setSum" >
                    <VAR id="x" />
                  </FUNCON>
                </PREDCON>
                <EXISTS>
                  <VAR id="y" />
                  <AND>
                    <PREDCON ref="in">
                      <VAR id="y" />
                      <VAR id="x" />
                    </PREDCON>
                    <PREDCON ref="in">
                      <VAR id="z" />
                      <VAR id="y" />
                    </PREDCON>
                  </AND>
                </EXISTS>
              </EQUI>
            </FORMULA>
          </THEOREM>
          <SUCCEEDING>
            <LATEX language="en">
              <![CDATA[

                Here we can drop the set condition $\mathfrak{M}(z)$.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Hier können wir die Mengenbedingung $\mathfrak{M}(z)$ weglassen.
                
              ]]>
            </LATEX>
          </SUCCEEDING>
        </NODE>

        <NODE id="theorem:emptySetSum" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                For the empty class we obtain.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Für die leere Klasse erhalten wir.
                
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <PREDCON ref="l.equal">
                <FUNCON ref="setSum" >
                  <FUNCON ref="emptySet" />
                </FUNCON>
                <FUNCON ref="emptySet" />
              </PREDCON>
            </FORMULA>
          </THEOREM>
        </NODE>

        <NODE id="theorem:subsetSumProductImplication" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                The subclass relation behaves to the set product and sum as follows.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Die Teilklassenrelation verhält sich zu Mengenprodukt und Mengensumme wie folgt.
                
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <AND>
                <IMPL>
                  <PREDCON ref="subclass">
                    <VAR id="x" />
                    <VAR id="y" />
                  </PREDCON>
                  <PREDCON ref="subclass">
                    <FUNCON ref="setProduct">
                      <VAR id="y" />
                    </FUNCON>
                    <FUNCON ref="setProduct">
                      <VAR id="x" />
                    </FUNCON>
                  </PREDCON>
                </IMPL>
                <IMPL>
                  <PREDCON ref="subclass">
                    <VAR id="x" />
                    <VAR id="y" />
                  </PREDCON>
                  <PREDCON ref="subclass">
                    <FUNCON ref="setSum">
                      <VAR id="x" />
                    </FUNCON>
                    <FUNCON ref="setSum">
                      <VAR id="y" />
                    </FUNCON>
                  </PREDCON>
                </IMPL>
              </AND>
            </FORMULA>
          </THEOREM>
        </NODE>

        <NODE id="theorem:membershipToSetProductAndSum" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                The membership relation induces subclass relations in the following way.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Die Elementbeziehung induziert Teilklassenbeziehungen in der folgenden Weise.
                
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <AND>
                <IMPL>
                  <PREDCON ref="in">
                    <VAR id="x" />
                    <VAR id="y" />
                  </PREDCON>
                  <PREDCON ref="subclass">
                    <VAR id="x" />
                    <FUNCON ref="setSum">
                      <VAR id="y" />
                    </FUNCON>
                  </PREDCON>
                </IMPL>
                <IMPL>
                  <PREDCON ref="in">
                    <VAR id="x" />
                    <VAR id="y" />
                  </PREDCON>
                  <PREDCON ref="subclass">
                    <FUNCON ref="setProduct">
                      <VAR id="y" />
                    </FUNCON>
                    <VAR id="x" />
                  </PREDCON>
                </IMPL>
              </AND>
            </FORMULA>
          </THEOREM>
        </NODE>

        <NODE id="theorem:unionIntersectionSetSumProduct" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                The union and intersection operation match with the set sum and set product
                as follows.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Die Vereinigungs- und Schnittklassenbildung passt zu Mengensumme und
                Mengenprodukt wie nachfolgend beschrieben.
                
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <AND>
                <PREDCON ref="l.equal">
                  <FUNCON ref="setProduct">
                    <FUNCON ref="union">
                      <VAR id="x" />
                      <VAR id="y" />
                    </FUNCON>
                  </FUNCON>
                  <FUNCON ref="intersection">
                    <FUNCON ref="setProduct">
                      <VAR id="x" />
                    </FUNCON>
                    <FUNCON ref="setProduct">
                      <VAR id="y" />
                    </FUNCON>
                  </FUNCON>
                </PREDCON>
                <PREDCON ref="l.equal">
                  <FUNCON ref="setSum">
                    <FUNCON ref="union">
                      <VAR id="x" />
                      <VAR id="y" />
                    </FUNCON>
                  </FUNCON>
                  <FUNCON ref="union">
                    <FUNCON ref="setSum">
                      <VAR id="x" />
                    </FUNCON>
                    <FUNCON ref="setSum">
                      <VAR id="y" />
                    </FUNCON>
                  </FUNCON>
                </PREDCON>
                <PREDCON ref="subclass">
                  <FUNCON ref="setSum">
                    <FUNCON ref="intersection">
                      <VAR id="x" />
                      <VAR id="y" />
                    </FUNCON>
                  </FUNCON>
                  <FUNCON ref="intersection">
                    <FUNCON ref="setSum">
                      <VAR id="x" />
                    </FUNCON>
                    <FUNCON ref="setSum">
                      <VAR id="y" />
                    </FUNCON>
                  </FUNCON>
                </PREDCON>
              </AND>
            </FORMULA>
          </THEOREM>
        </NODE>

        <NODE id="theorem:nonEmptySumProductSubSet" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                In case of a non empty set family we have this.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Für den Fall einer nichtleeren Mengenfamilie haben wir dieses Ergebnis.
                
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <FORALL>
                <VAR id="x" />
                <IMPL>
                  <PREDCON ref="l.notEqual">
                    <VAR id="x" />
                    <FUNCON ref="emptySet" />
                  </PREDCON>
                  <PREDCON ref="subclass">
                    <FUNCON ref="setProduct">
                      <VAR id="x" />
                    </FUNCON>
                    <FUNCON ref="setSum">
                      <VAR id="x" />
                    </FUNCON>
                  </PREDCON>
                </IMPL>
              </FORALL>
            </FORMULA>
          </THEOREM>
        </NODE>
              
        <NODE id="theorem:setPairSetSumProduct" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                For set pairs we get the expected results.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Für Mengenpaare erhalten wir die erwarteten Ergebnisse.
                
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <AND>
                <IMPL>
                  <AND>
                    <PREDCON ref="isSet">
                      <VAR id="x" />
                    </PREDCON>
                    <PREDCON ref="isSet">
                      <VAR id="y" />
                    </PREDCON>
                  </AND>
                  <PREDCON ref="l.equal">
                    <FUNCON ref="setProduct">
                      <FUNCON ref="classList">
                        <VAR id="x" />
                        <VAR id="y" />
                      </FUNCON>
                    </FUNCON>
                    <FUNCON ref="intersection">
                      <VAR id="x" />
                      <VAR id="y" />
                    </FUNCON>
                  </PREDCON>
                </IMPL>
                <IMPL>
                  <AND>
                    <PREDCON ref="isSet">
                      <VAR id="x" />
                    </PREDCON>
                    <PREDCON ref="isSet">
                      <VAR id="y" />
                    </PREDCON>
                  </AND>
                  <PREDCON ref="l.equal">
                    <FUNCON ref="setSum">
                      <FUNCON ref="classList">
                        <VAR id="x" />
                        <VAR id="y" />
                      </FUNCON>
                    </FUNCON>
                    <FUNCON ref="union">
                      <VAR id="x" />
                      <VAR id="y" />
                    </FUNCON>
                  </PREDCON>
                </IMPL>
              </AND>
            </FORMULA>
          </THEOREM>
        </NODE>
              
        <NODE id="theorem:singletonSetSumProduct" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                For set singletons we get analogous statements.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Für Einermengen erhalten wir analoge Aussagen.
                
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <AND>
                <IMPL>
                  <PREDCON ref="isSet">
                    <VAR id="x" />
                  </PREDCON>
                  <PREDCON ref="l.equal">
                    <FUNCON ref="setProduct">
                      <FUNCON ref="classList">
                        <VAR id="x" />
                      </FUNCON>
                    </FUNCON>
                    <VAR id="x" />
                  </PREDCON>
                </IMPL>
                <IMPL>
                  <PREDCON ref="isSet">
                    <VAR id="x" />
                  </PREDCON>
                  <PREDCON ref="l.equal">
                    <FUNCON ref="setSum">
                      <FUNCON ref="classList">
                        <VAR id="x" />
                      </FUNCON>
                    </FUNCON>
                    <VAR id="x" />
                  </PREDCON>
                </IMPL>
              </AND>
            </FORMULA>
          </THEOREM>
        </NODE>
              
      </SUBSECTIONS>
    </SECTION>

<!-- TODO decide if this section should be included 

    <SECTION>
      <TITLE>
        <LATEX language="de">
           Unendliche Boolsche Operatoren - Teil 2
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="de">
          <![CDATA[

            +++
            Es ist noch unklar, ob dieser Abschnitt drin bleibt. Für Indexmengen wird was ähnliches benötigt, 
            aber das könnte auch anders gemacht werden.

          ]]>
        </LATEX>
      </INTRODUCTION>
      <SUBSECTIONS>



        <NODE id="rule:quantorIntersection">
          <NAME>
            <LATEX language="en">quantor intersection</LATEX>
            <LATEX language="de">allgemeiner Durchschnitt von</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Quantor Intersection</LATEX>
            <LATEX language="de">Allgemeiner Durchschnitt\index{Durchschnitt!allgemeiner}\index{Schnitt!unendlicher}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                Starting with \qref{rule:classDefinition} we can extend the syntax and provide a new abbreviation.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Ausgehend von \qref{rule:classDefinition} können wir die Sprachsyntax erweitern und eine neue abkürzende Schreibweise einführen.
              ]]>
            </LATEX>
          </PRECEDING>
          <RULE name="GENERALIZED_QUANTIFIER" version="1.00.00">
            <LINK id="rule:classDefinition"/>
            <DESCRIPTION>
              <LATEX language="en">
                <![CDATA[
                  Each set which is member of all classes of a certain property is also member of the generalized quantifier.
                  For every formula $\alpha(x)$ we define the term expression $\bigcap_{\alpha(x)} x$ by
                  $$
                    \bigcap_{\alpha(x)} x \ := \ \{y~|~\forall \alpha(x) \ (y \in x)\}
                  $$
                  
                  \par
                  The free variables from $\bigcap_{\alpha(x)} x$ are the free variables from $\alpha(x)$ without $\{ x \}$. The bound variables correspond to the bound variables of $\alpha(x)$. All deduction rules are accordingly extended.
                  
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  Alle Mengen, welche Element aller Klassen mit einer bestimmten Eigenschaft sind, bilden die Elemente des allgemeinen Durchschnitts.
                  Für jede Formel $\alpha(x)$ definieren wir den Termausdruck $\bigcap_{\alpha(x)} x$ durch
                  $$
                    \bigcap_{\alpha(x)} x \ := \ \{y~|~\forall \alpha(x) \ (y \in x)\}
                  $$
                  
                  \par
                  Die freien Variablen von $\bigcap_{\alpha(x)} x$  sind die freien Variablen von $\alpha(x)$ vermindert um $\{ x \}$. Die gebunden Variablen entsprechen den gebunden Variablen von $\alpha(x)$. Alle Ableitungsregeln werden entsprechend erweitert.
                
                ]]>
              </LATEX>
            </DESCRIPTION>
          </RULE>
        </NODE>
        
      
        <SUBSECTION>
          <TEXT>
            <LATEX language="de">
              <![CDATA[


    \begin{defn}[Allgemeiner Durchschnitt]\index{Durchschnitt!allgemeiner}\index{Schnitt!unendlicher}
    $$ \bigcap_{\phi(x)} x \ := \ \{y~|~\forall \phi(x) \ (y \in x)\}$$
    \end{defn}

    \begin{defn}[Allgemeine Vereinigung]\index{Vereinigung!allgemeine}\index{Vereinigung!unendliche}
    $$ \bigcup_{\phi(x)} x \ := \ \{y~|~\exists \phi(x) \ (y \in x) \}$$
    \end{defn}

    In Analogie zu \qref{inSetEqual} gilt nun:
    \begin{thm}
    \begin{eqnarray}
    y \in \bigcap_{\phi(x)} x & \leftrightarrow & \mathfrak{M}(y) \land \forall \phi(x) \ (y \in x) \label{inUnionEqual}\\
    y \in \bigcup_{\phi(x)} x & \leftrightarrow & \exists \phi(x) \ (y \in x) \label{inIntersectionEqual}
    \end{eqnarray}
    \end{thm}
    Die Einschränkung auf Mengen in (\qref{inUnionEqual}) ist notwendig, da sonst bei einem nicht
    erfüllbaren $\phi$ auch alle Klassen $y$, die keine Mengen sind, die rechte Seite der Äquivalenz
    erfüllen würden.
    \par
    \begin{thm}
    \begin{equation}
    \phi(x) \rightarrow x \subseteq \bigcup_{\phi(y)} y
    \end{equation}
    \end{thm}
    \begin{thm}
    \begin{equation}
    \forall \phi(x) \ (x \subseteq z) \leftrightarrow \bigcup_{\phi(y)} y \subseteq z
    \end{equation}
    \end{thm}
    \begin{thm}
    \begin{equation}
    \forall \phi(x) \ (\bigcap_{\phi(y)} y \subseteq x)
    \end{equation}
    \end{thm}
    \begin{thm}
    \begin{equation}
    \forall \phi(x) \ (z \subseteq x) \leftrightarrow z \subseteq \bigcap_{\phi(y)} y
    \end{equation}
    \end{thm}
    \begin{thm}
    \begin{eqnarray}
    x \cup y & = & \bigcup_{z = x ~\lor~ z = y} z \\
    x \cap y & = & \bigcap_{z = x ~\land~ z = y} z
    \end{eqnarray}
    \end{thm}
    \begin{thm}
    \begin{eqnarray}
    x & = & \bigcup_{z = x} z \\
    x & = & \bigcap_{z = x} z
    \end{eqnarray}
    \end{thm}

    \begin{thm}
    \begin{eqnarray}
    \forall x \ (\phi(x) \leftrightarrow \psi(x) & \rightarrow & \bigcup_{\phi(x)} x = \bigcup_{\psi(x)} x \\
    \forall x \ (\phi(x) \leftrightarrow \psi(x) & \rightarrow & \bigcap_{\phi(x)} x = \bigcap_{\psi(x)} x
    \end{eqnarray}
    \end{thm}

    \begin{thm}
    \begin{eqnarray}
    \forall x \ (\phi(x) \leftrightarrow x = z) & \rightarrow & z = \bigcap_{\phi(x)} x \\
    \forall x \ (\phi(x) \leftrightarrow x = z) & \rightarrow & z = \bigcup_{\phi(x)} x
    \end{eqnarray}
    \end{thm}

    \begin{thm}
    \begin{eqnarray}
    \forall x \ (\phi(x) \rightarrow \psi(x) & \rightarrow & \bigcup_{\phi(x)} x \subseteq \bigcup_{\psi(x)} x \\
    \forall x \ (\phi(x) \rightarrow \psi(x) & \rightarrow &\bigcap_{\phi(x)} x \subseteq \bigcap_{\psi(x)} x
    \end{eqnarray}
    \end{thm}

    \begin{thm}
    \begin{equation}
    \exists \phi(x) \ (\bigcap_{\phi(x)} x ) \subseteq \bigcup_{\phi(x)} x
    \end{equation}
    \end{thm}

    \begin{thm}
    \begin{eqnarray}
    x & \subseteq & \mathfrak{P}(\bigcup_{z \in x} z) \\
    \bigcup_{z \in \mathfrak{P}(x)} z & \subseteq & x \\
    \forall \, \mathfrak{M}(x) \quad x & = & \bigcup_{z \in \mathfrak{P}(x)} z
    \end{eqnarray}
    \end{thm}

    +++ weitere Rechengesetze, de Morgan etc. \\
    +++ muss eventuell in Relationen und Funktionen noch einmal für Indexmengen ergänzt werden\\
    \par

              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>
      </SUBSECTIONS>
    </SECTION>

-->

    <SECTION>
      <TITLE>
        <LATEX language="en">
          Power Class Building
        </LATEX>
        <LATEX language="de">
          Potenzklassenbildung
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            
            An important operator is still missing.

          ]]>
        </LATEX>
        <LATEX language="de">
          <![CDATA[
            Ein wichtiger Operator fehlt uns noch.

          ]]>
        </LATEX>
      </INTRODUCTION>
      <SUBSECTIONS>

        <NODE id="definition:power">
          <NAME>
            <LATEX language="en">power</LATEX>
            <LATEX language="de">Potenzklasse</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Power Class\index{class!power}</LATEX>
            <LATEX language="de">Potenzklasse\index{Klasse!Potenz-}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
              
                The subset relation helps us to create another class operator: the \emph{power class operation}.

              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                 Aus der Teilklassenrelation lässt sich ein weiterer Klassenoperator gewinnen, die \emph{Potenzklassenbildung}.
              ]]>
            </LATEX>
          </PRECEDING>
          <DEFINITION_FUNCTION arguments="1" name="power">
            <LATEXPATTERN>\mathfrak{P}(#1)</LATEXPATTERN>
            <FORMULA>
              <PREDCON ref="l.equal">
                <FUNCON ref="power">
                  <VAR id="x" />
                </FUNCON>
                <CLASS>
                  <VAR id="z" />
                  <PREDCON ref="subclass">
                    <VAR id="z" />
                    <VAR id="x" />
                  </PREDCON>
                </CLASS>
              </PREDCON>
            </FORMULA>
          </DEFINITION_FUNCTION>
          <SUCCEEDING>
            <LATEX language="en">
              <![CDATA[
                We want to remind you that only sets can be members of the power class.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Wir erinnern noch einmal daran, dass nur Mengen in der Potenzklasse enthalten sein können.
              ]]>
            </LATEX>
          </SUCCEEDING>
        </NODE>

        <NODE id="theorem:powerPropositions" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                For this new operator the following propositions hold.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Für diesen neuen Operator gelten die folgenden Aussagen.
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <AND>

                <EQUI>
                  <PREDCON ref="in">
                    <VAR id="z" />
                    <FUNCON ref="power">
                      <VAR id="x" />
                    </FUNCON>
                  </PREDCON>
                  <AND>
                    <PREDCON ref="isSet">
                      <VAR id="z" />
                    </PREDCON>
                    <PREDCON ref="subclass">
                      <VAR id="z" />
                      <VAR id="x" />
                    </PREDCON>
                  </AND>
                </EQUI>

                <PREDCON ref="l.equal">
                  <FUNCON ref="power">
                    <FUNCON ref="universalClass" />
                  </FUNCON>
                  <FUNCON ref="universalClass" />
                </PREDCON>

                <PREDCON ref="l.equal">
                  <FUNCON ref="power">
                    <FUNCON ref="emptySet" />
                  </FUNCON>
                  <FUNCON ref="classList">
                    <FUNCON ref="emptySet" />
                  </FUNCON>
                </PREDCON>

                <EQUI>
                  <PREDCON ref="isSet">
                    <VAR id="x" />
                  </PREDCON>
                  <PREDCON ref="in">
                    <VAR id="x" />
                    <FUNCON ref="power">
                      <VAR id="x" />
                    </FUNCON>
                  </PREDCON>
                </EQUI>

                <IMPL>
                  <PREDCON ref="subclass">
                    <VAR id="x" />
                    <VAR id="y" />
                  </PREDCON>
                  <PREDCON ref="subclass">
                    <FUNCON ref="power">
                      <VAR id="x" />
                    </FUNCON>
                    <FUNCON ref="power">
                      <VAR id="y" />
                    </FUNCON>
                  </PREDCON>
                </IMPL>

                <IMPL>
                  <AND>
                    <PREDCON ref="isSet">
                      <VAR id="x" />
                    </PREDCON>
                    <PREDCON ref="subclass">
                      <FUNCON ref="power">
                        <VAR id="x" />
                      </FUNCON>
                      <FUNCON ref="power">
                        <VAR id="y" />
                      </FUNCON>
                    </PREDCON>
                  </AND>
                  <PREDCON ref="subclass">
                    <VAR id="x" />
                    <VAR id="y" />
                  </PREDCON>
                </IMPL>

                <PREDCON ref="l.equal">
                  <FUNCON ref="power">
                    <FUNCON ref="intersection">
                      <VAR id="x" />
                      <VAR id="y" />
                    </FUNCON>
                  </FUNCON>
                  <FUNCON ref="intersection">
                    <FUNCON ref="power">
                      <VAR id="x" />
                    </FUNCON>
                    <FUNCON ref="power">
                      <VAR id="y" />
                    </FUNCON>
                  </FUNCON>
                </PREDCON>

                <PREDCON ref="subclass">
                  <FUNCON ref="union">
                    <FUNCON ref="power">
                      <VAR id="x" />
                    </FUNCON>
                    <FUNCON ref="power">
                      <VAR id="y" />
                    </FUNCON>
                  </FUNCON>
                  <FUNCON ref="power">
                    <FUNCON ref="union">
                      <VAR id="x" />
                      <VAR id="y" />
                    </FUNCON>
                  </FUNCON>
                </PREDCON>
              
                <PREDCON ref="subclass">
                  <VAR id="x" />
                  <FUNCON ref="power">
                    <FUNCON ref="setSum">
                      <VAR id="x" />
                    </FUNCON>
                  </FUNCON>
                </PREDCON>

                <PREDCON ref="subclass">
                  <FUNCON ref="setSum">
                    <FUNCON ref="power">
                      <VAR id="x" />
                    </FUNCON>
                  </FUNCON>
                  <VAR id="x" />
                </PREDCON>

              </AND>
            </FORMULA>
          </THEOREM>
        </NODE>

        <NODE id="theorem:powerSetPropositions" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                Especially for the power class of a set we can sharpen \qref{theorem:powerPropositions/j}.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Speziell für die Potenzklasse einer Menge lässt sich \qref{theorem:powerPropositions/j} verschärfen.
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <IMPL>
                <PREDCON ref="isSet">
                  <VAR id="x" />
                </PREDCON>
                <PREDCON ref="l.equal">
                  <VAR id="x" />
                  <FUNCON ref="setSum">
                    <FUNCON ref="power">
                      <VAR id="x" />
                    </FUNCON>
                  </FUNCON>
                </PREDCON>
              </IMPL>
            </FORMULA>
          </THEOREM>
          <SUCCEEDING>
            <LATEX language="en">
              <![CDATA[
                For a set building the power class and afterwards building the set sum eliminate each other.
                Later on we can drop the set condition because of new axioms.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Für Mengen heben sich die Potenzklassenbildung und die Mengensumme (in dieser Reihenfolge) gegenseitig auf.
                Später können wir die Mengenbedingung fallenlassen, da wir dann über weitere Axiome
                verfügen.
              ]]>
            </LATEX>
          </SUCCEEDING>
        </NODE>
      </SUBSECTIONS>
    </SECTION>

    </CHAPTER>
    <CHAPTER>
      <TITLE>
        <LATEX language="en">
          Sets, Relations and Functions
        </LATEX>
        <LATEX language="de">
           Mengen, Relationen und Funktionen
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
          
            In this chapter we concentrate on the property \emph{is a set} and we introduce new axioms to assure
            the existence of sets.
            
            \par
            To be able to define relations within our theory we need the new class operator \emph{ordered pair}. 
            With this operator we can define \emph{Cartesian products} of classes. Relations are no other
            than subclasses of Cartesian products and fulfill the laws of an \emph{universal algebra}\index{algebra!universal}.
            
            \par
            A special kind of relations are the \emph{equivalence relations} which form a more abstract form of 
            equality. Functions are also a special kind of relations. The axiom of replacement guaranties that
            sets are mapped onto sets.

          ]]>
        </LATEX>
        <LATEX language="de">
          <![CDATA[
          
            In diesem Kapitel wird noch einmal genauer auf die Mengeneigenschaft eingegangen und es werden neue Axiome angegeben, um die Existenz von Mengen abzusichern.

            \par
            Um Relationen definieren zu können, wird der Begriff des \emph{geordneten Klassenpaares} benötigt,
            der es ermöglicht, das \emph{cartesische Produkt} von Klassen zu definieren. Relationen sind
            Teilklassen von cartesischen Produkten und bilden zusammen mit bestimmten Operationen eine
            \emph{universelle Algebra}\index{Algebra!universelle}. 
            
            \par
            Spezielle Relationen sind die \emph{Äquivalenzrelationen}, die einen etwas
            weiter gefassten Gleichheitsbegriff ermöglichen. Funktionen sind ebenfalls spezielle Relationen,
            Das Fraenkelsche Ersetzungsaxiom garantiert, dass Mengen auf Mengen abgebildet werden.

          ]]>
        </LATEX>
      </INTRODUCTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">
           Sets
        </LATEX>
        <LATEX language="de">
           Mengen
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            
            For the presentation of the boolean class algebra we needed no set theoretic axioms. In the following
            we get some more axioms that give conditions for being a set.

          ]]>
        </LATEX>
        <LATEX language="de">
          <![CDATA[

            Zur Darstellung der Booleschen Klassenalgebra wurden noch keine mengentheoretischen Axiome benötigt
            Im Folgenden werden weitere Axiome vorgestellt, die Bedingungen dafür angeben, wann eine Klasse
            eine Menge ist.

          ]]>
        </LATEX>
      </INTRODUCTION>
      <SUBSECTIONS>

        <NODE id="axiom:emptySet" level="formal">
          <NAME>
            <LATEX language="en">empty set axiom</LATEX>
            <LATEX language="de">Nullmengenaxiom</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Empty Set Axiom\index{axiom!empty set}</LATEX>
            <LATEX language="de">Axiom der leeren Menge\index{Axiom!der leeren Menge}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
              
                The empty class should be a set.
              
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
              
                Die leere Klasse soll eine Menge sein.
              
              ]]>
            </LATEX>
          </PRECEDING>
          <AXIOM>
            <FORMULA>
              <PREDCON ref="isSet">
                <FUNCON ref="emptySet" />
              </PREDCON>
            </FORMULA>
          </AXIOM>
          <SUCCEEDING>
            <LATEX language="en">
              <![CDATA[
              
                This is the first time we know about the existence of a set.
              
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
              
                Damit haben wir zum ersten Mal Kenntnis über die Existenz einer Menge.
              
              ]]>
            </LATEX>
          </SUCCEEDING>
        </NODE>

        <NODE id="axiom:pairingSet" level="formal">
          <NAME>
            <LATEX language="en">pairing set axiom</LATEX>
            <LATEX language="de">Paarmengenaxiom</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Pairing Set Axiom\index{axiom!pairing set}</LATEX>
            <LATEX language="de">Axiom der Paarmenge\index{Axiom!Paarmengen-}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                To ensure the set property for set pairs we have out next axiom.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Um die Mengeneigenschaft für Paare von Mengen zu erhalten, haben wir das
                folgende Axiom.
              ]]>
            </LATEX>
          </PRECEDING>
          <AXIOM>
            <FORMULA>
              <IMPL>
                <AND>
                  <PREDCON ref="isSet">
                    <VAR id="x" />
                  </PREDCON>
                  <PREDCON ref="isSet">
                    <VAR id="y" />
                  </PREDCON>
                </AND>
                <PREDCON ref="isSet">
                  <FUNCON ref="classList">
                    <VAR id="x" />
                    <VAR id="y" />
                  </FUNCON>
                </PREDCON>
              </IMPL>
            </FORMULA>
          </AXIOM>
        </NODE>

        <NODE id="axiom:setSumSet" level="formal">
          <NAME>
            <LATEX language="en">sum set axiom</LATEX>
            <LATEX language="de">Summenmengenaxiom</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Axiom of the Sum Set\index{axiom!of the sum set}</LATEX>
            <LATEX language="de">Summenmengenaxiom\index{Axiom!Summenmengen-}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                The sum set of a set should be a set too.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Auch die Mengensumme einer Menge soll wieder eine Menge sein.
              ]]>
            </LATEX>
          </PRECEDING>
          <AXIOM>
            <FORMULA>
              <IMPL>
                <PREDCON ref="isSet">
                  <VAR id="x" />
                </PREDCON>
                <PREDCON ref="isSet">
                  <FUNCON ref="setSum">
                    <VAR id="x" />
                  </FUNCON>
                </PREDCON>
              </IMPL>
            </FORMULA>
          </AXIOM>
        </NODE>

        <NODE id="axiom:powerSet" level="formal">
          <NAME>
            <LATEX language="en">power set axiom</LATEX>
            <LATEX language="de">Potenzmengenaxiom</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Power Set Axiom\index{axiom!power set}</LATEX>
            <LATEX language="de">Axiom der Potenzmenge\index{Axiom!Potenzmengen-}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
              
                ´The power class of a set should also be a set.
              
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
              
                Die Potenzklasse einer Menge soll auch wieder eine Menge sein.
              
              ]]>
            </LATEX>
          </PRECEDING>
          <AXIOM>
            <FORMULA>
              <IMPL>
                <PREDCON ref="isSet">
                  <VAR id="x" />
                </PREDCON>
                <PREDCON ref="isSet">
                  <FUNCON ref="power">
                    <VAR id="x" />
                  </FUNCON>
                </PREDCON>
              </IMPL>
            </FORMULA>
          </AXIOM>
        </NODE>

        <NODE id="axiom:subset" level="formal">
          <NAME>
            <LATEX language="en">subset axiom</LATEX>
            <LATEX language="de">Teilmengenaxiom</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Subset Axiom\index{axiom!subset}</LATEX>
            <LATEX language="de">Teilmengenaxiom\index{Axiom!Teilmengen-}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
              
                The subclass of a set should also be a set.
              
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
              
                Die Teilklasse einer Menge soll wieder eine Menge sein.
                
              ]]>
            </LATEX>
          </PRECEDING>
          <AXIOM>
            <FORMULA>
              <IMPL>
                <AND>
                  <PREDCON ref="isSet">
                    <VAR id="x" />
                  </PREDCON>
                  <PREDCON ref="subclass">
                    <VAR id="y" />
                    <VAR id="x" />
                  </PREDCON>
                </AND>
                <PREDCON ref="isSet">
                  <VAR id="y" />
                </PREDCON>
              </IMPL>
            </FORMULA>
          </AXIOM>
        </NODE>

        <SUBSECTION>
          <TEXT>
            <LATEX language="en">
              <![CDATA[

                The above set axioms enables us to construct sets. Starting with 
                \qref{axiom:emptySet} we have one first set $\emptyset$. By applying
                \qref{axiom:powerSet} we get the set $\{ \emptyset \}$. Building the
                power class again provides the set $\{ \emptyset, \{ \emptyset \} \}$. 
                By repeating this procedure we get an infinite number of 
                sets.\footnote{One can easily show that they are all different.}
                
                \par
                Furthermore we notice that our current axioms can show only the existence of
                sets with a finite number of members. These finite classes are `save' in
                the following sense: they alone can not lead to the contradictions as the 
                unrestricted set theory of Zermelo.
              
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Die obigen Mengenaxiome ermöglichen es uns Mengen zu konstruieren.
                Durch das \qref{axiom:emptySet} haben wir eine erste Menge $\emptyset$. 
                Durch die Anwendung von \qref{axiom:powerSet} erhalten wir die Menge
                $\{ \emptyset \}$. Die erneute Bildung der Potenzmenge erzeugt die Menge
                $\{ \emptyset, \{ \emptyset \} \}$. Durch wiederholtes Anwendung der Prozedur
                bekommen wir eine beliebige Anzahl von Mengen.\footnote{Dass die Mengen alle
                paarweise voneinander verschieden sind, ist leicht zu zeigen.}
                
                \par
                Weiterhin stellen wir fest, dass wir mit unseren bisherigen Axiomen nur die 
                Existenz von Mengen mit einer endlichen Elementanzahl nachweisen können.
                Diese endlichen Mengen sind {\glqq sicher\grqq} in dem Sinne, dass sie nicht zu
                den Widersprüchen führen, wie sie in der uneingeschränkten Mengenlehre 
                Zermelos auftreten,
                
              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>

        <NODE id="theorem:isSet" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
              
                The new axioms enable us to derive some more propositions.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
              
                Mit Hilfe der neuen Axiome können weitere Folgerungen gezogen werden.

              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <AND>
                <IMPL>
                  <AND>
                    <NOT>
                      <PREDCON ref="isSet">
                        <VAR id="y" />
                      </PREDCON>
                    </NOT>
                    <PREDCON ref="subclass">
                      <VAR id="y" />
                      <VAR id="x" />
                    </PREDCON>
                  </AND>
                  <NOT>
                    <PREDCON ref="isSet">
                      <VAR id="x" />
                    </PREDCON>
                  </NOT>
                </IMPL>
                <NOT>
                  <PREDCON ref="isSet">
                    <FUNCON ref="universalClass" />
                  </PREDCON>
                </NOT>
                <IMPL>
                  <AND>
                    <PREDCON ref="isSet">
                      <VAR id="x" />
                    </PREDCON>
                    <PREDCON ref="isSet">
                      <VAR id="y" />
                    </PREDCON>
                  </AND>
                  <PREDCON ref="isSet">
                    <FUNCON ref="union">
                      <VAR id="x" />
                      <VAR id="y" />
                    </FUNCON>
                  </PREDCON>
                </IMPL>
                <IMPL>
                  <AND>
                    <PREDCON ref="isSet">
                      <VAR id="x" />
                    </PREDCON>
                    <PREDCON ref="isSet">
                      <VAR id="y" />
                    </PREDCON>
                  </AND>
                  <PREDCON ref="isSet">
                    <FUNCON ref="intersection">
                      <VAR id="x" />
                      <VAR id="y" />
                    </FUNCON>
                  </PREDCON>
                </IMPL>
                <IMPL>
                  <PREDCON ref="isSet">
                    <VAR id="x" />
                  </PREDCON>
                  <PREDCON ref="isSet">
                    <FUNCON ref="classList">
                      <VAR id="x" />
                    </FUNCON>
                  </PREDCON>
                </IMPL>
                <IMPL>
                  <PREDCON ref="isSet">
                    <VAR id="x" />
                  </PREDCON>
                  <NOT>
                    <PREDCON ref="isSet">
                      <FUNCON ref="complement">
                        <VAR id="x" />
                      </FUNCON>
                    </PREDCON>
                  </NOT>
                </IMPL>
                <PREDCON ref="l.equal">
                  <VAR id="x" />
                  <FUNCON ref="setSum">
                    <FUNCON ref="power">
                      <VAR id="x" />
                    </FUNCON>
                  </FUNCON>
                </PREDCON>
                <EQUI>
                  <PREDCON ref="isSet">
                    <VAR id="x" />
                  </PREDCON>
                  <PREDCON ref="isSet">
                    <FUNCON ref="setSum">
                      <VAR id="x" />
                    </FUNCON>
                  </PREDCON>
                </EQUI>
                <PREDCON ref="l.equal">
                  <FUNCON ref="setProduct">
                    <FUNCON ref="universalClass" />
                  </FUNCON>
                  <FUNCON ref="emptySet" />
                </PREDCON>
                <PREDCON ref="l.equal">
                  <FUNCON ref="setSum">
                    <FUNCON ref="universalClass" />
                  </FUNCON>
                  <FUNCON ref="universalClass" />
                </PREDCON>
                <IMPL>
                  <PREDCON ref="l.notEqual">
                    <VAR id="x" />
                    <FUNCON ref="emptySet" />
                  </PREDCON>
                  <PREDCON ref="isSet">
                    <FUNCON ref="setProduct">
                      <VAR id="x" />
                    </FUNCON>
                  </PREDCON>
                </IMPL>
              </AND>
            </FORMULA>
          </THEOREM>
        </NODE>

        <SUBSECTION>
          <TEXT>
            <LATEX language="en">
              <![CDATA[
                We conclude observing we didn't use \qref{axiom:emptySet} ((Empty Set Axiom) in our axioms yet. This means all previous propositions are valid even if we can not guarantee the existence of one single set.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Wir stellen abschließend fest, dass wir \qref{axiom:emptySet} (Axiom der leeren Menge) in den Beweisen bisher noch nicht verwendet haben. Da bedeutet, dass alle bisherigen Sätze unabhängig von der Existenz einer einzigen Menge gültig sind.
              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>


      </SUBSECTIONS>
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">
           Ordered Pair
        </LATEX>
        <LATEX language="de">
           Geordnetes Klassenpaar
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
          
            The concept of an ordered pair is vital for our further development.
            It enables us to arrange objects. Till now our object collections did not depend on the
            order of gathering. We wish to figure out which element was \emph{first} and which element
            was \emph{second} after wards.

          ]]>
        </LATEX>
        <LATEX language="de">
          <![CDATA[
          
            Das Konzept eines geordneten Paares ist für die weitere Entwicklung unserer Theorie wichtig.
            Es ermöglicht uns die Objekte anzuordnen. Bisher hingen unsere Objektzusammenfassungen nicht
            von der Reihenfolge der Sammlung ab. Wir wollen nun aber auch nach der Zusammenfassung
            herausfinden können, welches das \emph{erste} Element und welches das \emph{zweite} Element
            war.

          ]]>
        </LATEX>
      </INTRODUCTION>
      <SUBSECTIONS>

        <NODE id="definition:orderedPair">
          <NAME>
            <LATEX language="en">ordered pair</LATEX>
            <LATEX language="de">geordnetes Paar</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Ordered Pair\index{pair!ordered}\index{ordered pair}</LATEX>
            <LATEX language="de">Geordnetes Paar\index{geordnetes Paar}\index{Paar!geordnetes}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
              
                Our definition of an \emph{ordered pair} $\langle x, y\rangle$ is due to  \emph{N.~Wiener} (1914) and \emph{K.~Kuratowski} (1921).

              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
              
                Die Definition eines geordneten Paares $\langle x, y\rangle$ erfolgt nach \emph{N.~Wiener} (1914) bzw. \emph{K.~Kuratowski} (1921).

              ]]>
            </LATEX>
          </PRECEDING>
          <DEFINITION_FUNCTION arguments="2" name="orderedPair">
            <LATEXPATTERN>\langle #1, #2 \rangle</LATEXPATTERN>
            <FORMULA>
              <PREDCON ref="l.equal">
                <FUNCON ref="orderedPair">
                  <VAR id="x" />
                  <VAR id="y" />
                </FUNCON>
                <FUNCON ref="classList">
                  <FUNCON ref="classList">
                    <VAR id="x" />
                  </FUNCON>
                  <FUNCON ref="classList">
                    <VAR id="x" />
                    <VAR id="y" />
                  </FUNCON>
                </FUNCON>
              </PREDCON>
            </FORMULA>
          </DEFINITION_FUNCTION>
        </NODE>

        <NODE id="theorem:orderedPairEquality" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                For an ordered pair of sets the order of the defining elements matters.
                Ordered pairs should only be identical if their first elements 
                are identical and their second elements are identical.
             
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Für geordnete Paare von Mengen spielt die Reihe der angegebenen Elemente
                eine Rolle. Geordnete Paare sollten nur dann identisch sein, wenn
                ihre ersten Elemente und ihre zweiten Elemente identisch sind.
             
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <IMPL>
                <AND>
                  <PREDCON ref="isSet">
                    <VAR id="x" />
                  </PREDCON>
                  <PREDCON ref="isSet">
                    <VAR id="y" />
                  </PREDCON>
                  <PREDCON ref="isSet">
                    <VAR id="u" />
                  </PREDCON>
                  <PREDCON ref="isSet">
                    <VAR id="v" />
                  </PREDCON>
                </AND>
                <IMPL>
                  <PREDCON ref="l.equal">
                    <FUNCON ref="orderedPair">
                      <VAR id="x" />
                      <VAR id="y" />
                    </FUNCON>
                    <FUNCON ref="orderedPair">
                      <VAR id="u" />
                      <VAR id="v" />
                    </FUNCON>
                  </PREDCON>
                  <AND>
                    <PREDCON ref="l.equal">
                      <VAR id="x" />
                      <VAR id="u" />
                    </PREDCON>
                    <PREDCON ref="l.equal">
                      <VAR id="y" />
                      <VAR id="v" />
                    </PREDCON>
                  </AND>
                </IMPL>
              </IMPL>
            </FORMULA>
          </THEOREM>
        </NODE>
        
        <NODE id="theorem:orderedPairOfSets" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                An ordered pair made of sets is also a set. The reverse is also true.
             
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
              
                Ein aus Mengen gebildetes geordnetes Paar ist auch eine Menge. 
                Die Umkehrung gilt auch.
             
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <EQUI>
                <AND>
                  <PREDCON ref="isSet">
                    <VAR id="x" />
                  </PREDCON>
                  <PREDCON ref="isSet">
                    <VAR id="y" />
                  </PREDCON>
                </AND>
                <PREDCON ref="isSet">
                  <FUNCON ref="orderedPair">
                    <VAR id="x" />
                    <VAR id="y" />
                  </FUNCON>
                </PREDCON>
              </EQUI>
            </FORMULA>
          </THEOREM>
        </NODE>
        
        <NODE id="theorem:orderedPairWithNonSet" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                If one of the classes is not a set the resulting ordered pair is 
                identical with the universal class.
             
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
              
                Falls eine der Klassen keine Menge ist, dann ist das geordnete Paar
                mit der Allklasse identisch.
             
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <IMPL>
                <OR>
                  <NOT>
                    <PREDCON ref="isSet">
                      <VAR id="x" />
                    </PREDCON>
                  </NOT>
                  <NOT>
                    <PREDCON ref="isSet">
                      <VAR id="y" />
                    </PREDCON>
                  </NOT>
                </OR>
                <PREDCON ref="l.equal">
                  <FUNCON ref="orderedPair">
                    <VAR id="x" />
                    <VAR id="y" />
                  </FUNCON>
                  <FUNCON ref="universalClass" />
                </PREDCON>
              </IMPL>
            </FORMULA>
          </THEOREM>
        </NODE>
        
        <NODE id="definition:isOrderedPair" level="formal">
          <NAME>
            <LATEX language="en">is ordered pair</LATEX>
            <LATEX language="de">ist geordnetes Paar</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Ordered Pair Property\index{ordered pair!property}\index{pair!ordered}</LATEX>
            <LATEX language="de">Eigenschaft geordnetes Paar\index{Paar!geordnetes}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
              
                To speak of ordered pairs we need a predicate that says `is an ordered pair'.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Um über geordnete Paare sprechen zu können, benötigen wir ein neues Prädikat
                {\glqq ist ein geordnetes Paar \grqq}.
                
              ]]>
            </LATEX>
          </PRECEDING>
          <DEFINITION_PREDICATE arguments="1" name="isOrderedPair">
            <LATEXPATTERN>\mbox{isOrderedPair}(#1)</LATEXPATTERN>
            <FORMULA>
              <EQUI>
                <PREDCON ref="isOrderedPair">
                  <VAR id="x"/>
                </PREDCON>
                <EXISTS>
                  <VAR id="u"/>
                  <EXISTS>
                    <VAR id="v"/>
                    <PREDCON ref="l.equal">
                      <VAR id="x"/>
                      <FUNCON ref="orderedPair">
                        <VAR id="u" />
                        <VAR id="v" />
                      </FUNCON>
                    </PREDCON>
                  </EXISTS>
                </EXISTS>
              </EQUI>
            </FORMULA>
          </DEFINITION_PREDICATE>
          <SUCCEEDING>
            <LATEX language="en">
              <![CDATA[

                We notice that $\mathfrak{V}$ is also an ordered pair. But because we mostly speak
                about class members we must only deal with sets that might be ordered pairs.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
              
                Wir betonen noch einmal, dass auch $\mathfrak{V}$ ein geordnetes Paar ist. Aber da
                wir meistens über Elemente von Klassen sprechen, haben wir nur mit Mengen zu tun,
                die eventuell auch geordnete Paare sind.
                
              ]]>
            </LATEX>
          </SUCCEEDING>
        </NODE>
        
      </SUBSECTIONS>
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">
           Cartesian Product
        </LATEX>
        <LATEX language="de">
           Kartesisches Produkt
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[

            For the ordered pairs we need a meta structure. We just assemble ordered pairs into a class.

          ]]>
        </LATEX>
        <LATEX language="de">
          <![CDATA[
          
            Für die geordneten Klassenpaare brauchen wir eine Metastruktur. Dafür fassen wir einfach geordnete
            Paare in einer Klasse zusammen.

          ]]>
        </LATEX>
      </INTRODUCTION>
        <SUBSECTIONS>

          <NODE id="definition:cartesianProduct">
            <NAME>
              <LATEX language="en">Cartesian product</LATEX>
              <LATEX language="de">Kartesisches Produkt</LATEX>
            </NAME>
            <TITLE>
              <LATEX language="en">Cartesian Product\index{product!Cartesian}\index{Cartesian product}\index{direct product}\index{product!direct}</LATEX>
              <LATEX language="de">Kartesisches Produkt\index{Produkt!kartesisches}\index{Produkt!Kreuz-}\index{Kartesisches Produkt}\index{Kreuzprodukt}</LATEX>
            </TITLE>
            <PRECEDING>
              <LATEX language="en">
                <![CDATA[
                 The \emph{Cartesian product}\footnote{Named after the the French philosopher and mathematician \emph{R.~Descartes} also known as \emph{Cartesius}.} also called \emph{direct product} is the class of all ordered pairs, which elements are members of the origin classes.

                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[

                  Das Kartesische Produkt\footnote{Kartesisch oder kartesianisch nach der 
                  lateinischen Namensform \emph{Cartesius} des Philosophen und Mathematikers 
                  \emph{R.~Descartes}.}, auch \emph{Kreuzprodukt} genannt, ist die Klasse 
                  aller geordneter Paare, deren Elemente aus den Ausgangsklassen stammen.

                ]]>
              </LATEX>
            </PRECEDING>
            <DEFINITION_FUNCTION arguments="2" name="cartesianProduct">
              <LATEXPATTERN>( #1 \times #2)</LATEXPATTERN>
              <FORMULA>
                <PREDCON ref="l.equal">
                  <FUNCON ref="cartesianProduct">
                    <VAR id="x" />
                    <VAR id="y" />
                  </FUNCON>
                  <CLASS>
                    <VAR id="z"/>
                    <EXISTS>
                      <VAR id="u" />
                      <EXISTS>
                        <VAR id="v" />
                        <AND>
                          <PREDCON ref="in">
                            <VAR id="u" />
                            <VAR id="x" />
                          </PREDCON>
                          <PREDCON ref="in">
                            <VAR id="v" />
                            <VAR id="y" />
                          </PREDCON>
                          <PREDCON ref="l.equal">
                            <VAR id="z" />
                            <FUNCON ref="orderedPair">
                              <VAR id="u" />
                              <VAR id="v" />
                            </FUNCON>
                          </PREDCON>
                        </AND>
                      </EXISTS>
                    </EXISTS>
                  </CLASS>
                </PREDCON>
              </FORMULA>
            </DEFINITION_FUNCTION>
          </NODE>
      
      </SUBSECTIONS>
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">
           Relations
        </LATEX>
        <LATEX language="de">
           Relationen
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
          
            It is important to be able to express relations between
            mathematical objects and to handle them as objects
            too. It turns out that we do not have to introduce new
            kinds of objects. Our current structures are sufficient.

          ]]>
        </LATEX>
        <LATEX language="de">
          <![CDATA[

            Es ist wichtig, Relationen zwischen mathematischen Objekten
            ausdrücken zu können und sie auch als Objekte behandeln
            zu können. Es stellt sich heraus, dass wir keine neuen
            Objektarten benötigen. Unsere bisherigen Strukturen reichen aus.

          ]]>
        </LATEX>
      </INTRODUCTION>
      <SUBSECTIONS>

        <NODE id="definition:relation">
          <NAME>
            <LATEX language="en">is relation</LATEX>
            <LATEX language="de">ist eine Relation</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Relation\index{relation}</LATEX>
            <LATEX language="de">Relation\index{relation}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                
                We are now able to define a \emph{relation} within our set theory.

              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Nun können wir den Begriff der \emph{Relation} auch innerhalb unserer Mengenlehre definieren.

              ]]>
            </LATEX>
          </PRECEDING>
          <DEFINITION_PREDICATE arguments="1" name="isRelation">
            <LATEXPATTERN>\mathfrak{Rel}(#1)</LATEXPATTERN>
            <FORMULA>
              <EQUI>
                <PREDCON ref="isRelation">
                  <VAR id="x" />
                </PREDCON>
                <FORALL>
                  <VAR id="y"/>
                  <IMPL>
                    <PREDCON ref="in">
                      <VAR id="y" />
                      <VAR id="x" />
                    </PREDCON>
                    <PREDCON ref="isOrderedPair">
                      <VAR id="y" />
                    </PREDCON>
                  </IMPL>
                </FORALL>
              </EQUI>
            </FORMULA>
          </DEFINITION_PREDICATE>
        </NODE>
      
        <NODE id="theorem:relationProperties" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
              
                Some propositions about relations.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
              
                Ein paar Aussagen über Relationen.

              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <AND>
                <PREDCON ref="isRelation">
                  <FUNCON ref="emptySet" />
                </PREDCON>
                <PREDCON ref="isRelation">
                  <FUNCON ref="cartesianProduct">
                    <FUNCON ref="universalClass" />
                    <FUNCON ref="universalClass" />
                  </FUNCON>
                </PREDCON>
                <IMPL>
                  <AND>
                    <PREDCON ref="isRelation">
                      <VAR id="x" />
                    </PREDCON>
                    <PREDCON ref="isRelation">
                      <VAR id="y" />
                    </PREDCON>
                  </AND>
                  <PREDCON ref="isRelation">
                    <FUNCON ref="intersection">
                      <VAR id="x" />
                      <VAR id="y" />
                    </FUNCON>
                  </PREDCON>
                </IMPL>
                <IMPL>
                  <AND>
                    <PREDCON ref="isRelation">
                      <VAR id="x" />
                    </PREDCON>
                    <PREDCON ref="isRelation">
                      <VAR id="y" />
                    </PREDCON>
                  </AND>
                  <PREDCON ref="isRelation">
                    <FUNCON ref="union">
                      <VAR id="x" />
                      <VAR id="y" />
                    </FUNCON>
                  </PREDCON>
                </IMPL>
              </AND>
            </FORMULA>
          </THEOREM>
        </NODE>

        <NODE id="definition:domain">
          <NAME>
            <LATEX language="en">domain of</LATEX>
            <LATEX language="de">Definitionsbereich von</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Domain\index{domain}</LATEX>
            <LATEX language="de">Definitionsbereich\index{Definitionsbereich}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                We now give an universal definition of the concept \emph{domain}.

              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
              
                Wie geben nun eine allgemeine Definition des Begriffs \emph{Definitionsbereich} an.

              ]]>
            </LATEX>
          </PRECEDING>
          <DEFINITION_FUNCTION arguments="1" name="domain">
            <LATEXPATTERN>\mathfrak{Dom}(#1)</LATEXPATTERN>
            <FORMULA>
              <PREDCON ref="l.equal">
                <FUNCON ref="domain">
                  <VAR id="x" />
                </FUNCON>
                <CLASS>
                  <VAR id="y"/>
                  <EXISTS>
                    <VAR id="z"/>
                    <PREDCON ref="in">
                      <FUNCON ref="orderedPair">
                        <VAR id="y" />
                        <VAR id="z" />
                      </FUNCON>
                      <VAR id="x" />
                    </PREDCON>
                  </EXISTS>
                </CLASS>
              </PREDCON>
            </FORMULA>
          </DEFINITION_FUNCTION>
        </NODE>
      
        <NODE id="definition:range">
          <NAME>
            <LATEX language="en">range of</LATEX>
            <LATEX language="de">Wertebereich von</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Range\index{range}</LATEX>
            <LATEX language="de">Wertebereich\index{Wertebereich}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
              
                Analogous to the domain we specify the \emph{range} of a class.

              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[

                Analog zu dem Definitionsbereich legen wir den \emph{Wertebereich} einer Klasse fest.

              ]]>
            </LATEX>
          </PRECEDING>
          <DEFINITION_FUNCTION arguments="1" name="range">
            <LATEXPATTERN>\mathfrak{Rng}(#1)</LATEXPATTERN>
            <FORMULA>
              <PREDCON ref="l.equal">
                <FUNCON ref="range">
                  <VAR id="x" />
                </FUNCON>
                <CLASS>
                  <VAR id="y"/>
                  <EXISTS>
                    <VAR id="z"/>
                    <PREDCON ref="in">
                      <FUNCON ref="orderedPair">
                        <VAR id="z" />
                        <VAR id="y" />
                      </FUNCON>
                      <VAR id="x" />
                    </PREDCON>
                  </EXISTS>
                </CLASS>
              </PREDCON>
            </FORMULA>
          </DEFINITION_FUNCTION>
        </NODE>
      
      
      </SUBSECTIONS>
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">
           Relation Algebra
        </LATEX>
        <LATEX language="de">
           Relationenalgebra
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[

    +++
          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">
           Equivalence Relations
        </LATEX>
        <LATEX language="de">
           Äquivalenzrelationen
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[

    +++
          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">
           Maps and Functions
        </LATEX>
        <LATEX language="de">
           Abbildungen und Funktionen
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[

    +++

          ]]>
        </LATEX>
      </INTRODUCTION>
      
      <SUBSECTIONS>

        <NODE id="definition:function">
          <NAME>
            <LATEX language="en">is function</LATEX>
            <LATEX language="de">ist eine Funktion</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Function\index{function}</LATEX>
            <LATEX language="de">Funktion\index{Funktion}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[

                A function is just a special sort of relation.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
              
                Eine Funktion ist einfach eine spezielle Art von Relation.

              ]]>
            </LATEX>
          </PRECEDING>
          <DEFINITION_PREDICATE arguments="1" name="isFunction">
            <LATEXPATTERN>\mathfrak{Funct}(#1)</LATEXPATTERN>
            <FORMULA>
              <EQUI>
                <PREDCON ref="isFunction">
                  <VAR id="x"/>
                </PREDCON>
                <AND>
                  <PREDCON ref="isRelation">
                    <VAR id="x"/>
                  </PREDCON>
                  <FORALL>
                    <VAR id="y"/>
                    <IMPL>
                      <PREDCON ref="in">
                        <VAR id="y" />
                        <FUNCON ref="domain">
                          <VAR id="x" />
                        </FUNCON>
                      </PREDCON>
                      <EXISTSU>
                        <VAR id="z" />
                        <PREDCON ref="in">
                          <FUNCON ref="orderedPair">
                            <VAR id="y" />
                            <VAR id="z" />
                          </FUNCON>
                          <VAR id="x" />
                        </PREDCON>
                      </EXISTSU>
                    </IMPL>
                  </FORALL>
                </AND>
              </EQUI>
            </FORMULA>
          </DEFINITION_PREDICATE>
        </NODE>
        
        <NODE id="axiom:FraenkelsReplacement" level="formal">
          <NAME>
            <LATEX language="en">Fraenkel's replacement axiom</LATEX>
            <LATEX language="de">Fraenkelsches Ersetzungsaxiom</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Fraenkel's Replacement Axiom\index{axiom!of replacement}\index{Fraenkel's replacement axiom}</LATEX>
            <LATEX language="de">Fraenkelsches Ersetzungsaxiom\index{Axiom!Fraenkelsches Ersetzungs-}\index{Substitutionsaxiom}\index{Fraenkel}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
              
                If the domain of a function is a set so its range should be a set too.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
              
                Falls der Definitionsbereich einer Funktion eine Menge ist, dann sollte auch ihr Wertebereich eine Menge sein.
                
              ]]>
            </LATEX>
          </PRECEDING>
          <AXIOM>
            <FORMULA>
              <IMPL>
                <AND>
                  <PREDCON ref="isFunction">
                    <VAR id="f" />
                  </PREDCON>
                  <PREDCON ref="isSet">
                    <FUNCON ref="domain">
                      <VAR id="f" />
                    </FUNCON>
                  </PREDCON>
                </AND>
                <PREDCON ref="isSet">
                  <FUNCON ref="range">
                    <VAR id="f" />
                  </FUNCON>
                </PREDCON>
              </IMPL>
            </FORMULA>
          </AXIOM>
        </NODE>
      
      </SUBSECTIONS>      
    </SECTION>
  </CHAPTER>
  <CHAPTER>
    <TITLE>
      <LATEX language="en">
        Natural Numbers
      </LATEX>
      <LATEX language="de">
         Natürliche Zahlen
      </LATEX>
    </TITLE>
    <INTRODUCTION>
      <LATEX language="en">
        <![CDATA[

  +++
        ]]>
      </LATEX>
    </INTRODUCTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">
           Foundation and Infinity
        </LATEX>
        <LATEX language="de">
           Fundierung und Unendlichkeit
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[

  +++

          ]]>
        </LATEX>
      </INTRODUCTION>
      <SUBSECTIONS>      
        <NODE id="axiom:foundation" level="formal">
          <NAME>
            <LATEX language="en">axiom of foundation</LATEX>
            <LATEX language="de">Fundierungsaxiom</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Axiom of Foundation\index{axiom!of foundation}\index{axiom!of regularity}</LATEX>
            <LATEX language="de">Fundierungsaxiom\index{Axiom!Fundierungs-}\index{Axiom!Regularitäts-}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
              
                Sets $x$ should not contain itself as a member, or contain an element that contains $x$. 
                To avoid these and further membership circles we provide the following axiom.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
              
                Mengen $x$ sollten sich nicht selbst als Element enthalten oder ein Element besitzen, das wiederum
                $x$ als Element hat. Um diese und andere Enthaltenseinszirkel auszuschließen, stellen wir das folgende
                Axiom vor.
                
              ]]>
            </LATEX>
          </PRECEDING>
          <AXIOM>
            <FORMULA>
              <IMPL>
                <PREDCON ref="l.notEqual">
                  <VAR id="x" />
                  <FUNCON ref="emptySet" />
                </PREDCON>
                <EXISTS>
                  <VAR id="y" />
                  <AND>
                    <PREDCON ref="in">
                      <VAR id="y" />
                      <VAR id="x" />
                    </PREDCON>
                    <PREDCON ref="l.equal">
                      <FUNCON ref="intersection">
                        <VAR id="y" />
                        <VAR id="x" />
                      </FUNCON>
                      <FUNCON ref="emptySet" />
                    </PREDCON>
                  </AND>
                </EXISTS>
              </IMPL>
            </FORMULA>
          </AXIOM>
          <SUCCEEDING>
            <LATEX language="en">
              <![CDATA[
              
                This axiom is also called axiom of regularity.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
              
                Dieses Axiom heißt auch Regularitätsaxiom.
                
              ]]>
            </LATEX>
          </SUCCEEDING>
        </NODE>
      
        <NODE id="definition:successor" level="formal">
          <NAME>
            <LATEX language="en">successor</LATEX>
            <LATEX language="de">Nachfolger</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Successor\index{successor}</LATEX>
            <LATEX language="de">Nachfolger\index{Nachfolger}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
              
                A canonical class extension is the union with its singleton.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
              
                Eine naheliegende Klassenerweiterung ist die Bildung der
                Vereinigungsmenge mit der Einerklasse.
                
              ]]>
            </LATEX>
          </PRECEDING>
          <DEFINITION_FUNCTION arguments="1" name="successor">
            <LATEXPATTERN>#1'</LATEXPATTERN>
            <FORMULA>
              <PREDCON ref="l.equal">
                <FUNCON ref="successor">
                  <VAR id="x" />
                </FUNCON>
                <FUNCON ref="union">
                  <VAR id="x" />
                  <FUNCON ref="classList">
                    <VAR id="x" />
                  </FUNCON>
                </FUNCON>
              </PREDCON>
            </FORMULA>
          </DEFINITION_FUNCTION>
          <SUCCEEDING>
            <LATEX language="en">
              <![CDATA[
              
                Because $x \notin x$ the successor function adds just one element to
                the original class.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
              
                Weil $x \notin x$ fügt die Nachfolgerfunktion der orginalen Klasse
                genau ein Element hinzu.
                
              ]]>
            </LATEX>
          </SUCCEEDING>
        </NODE>
        
        <NODE id="axiom:infinity" level="formal">
          <NAME>
            <LATEX language="en">axiom of infinity</LATEX>
            <LATEX language="de">Unendlichkeitsaxiom</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Axiom of Infinity\index{infinity!axiom of}\index{axiom!of infinity}</LATEX>
            <LATEX language="de">Unendlichkeitsaxiom\index{Unendlichkeit!-saxiom}\index{Axiom!Unendlichkeits-}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
              
                We want to have a set with an infinite number of elements. So we just postulate its existence.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
              
                Wir wollen eine Menge mit unendlich vielen Elementen haben. So fordern wir einfach ihre Existenz.
                
              ]]>
            </LATEX>
          </PRECEDING>
          <AXIOM>
            <FORMULA>
              <EXISTS>
                <VAR id="x" />
                <AND>
                  <PREDCON ref="isSet">
                    <VAR id="x" />
                  </PREDCON>
                  <PREDCON ref="in">
                    <FUNCON ref="emptySet" />
                    <VAR id="x" />
                  </PREDCON>
                  <FORALL>
                    <VAR id="y" />
                    <IMPL>
                      <PREDCON ref="in">
                        <VAR id="y" />
                        <VAR id="x" />
                      </PREDCON>
                      <PREDCON ref="in">
                        <FUNCON ref="successor">
                          <VAR id="y" />
                        </FUNCON>
                        <VAR id="x" />
                      </PREDCON>
                    </IMPL>
                  </FORALL>
                </AND>
              </EXISTS>
            </FORMULA>
          </AXIOM>
        </NODE>
      
      </SUBSECTIONS>      
      
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">
           Definition and Basic Properties
        </LATEX>
        <LATEX language="de">
           Definition und Grundeigenschaften
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[

    +++
          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">
           Induction
        </LATEX>
        <LATEX language="de">
           Induktion
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[

    +++
          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">
           Sequences and Normal Functions
        </LATEX>
        <LATEX language="de">
           Folgen und normale Funktionen
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[

    +++
          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">
           Recursion
        </LATEX>
        <LATEX language="de">
           Rekursion
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[

    +++
          ]]>
        </LATEX>
      </INTRODUCTION>
        </SECTION>
    </CHAPTER>
    <CHAPTER>
      <TITLE>
        <LATEX language="en">
           Axiom of Choice
        </LATEX>
        <LATEX language="de">
           Auswahlaxiom
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[

    +++

          ]]>
        </LATEX>
        <LATEX language="de">
          <![CDATA[

    +++

          ]]>
        </LATEX>
      </INTRODUCTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">
           Well-Ordering
        </LATEX>
        <LATEX language="de">
           Wohlordnungen
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="de">
          <![CDATA[

    +++
          ]]>
        </LATEX>
      </INTRODUCTION>
      <SUBSECTIONS>      
        <NODE id="axiom:choice" level="formal">
          <NAME>
            <LATEX language="en">axiom of choice</LATEX>
            <LATEX language="de">Auswahlaxiom</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Axiom of Choice\index{axiom!of foundation}</LATEX>
            <LATEX language="de">Auswahlaxiom\index{Axiom!Auswahl-}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                
                Now we come to the famous axiom of choice. We write it down for relations.
                
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
              
                Nun kommen wir zu dem bekannten Auswahlaxiom. Wir formulieren es für Relationen.
                
              ]]>
            </LATEX>
          </PRECEDING>
          <AXIOM>
            <FORMULA>
              <IMPL>
                <PREDCON ref="isRelation">
                  <VAR id="x" />
                </PREDCON>
                <EXISTS>
                  <VAR id="y" />
                  <IMPL>
                    <PREDCON ref="isFunction">
                      <VAR id="y" />
                    </PREDCON>
                    <AND>
                      <PREDCON ref="subclass">
                        <VAR id="y" />
                        <VAR id="x" />
                      </PREDCON>
                      <PREDCON ref="l.equal">
                        <FUNCON ref="domain">
                          <VAR id="x" />
                        </FUNCON>
                        <FUNCON ref="domain">
                          <VAR id="y" />
                        </FUNCON>
                      </PREDCON>
                    </AND>
                  </IMPL>
                </EXISTS>
              </IMPL>
            </FORMULA>
          </AXIOM>
        </NODE>
     </SUBSECTIONS>
      
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">
          Applications of the Axiom of Choice
        </LATEX>
        <LATEX language="de">
          Anwendungen des Auswahlaxioms
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[


          ]]>
        </LATEX>
       </INTRODUCTION>
    </SECTION>
  </CHAPTER>
  <CHAPTER>
    <TITLE>
      <LATEX language="en">
         Continuum
      </LATEX>
      <LATEX language="de">
         Kontinuum
      </LATEX>
    </TITLE>
    <INTRODUCTION>
      <LATEX language="de">
        <![CDATA[

        ]]>
      </LATEX>
    </INTRODUCTION>
  </CHAPTER>
  <BIBLIOGRAPHY>
    <ITEM label="lemmon">
      <LATEX language="en">
        <![CDATA[
           \emph{E. J. Lemmon}, Introduction to Axiomatic Set Theory, Routledge \& Kegan Paul Ltd, London 1968
        ]]>
      </LATEX>
      <LATEX language="de">
        <![CDATA[
           \emph{E. J. Lemmon}, Introduction to Axiomatic Set Theory, Routledge \& Kegan Paul Ltd, London 1968
        ]]>
      </LATEX>
    </ITEM>
    <ITEM label="monk">
      <LATEX language="en">
        <![CDATA[
           \emph{J. D. Monk}, Introduction to Set Theory, McGraw-Hill, New York 1996
        ]]>
      </LATEX>
      <LATEX language="de">
        <![CDATA[
           \emph{J. D. Monk}, Introduction to Set Theory, McGraw-Hill, New York 1996
        ]]>
      </LATEX>
    </ITEM>
    <ITEM label="schmidt">
      <LATEX language="en">
        <![CDATA[
           \emph{J. Schmidt}, Mengenlehre I, BI, Mannheim 1966
        ]]>
      </LATEX>
      <LATEX language="de">
        <![CDATA[
           \emph{J. Schmidt}, Mengenlehre I, BI, Mannheim 1966
        ]]>
      </LATEX>
    </ITEM>
  </BIBLIOGRAPHY>
  
</QEDEQ>
