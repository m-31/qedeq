<?xml version="1.0" encoding="UTF-8"?>
<QEDEQ
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="http://www.qedeq.org/0_04_03/xml/qedeq.xsd">
  <HEADER email="mime@qedeq.org">
    <SPECIFICATION name="qedeq_logic_v1" ruleVersion="1.00.00">
      <LOCATIONS>
        <LOCATION value="http://wwww.qedeq.org/0_04_03/doc/math"/>
      </LOCATIONS>
    </SPECIFICATION>
    <TITLE>
      <LATEX language="en">Elements of Mathematical Logic</LATEX>
      <LATEX language="de">Anfangsgründe der mathematischen Logik</LATEX>
    </TITLE>
    <ABSTRACT>
      <LATEX language="en">
        <![CDATA[
          In this text a formal language is presented which enables us to describe all domains of mathematics. It is a first order predicate calculus with equality based on the text \emph{Elements of Mathematical Logic} from P.~S.~Novikov. The logical axioms and basic rules originate from the book \emph{Principles of Mathematical Logic (Grundz{\"u}ge der theoretischen Logik)} (1928) by D.~Hilbert and W.~Ackermann.

          \par
          This document is not finished and is updated from time to time.
        ]]>
      </LATEX>
      <LATEX language="de">
        <![CDATA[
          In diesem Text wird eine formale Sprache vorgestellt in der alle Bereiche der Mathematik beschrieben werden können. Es handelt sich um eine Prädikatenlogik erster Stufe mit Gleichheit, die auf dem Text \emph{Grundz{\"u}ge der mathematischen Logik} von P.~S.~Novikov beruhen. Die logischen Axiome und Basisregeln haben ihren Ursprung in dem Buch \emph{Grundzüge der theoretischen Logik} (1928) von D.~Hilbert und W.~Ackermann.
         
          \par
          Dieses Dokument ist noch nicht fertiggestellt und wird von Zeit zu Zeit aktualisiert.
        ]]>
      </LATEX>
    </ABSTRACT>
    <AUTHORS>
      <AUTHOR email="michael@meyling.com">
        <NAME>
          <LATEX language="de">
            Michael Meyling
          </LATEX>
        </NAME>
      </AUTHOR>
    </AUTHORS>
    <USEDBY>
      <SPECIFICATION name="qedeq_set_theory_v1" ruleVersion="1.00.00">
        <LOCATIONS>
          <LOCATION value="."/>
        </LOCATIONS>
      </SPECIFICATION>
    </USEDBY>
  </HEADER>
  <CHAPTER noNumber="true">
    <TITLE>
      <LATEX language="en">
         Summary\index{summary}
      </LATEX>
      <LATEX language="de">
         Zusammenfassung\index{Zusammenfassung}
      </LATEX>
    </TITLE>
    <INTRODUCTION>
      <LATEX language="en">
        <![CDATA[

          The project \textbf{Hilbert II} deals with the formal presentation and documentation of mathematical knowledge. For this reason \textbf{Hilbert II} provides a program suite to accomplish that tasks. The concrete documentation of mathematical basics is also a purpose of this project.   
          For further informations about the \textbf{Hilbert II} project see under \url{http://www.qedeq.org}.

          \par
          This document describes the logical axioms and the rules and meta rules that are used to derive new propositions.

          \par
          The presentation is axiomatic and in a formal form. A formal calculus is given that enables us to derive all true formulas. Additional derived rules, theorems, definitions, abbreviations and syntax extensions basically correspond with the mathematical practice.

          \par
          This document is also written in a formal language, the original text is a XML file with a syntax defined by the XSD \url{http://www.qedeq.org/current/xml/qedeq.xsd}.

          \par
          This document is work in progress and is updated from time to time. Especially at the locations marked by {\glqq+++\grqq} additions or changes will take place.

        ]]>
      </LATEX>
      <LATEX language="de">
        <![CDATA[

          Das Projekt \textbf{Hilbert II} beschäftigt sich mit der formalen Darstellung und Dokumentation von mathematischem Wissen. Dazu stellt \textbf{Hilbert II} eine Programmsuite zur Lösung der damit zusammenhängenden Aufgaben bereit. Auch die konkrete Dokumentation mathematischen Grundlagenwissens mit diesen Hilfsmitteln gehört zum Ziel dieses Projekts. 
          Für weitere Informationen über das Projekt \textbf{Hilbert II} siehe auch unter \url{http://www.qedeq.org}.

          \par
          Dieses Dokument beschreibt die logischen Axiome, Schluss- und Metaregeln mit denen logische Schlüsse durchgeführt werden können.

          \par
          Die Darstellung erfolgt in axiomatischer Weise und in formaler Form. Dazu wird ein Kalkül angegeben, der es gestattet alle wahren Formeln abzuleiten. Weitere abgeleitete Regeln, Sätze, Definitionen, Abkürzungen und Syntaxerweiterungen entsprechen im Wesentlichen der mathematischen Praxis.

          \par
          Dieses Dokument liegt auch selbst in einer formalen Sprache vor, der Ursprungstext ist eine XML-Datei, deren Syntax mittels der XSD \url{http://www.qedeq.org/current/xml/qedeq.xsd} definiert wird.

          \par
          Dieses Dokument ist noch sehr in Arbeit und wird von Zeit zu Zeit aktualisiert. Insbesondere werden an den durch {\glqq+++\grqq} gekennzeichneten Stellen noch Ergänzungen oder Änderungen vorgenommen.

        ]]>
      </LATEX>
    </INTRODUCTION>
  </CHAPTER>
  <CHAPTER noNumber="true">
    <TITLE>
      <LATEX language="en">
         Foreword
      </LATEX>
      <LATEX language="de">
         Vorwort
      </LATEX>
    </TITLE>
    <INTRODUCTION>
      <LATEX language="en">
        <![CDATA[

          The whole mathematical universe can be unfolded by set--theoretic means. Beside the set--theoretic axioms only logical axioms and rules are required. These elementary basics are sufficient to define the most complex mathematical structures and enable us to prove propositions for those structures. This approach can be fully formalized and can be reduced to simple manipulations of character strings. The semantical interpretation of these character strings represent the mathematical universum.

          \par
          It is more than convenient to introduce abbreviations and use further derivation rules. But these comforts could be eliminated and replaced by the basic terms at any time\footnote{At least this is theoretically possible. This transformation is not in each case practically realizable due to restrictions in time and space. For example it is not possible to write down the
          natural number $1,000,000,000$ completely in set notation.}.

          \par
          This project has its source in a childhood dream to undertake a formalization of mathematics. In the meantime the technical possibilities are highly developed so that a realization seems within reach.
          
          \par
          Special thanks go to the professors \emph{W.~Kerby} and \emph{V.~Günther} of the university of Hamburg for their inspiring lectures about logic and axiomatic set theory. Without these important impulses this project would not exist.
          
          \par
          I am deeply grateful to my wife \emph{Gesine~Dräger} and our son \emph{Lennart} for their support and patience.          

          \par
          \vspace*{1cm} Hamburg, december, 2010 \\
          \hspace*{\fill} Michael Meyling

        ]]>
      </LATEX>
      <LATEX language="de">
        <![CDATA[

          Das ganze Universium der Mathematik kann mit den Mitteln der Mengenlehre entfaltet werden. Außer den Axiomen der Mengenlehre werden dazu nur noch logische Axiome und Regeln benötigt. Diese elementaren Grundlagen genügen, um die komplexesten mathematischen Strukturen zu definieren und Sätze über solche Strukturen beweisen zu können. Dieses Vorgehen lässt 
          sich vollständig formalisieren und auf die einfache Manipulation von Zeichenketten zurückführen. Die inhaltliche Deutung der Zeichenfolgen stellt dann das mathematische Universum dar.

          \par
          Dabei ist es natürlich mehr als nur bequem, Abkürzungen einzuführen und weitere abgeleitete Regeln zu verwenden. Diese Bequemlichkeiten können aber jederzeit\footnote{Zumindest ist eine solche Rückführung theoretisch immer möglich. Praktisch kann sie jedoch an der Endlichkeit der zur Verfügung stehenden Zeit und des nutzbaren Raums scheitern. So wird es 
          sicherlich nicht möglich sein, die natürliche Zahl $1.000.000.000$ in Mengenschreibweise anzugeben.} eliminiert und durch die grundlegenden Begrifflichkeiten ersetzt werden.

          \par
          Dieses Projekt entspringt meinem Kindheitstraum eine solche Formalisierung konkret vorzunehmen. Inzwischen sind die technischen Möglichkeiten so weit entwickelt, dass eine Realisierung möglich erscheint.

          \par
          Dank gebührt den Professoren \emph{W.~Kerby} und \emph{V.~Günther} der Hamburger Universität für ihre inspirierenden Vorlesungen zu den Themen Logik und Axiomatische Mengenlehre. Ohne diese entscheidenden Impulse hätte es dieses Projekt nie gegeben.

          \par
          Besonderer Dank geht an meine Frau \emph{Gesine~Dräger} und unseren Sohn \emph{Lennart} für ihre Unterstützung und ihr Verständnis für ihnen fehlende Zeit -- wobei der Verständnisgrad unseres Kleinkinds vielleicht noch nicht so stark ausgeprägt ist.

          \par
          \vspace*{1cm} Hamburg, Dezember 2010 \\
          \hspace*{\fill} Michael Meyling

        ]]>
      </LATEX>
    </INTRODUCTION>
  </CHAPTER>
  <CHAPTER noNumber="true">
    <TITLE>
      <LATEX language="en">
         Introduction
      </LATEX>
      <LATEX language="de">
         Einleitung
      </LATEX>
    </TITLE>
    <INTRODUCTION>
      <LATEX language="en">
        <![CDATA[
          At the beginning we quote \emph{D. Hilbert} from the lecture {\glqq The Logical Basis of Mathematics\grqq}, September 
          1922\footnote{Lecture given at the Deutsche Naturforscher-Gesellschaft, September 1922.}.

          \par
          \begin{quote} {
          \glqq The fundamental idea of my proof theory is the following:
          
          \par
          All the propositions that constitute in mathematics are converted into formulas, so that mathematics proper becomes all inventory of formulas. These differ from the ordinary formulas of mathematics only in that, besides the ordinary signs, 
          the logical signs especially {\glqq implies\grqq} ($\rightarrow$) and for {\glqq not\grqq} ($\bar{\quad}$) occur in them. 
          Certain formulas, which serve as building blocks for the formal edifice of mathematics, are called axioms. A proof is an array that must be given as such to our perceptual intuition of it of inferences according to the schema\\
          \begin{eqnarray*}
          & A & \\
          & A \rightarrow B& \\
          \cline{2-3}
           & B &
          \end{eqnarray*}
          where each of the premises, that is, the formulae, $A$ and $A \rightarrow B$ in the array either is an axiom or directly from an axiom by substitution, or else coincides with the end formula $B$ of an inference occurring earlier in the proof or results from it by substitution. A formula is said to be provable if it is either an axiom or the end formula of a proof.\grqq}
          \end{quote}

          \par
          At the beginning there is logic. Logic is the analysis of methods of reasoning. It helps to derive new propositions from already given ones. Logic is universally applicable.

          \par
          In the 1928 published book \emph{Grundzüge der theoretischen Logik} (Principles of Theoretical Logic) \emph{D.~Hilbert} and \emph{W.~Ackermann} formalized propositional calculus in a way that build the basis for the logical system used here. 1959 \emph{P.~S.~Novikov} specified a refined axiom and rule system for predicate calculus.
          
          \par
          In this text we present a first order predicate calculus with identity and functors that is the starting point for the development of the mathematical theory. Only the results without any proofs and in short form are given in the following.\footnote{If there is time proofs will be added.}
          
        ]]>
      </LATEX>
      <LATEX language="de">
        <![CDATA[
          An den Anfang sei ein Zitat aus einem von \emph{D. Hilbert} im September 1922 gehaltenen Vortrag\footnote{Vortrag, gehalten in der Deutschen Naturforscher-Gesellschaft. September 1922.} mit dem programmatischen Titel {\glqq Die logischen Grundlagen der Mathematik\grqq} gesetzt.

          \par
          \begin{quote} {
          \glqq Der Grundgedanke meiner Beweistheorie ist folgender:
          \par
          Alles, was im bisherigen Sinne die Mathematik ausmacht, wird streng formalisiert, so daß die eigentliche Mathematik oder die Mathematik in engerem Sinne zu einem Bestande an Formeln wird. Diese unterscheiden sich von den gewöhnlichen Formeln der Mathematik nur dadurch, daß außer den gewöhnlichen Zeichen noch die logischen Zeichen, insbesondere die für {\glqq folgt\grqq} ($\rightarrow$) und für {\glqq nicht\grqq} ($\bar{\quad}$) darin vorkommen. Gewisse Formeln, die als Bausteine des formalen Gebäudes der Mathematik dienen, werden Axiome genannt. Ein Beweis ist die Figur, die uns als solche anschaulich vorliegen muß; er besteht aus Schlüssen vermöge des Schlußschemas\\
          \begin{eqnarray*}
          & A & \\
          & A \rightarrow B& \\
          \cline{2-3}
           & B &
          \end{eqnarray*}
          wo jedesmal die Prämissen, d.~h. die betreffenden Formeln $A$ und $A \rightarrow B$ jede entweder ein Axiom ist bzw. direkt durch Einsetzung aus einem Axiom entsteht oder mit der Endformel $B$ eines Schlusses übereinstimmt, der vorher im Beweise vorkommt bzw. durch Einsetzung aus einer solchen Endformel entsteht. Eine Formel soll beweisbar heißen, wenn sie entweder ein Axiom ist bzw. durch Einsetzen aus einem Axiom entsteht oder die Endformel eines Beweises ist.\grqq}
          \end{quote}

          \par
          Am Anfang steht die Logik. Sie stellt das Rüstzeug zur Argumentation bereit. Sie hilft beim Gewinnen von neuen Aussagen aus bereits vorhandenen. Sie ist universell anwendbar. 
          
          \par
          In dem 1928 erschienenen Buch \emph{Grundzüge der theoretischen Logik} formulierten \emph{D.~Hilbert} und \emph{W.~Ackermann} ein axiomatisches System der Aussagenlogik, welches die Basis für das hier verwendete bildet. Durch das von \emph{P.~S.~Novikov} 1959 angegebene Axiomensystem und Regelwerk der Prädikatenlogik wird das System verfeinert.
          
          \par
          In diesem Text wird ein Prädikatenkalkül erster Stufe mit Identität und Funktoren vorgestellt, der die Grundlagen für die Entwicklung der mathematischen Theorie schafft. Es werden im Folgenden nur die Ergebnisse ohne weitere Beweise und in knapper Form präsentiert.\footnote{Die Beweise werden zu einem späteren Zeitpunkt ergänzt.}
        ]]>
      </LATEX>
    </INTRODUCTION>
  </CHAPTER>
  <CHAPTER>
    <TITLE>
      <LATEX language="en">
         Language
      </LATEX>
      <LATEX language="de">
         Sprache
      </LATEX>
    </TITLE>
    <INTRODUCTION>
      <LATEX language="en">
        <![CDATA[
          In this chapter we define a formal language to express mathematical propositions in a very precise way. Although this document describes a very formal approach to express mathematical content it is not sufficent to serve as a definition for an computer readable document format. Therefore such an extensive specification has to be done elsewhere. The choosen format is the \emph{Extensible Markup Language} abbreviated \emph{XML}. XML is a set of rules for encoding documents electronically.\footnote{See \url{http://www.w3.org/XML/} for more information.}
          The according formal syntax specification can be found at \url{http://www.qedeq.org/current/xml/qedeq.xsd}.
          It specifies a complete mathematical document format that enables the generation of \LaTeX books and makes automatic proof checking possible. 
          Further syntax restrictions and some explanations can be found at \url{http://www.qedeq.org/current/doc/project/qedeq_logic_language_en.pdf}.
          %%% TODO explain XSD, XML etc.

          \par          
          Even this document is (or was generated) from an XML file that can be found here: \url{http://wwww.qedeq.org/0_04_03/doc/math/qedeq_logic_v1.xml}.
          But now we just follow the traditional mathematical way to present the elements of mathematical logic.
        ]]>
      </LATEX>
      <LATEX language="de">
        <![CDATA[
          Um mathematische Aussagen präzise formulieren zu können, wird in diesem Kapitel eine formale Sprache definiert. Obgleich dieses Dokument mathematischen Inhalt sehr formal beschreibt, reicht es nicht aus um als Definition für ein computerlesbares Dokumentformat zu dienen. Daher muss eine solch extensive Spezifikation an anderer Stelle erfolgen.
          Das dafür ausgewählte Format ist die \emph{Extensible Markup Language} abgekürzt \emph{XML}. XML beschreibt eine Menge von Regeln für den Aufbau elektronischer Dokumente.\footnote{Siehe \url{http://www.w3.org/XML/} für weitere Informationen.} Die daran ausgerichtete formale Syntaxspezifikation kann hier gelesen werden: \url{http://www.qedeq.org/current/xml/qedeq.xsd}.
          Damit wird ein mathematisches Dokumentenformat festgelegt, das die Erzeugung von \LaTeX Büchern und eine automatische Beweisüberprüfung ermöglicht. 
          Weitere Syntaxbeschränkungen und einige Erklärungen werden beschrieben in \url{http://www.qedeq.org/current/doc/project/qedeq_logic_language_en.pdf}.

          \par
          Auch dieses Dokument ist eine (oder wurde erzeugt aus einer) XML-Datei, die hier zu finden ist \url{http://wwww.qedeq.org/0_04_03/doc/math/qedeq_logic_v1.xml}.
          Aber nun folgen wir einfach dem traditionellen mathematischen Weg, die Anfangsgünde der mathematischen Logik vorzustellen.
        ]]>
      </LATEX>
    </INTRODUCTION>
    
    <SECTION>
      <TITLE>
        <LATEX language="en">
           Terms\index{term} and Formulas\index{formula}
        </LATEX>
        <LATEX language="de">
           Terme\index{Term} und Formeln\index{Formel}
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            We use the \emph{logical symbols} 
            $L = \{$ \mbox{`$\neg$'}, \mbox{`$\vee$'}, \mbox{`$\wedge$'}, \mbox{`$\leftrightarrow$'}, \mbox{`$\rightarrow$'}, \mbox{`$\forall$'}, \mbox{`$\exists$'} $\}$, the \emph{predicate constants}\index{predicate constant}\index{constant!predicate} $C = \{c^k_i~|~i, k \in \omega\}$, the \emph{function variables}\index{function variable}\index{variable!function}\footnote{Function variables are used for a shorter notation. For example writing an identity proposition $x = y \rightarrow f(x) = f(y)$. Also this introduction prepares for the syntax extension for functional classes.} $F = \{f^k_i~|~i, k \in \omega \land k > 0\}$, the \emph{function constants}\index{function constant}\index{constant!function}\footnote{Function constants are also introduced for convenience and are used for direct defined class functions. For example to define building of the power class operator, the union and intersection operator and the successor function. All these function constants can be interpreted as abbreviations.} $H = \{h^k_i~|~i, k \in \omega\}$, the \emph{subject variables}\index{subject variable}\index{variable!subject} $V = \{v_i~|~i \in \omega\}$, as well as
            \emph{predicate variables}\index{predicate variable}\index{variable!predicate} $P = \{p^k_i~|~i, k \in \omega\}$.\footnote{By $\omega$ we understand the natural numbers including zero. All involved symbols are pairwise disjoint. 
            Therefore we can conclude for example: $f^k_i = f^{k'}_{i'} \rightarrow (k = k' \land i = i')$ and $h^k_i \neq v_j$.} 
            For the \emph{arity}\index{arity} or \emph{rank}\index{rank} of an operator we take the upper index. The set of predicate variables with zero arity is also called set of \emph{proposition variables}\index{proposition variable}\index{variable!proposition} or \emph{sentence letters}\index{sentence letters}: $A := \{p_i^0~|~i \in \omega \}$.
            For subject variables we write short hand certain lower letters: \mbox{$v_1 = $ `$u$'}, \mbox{$v_2 = $ `$v$'}, 
            \mbox{$v_3 = $ `$w$'}, \mbox{$v_4 = $ `$x$'}, \mbox{$v_5 = $ `$y$'}, \mbox{$v_5 = $ `$z$'}.
            Furthermore we use the following short notations: for the predicate variables $p^n_1 = $ `$\phi$' und $p^n_2 = $ `$\psi$', where the appropriate arity $n$ is calculated by counting the subsequent parameters, for the proposition variables
            $a_1 = $ `$A$', $a_2 = $ `$B$' and $a_3 = $ `$C$', for the function variables: $f^n_1 = $ `$f$' und $f^n_2 = $ `$g$', where again the appropriate arity $n$ is calculated by counting the subsequent parameters.  All binary propositional operators are written in infix notation. Parentheses surrounding groups of operands and operators are necessary to indicate the 
            intended order in which operations are to be performed. E.~g. for the operator $\land$ with the parameters $A$ and $B$ we write $(A \land B)$.
            
            
            In the absence of parentheses the usual precedence rules determine the order of operations. Especially outermost parentheses are omitted. Also empty parentheses are stripped.
            
            \par
            The operators have the order of precedence described below (starting with the highest).
            $$
            \begin{array}{c}
              \neg, \forall, \exists  \\
              \land \\
              \lor \\
              \rightarrow, \leftrightarrow \\
            \end{array}
            $$

            \par
            The term \emph{term\index{term}} is defined recursively as follows:

            \begin{enumerate}
            \item Every subject variable is a term. 
            \item Let $i, k \in \omega$ and let $t_1$, \ldots, $t_k$ be terms. Then $h^k_i(t_1, \ldots, t_k)$ is a term and if $k > 0$, so $f^k_i(t_1, \ldots, t_k)$ is a term too.
            \end{enumerate}

            Therefore all zero arity function constants $\{h^0_i~|~i \in \omega\}$ are terms. They are called \emph{individual constants}\index{individual constant}\index{constant!individual}.\footnote{In an analogous manner subject variables might be defined as function variables of zero arity. Because subject variables play an important role they have their own notation.}

            \par
            We define a \emph{formula\index{formula}} and the relations \emph{free}\index{bound subject variable}\index{subject variable!free} and \emph{bound}\index{bound subject variable}\index{subject variable!bound} subject variable recursivly as follows:

            \begin{enumerate}
            
            \item Every proposition variable is a formula. Such formulas contain no free or bound subject variables.
            
            \item If $p^k$ is a predicate variable with arity $k$ and $c^k$ is a predicate constant with arity $k$ and $t_1, t_2, \ldots, t_k$ are terms, then $p^k(t_1, t_2, \ldots t_k)$ and $c^k(t_1, t_2, \ldots, t_k)$ are formulas. All subject variables that occur at least in one of $t_1, t_2, \ldots, t_k$ are free subject variables. Bound subject variables does not occur.\footnote{This second item includes the first one, which is only listed for clarity.} 
            
            \item Let $\alpha, \beta$ be formulas in which no subject variables occur bound in one formula and free in the other. Then $\neg \alpha$, $(\alpha \land \beta)$, $(\alpha \lor \beta)$, $(\alpha \rightarrow \beta)$ and $(\alpha \leftrightarrow \beta)$ are also formulas. Subject variables which occur free (respectively bound) in $\alpha$ or $\beta$ stay free (respectively bound).
            
            \item If in the formula $\alpha$ the subject variable $x_1$ occurs not bound\footnote{This means that $x_1$ is free in the formula or does not occur at all.}, then also $\forall x_1~\alpha$ and $\exists x_1~\alpha$ are formulas. The symbol $\forall$ is called \emph{universal quantifier}\index{universal quantifier}\index{quantifier!universal} and $\exists$ as
            \emph{existential quantifier}\index{existential quantifier}\index{quantifier!existential}.
            
            Except for $x_1$ all free subject variables of $\alpha$ stay free. All bound subject variables are still bound and additionally $x_1$ is bound too.
            
            \end{enumerate}
            
            All formulas that are only built by usage of 1. and 3. are called formulas of the \emph{propositional calculus}\index{propositional calculus}\index{calculus!propositional}.
            
            \par
            For each formula $\alpha$ the following proposition holds: the set of free subject variables is disjoint with the set of bound subject variables..\footnote{Other formalizations allow for example $\forall x_1~\alpha$ also if $x_1$ occurs already bound within $\alpha$. Also propositions like $\alpha(x_1)~\land~(\forall~x_1~\beta)$ are allowed. In this formalizations
            free and bound are defined for a single occurrence of a variable.}
            
            \par
            If a formula has the form $\forall x_1 ~ \alpha$ respectively $\exists x_1 ~ \alpha$ then the formula $\alpha$ is called the
            \emph{scope}\index{scope}\index{quantifier!scope} of the quantifier $\forall$ respectively $\exists$.
            
            \par
            All formulas that are used to build up a formula by 1. to 4. are called \emph{part formulas}\index{part formula}\index{formula!part}. 

          ]]>
        </LATEX>
        <LATEX language="de">
          <![CDATA[
          
            Als Symbole kommen die \emph{logischen Symbole} $L = \{$ \mbox{`$\neg$'}, \mbox{`$\vee$'}, \mbox{`$\wedge$'},             \mbox{`$\leftrightarrow$'}, \mbox{`$\rightarrow$'}, \mbox{`$\forall$'}, \mbox{`$\exists$'} $\}$, die 
            \emph{Prädikatenkonstanten}\index{Prädikatenkonstante}\index{Konstante!Prädikaten-} $C = \{c^k_i~|~i, k \in \omega\}$, die 
            \emph{Funktionsvariablen}\index{Funktionsvariablen}\index{Variable!Funktions-}\footnote{Funktionsvariablen dienen der einfacheren Notation und werden beispielsweise zur Formulierung eines identitätslogischen Satzes benötigt: $x = y \rightarrow f(x) = f(y)$. Ausserdem bereitet ihre Einführung die spätere Syntaxerweiterung zur Anwendung von funktionalen Klassen vor.} $F = \{f^k_i~|~i, k \in \omega \land k > 0\}$, die \emph{Funktionskonstanten}\index{Funktionskonstanten}\index{Konstante!Funktions-}\footnote{Funktionskonstanten dienen ebenfalls der Bequemlichkeit und werden später für direkt 
            definierte Klassenfunktionen verwendet. So zum Beispiel zur Potenzklassenbildung, zur Vereinigungsklassenbildung und für die
            Nachfolgerfunktion. All diese Funktionskonstanten können auch als Abkürzungen verstanden werden.}
            $H = \{h^k_i~|~i, k \in \omega\}$, die \emph{Subjektvariablen}\index{Subjektvariable}\index{Variable!Subjekt-} 
            $V = \{v_i~|~i \in \omega\}$, sowie die \emph{Prädikatenvariablen}\index{Prädikatenvariable}\index{Variable!Prädikaten-}
            $P = \{p^k_i~|~i, k \in \omega\}$ vor.\footnote{Unter $\omega$ werden die natürlichen Zahlen, die Null eingeschlossen, verstanden. Alle bei den Mengenbildungen beteiligten Symbole werden als paarweise verschieden vorausgesetzt. Das bedeutet z.~B.: $f^k_i = f^{k'}_{i'} \rightarrow (k = k' \land i = i')$ und $h^k_i \neq v_j$.} Unter der \emph{Stellenzahl} eines Operators wird der obere Index verstanden. Die Menge der nullstelligen Prädikatenvariablen wird auch als Menge der
            \emph{Aussagenvariablen}\index{Aussagenvariable}\index{Variable!Aussagen-} bezeichnet: $A := \{p_i^0~|~i \in \omega \}$. 
            Für die Subjektvariablen werden abkürzend auch bestimmte Kleinbuchstaben geschrieben. Die Kleinbuchstaben stehen für verschiedene Subjektvariablen: \mbox{$v_1 = $ `$u$'}, \mbox{$v_2 = $ `$v$'}, \mbox{$v_3 = $ `$w$'}, \mbox{$v_4 = $ `$x$'}, \mbox{$v_5 = $ `$y$'}, \mbox{$v_5 = $ `$z$'}. Weiter werden als Abkürzungen verwendet: für die Prädikatenvariablen $p^n_1 = $ `$\phi$' und $p^n_2 = $ `$\psi$', wobei die jeweilige Stellenanzahl $n$ aus der Anzahl der nachfolgenden Parameter ermittelt wird, für die Aussagenvariablen $a_1 = $ `$A$', $a_2 = $ `$B$' und $a_3 = $ `$C$'. Als Abkürzungen für Funktionsvariablen wird festgelegt $f^n_1 = $ `$f$' und $f^n_2 = $ `$g$', wobei wiederum die jeweilige Stellenanzahl $n$ aus der Anzahl der nachfolgenden Parameter ermittelt wird. Bei allen aussagenlogischen zwei\-stelligen Operatoren wird der leichteren Lesbarkeit wegen die Infixschreibweise benutzt, dabei werden die Symbole `(' und `)' verwandt. 
            D.~h. für den Operator $\land$ mit den Argumenten $A$ und $B$ wird $(A \land B)$ geschrieben. 
            Es gelten die üblichen Operatorprioritäten und die dazugehörigen Klammerregeln. Insbesondere die äußeren Klammern werden in der Regel weggelassen. Auch werden leere Klammern nicht geschrieben.

            \par
            Nachfolgend werden die Operatoren mit absteigender Priorität aufgelistet.
            $$
            \begin{array}{c}
              \neg, \forall, \exists  \\
              \land \\
              \lor \\
              \rightarrow, \leftrightarrow \\
            \end{array}
            $$

            \par
            Der Begriff \emph{Term\index{Term}} wird im Folgenden rekursiv definiert:

            \begin{enumerate}
            \item Jede Subjektvariable ist ein Term. \item Seien $i, k \in \omega$ und $t_1$, \ldots, $t_k$ Terme. Dann ist auch $h^k_i(t_1, \ldots, t_k)$ und falls $k > 0$, so auch $f^k_i(t_1, \ldots, t_k)$ ein Term.
            \end{enumerate}

            Alle nullstelligen Funktionskonstanten $\{h^0_i~|~i, \in \omega\}$ sind demzufolge Terme, sie werden auch 
            \emph{Individuenkonstanten}\index{Individuenkonstante}\index{Konstante!Individuen-} genannt.\footnote{Analog dazu könnten Subjektvariablen auch als nullstellige Funktionsvariablen definiert werden. Da die Subjektvariablen jedoch eine hervorgehobene Rolle spielen, werden sie auch gesondert bezeichnet.}

            \par
            Die Begriffe \emph{Formel\index{Formel}}, \emph{freie\index{freie Subjektvariable}\index{Subjektvariable!freie}} und 
            \emph{gebundene\index{gebundene  Subjektvariable}\index{Subjektvariable!gebundene}} Subjektvariable werden rekursiv wie folgt definiert:

            \begin{enumerate}
            
            \item Jede Aussagenvariable ist eine Formel, solche Formeln enthalten keine freien oder gebundenen Subjektvariablen. 
            \item Ist $p^k$ eine $k$-stellige Prädikatenvariable und $c^k$ eine $k$-stellige Prädikatenkonstante und sind $t_1, t_2, \ldots, t_k$ Terme, so sind $p^k(t_1, t_2, \ldots t_k)$ und $c^k(t_1, t_2, \ldots, t_k)$ Formeln. Dabei gelten alle in 
            $t_1, t_2, \ldots, t_k$ vorkommenden Subjektvariablen als freie Subjektvariablen, gebundene Subjektvariablen kommen nicht 
            vor.\footnote{Dieser zweite Punkt umfasst den ersten, welcher nur der Anschaulichkeit wegen extra aufgeführt ist.} 
            
            \item Es seien $\alpha, \beta$ Formeln, in denen keine Subjektvariablen vorkommen, die in einer Formel gebunden und in der anderen frei sind. Dann sind auch $\neg \alpha$, $(\alpha \land \beta)$, $(\alpha \lor \beta)$, $(\alpha \rightarrow \beta)$, $(\alpha \leftrightarrow \beta)$ Formeln. Subjektvariablen, welche in $\alpha$ oder $\beta$ frei (bzw. gebunden) vorkommen, bleiben frei (bzw. gebunden).
            
            \item Falls in der Formel $\alpha$ die Subjektvariable $x_1$ nicht gebunden vorkommt\footnote{D.~h. $x_1$ kommt höchstens frei vor.}, dann sind auch $\forall x_1~\alpha$ und $\exists x_1~\alpha$ Formeln. Dabei wird $\forall$ als
            \emph{Allquantor}\index{Allquantor}\index{Quantor!All-} und $\exists$ als \emph{Existenzquantor}\index{Existenzquantor}\index{Quantor!Existenz-} bezeichnet. Bis auf $x_1$ bleiben alle freien Subjektvariablen von $\alpha$ auch frei, und zu den gebundenen Subjektvariablen von $\alpha$ kommt $x_1$ hinzu. 
            
            \end{enumerate}
            Alle Formeln die nur durch Anwendung von 1. und 3. gebildet werden, heißen Formeln der \emph{Aussagenalgebra}. 
            
            \par
            Es gilt für jede Formel $\alpha$: die Menge der freien und der gebundenen Subjektvariablen von $\alpha$ sind disjunkt.\footnote{Andere Formalisierungen erlauben z.~B. $\forall x_1~\alpha$ auch dann, wenn $x_1$ schon in $\alpha$ gebunden vorkommt. Auch Ausdrücke wie $\alpha(x_1)~\land~(\forall~x_1~\beta)$ sind erlaubt. Es wird dann
            für ein einzelnes Vorkommen einer Variablen definiert, ob es sich um ein freies oder gebundenes Vorkommen handelt.}
            
            \par
            Falls eine Formel die Gestalt $\forall x_1 ~ \alpha$ bzw. $\exists x_1 ~ \alpha$ besitzt, dann heißt die Formel $\alpha$ der
            \emph{Wirkungsbereich} des Quantors $\forall$ bzw. $\exists$.
            
            \par
            Alle Formeln, die beim Aufbau einer Formel mittels 1. bis 4. benötigt werden, heißen \emph{Teilformeln}.

          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
  </CHAPTER>

  <CHAPTER>
    <TITLE>
      <LATEX language="en">
         Axioms and Rules of Inference
      </LATEX>
      <LATEX language="de">
         Axiome und Schlussregeln
      </LATEX>
    </TITLE>
    <INTRODUCTION>
      <LATEX language="en">
        <![CDATA[
          We now state the system of axioms for the predicate calculus and present the rules for obtaining new formulas from them.
        ]]>
      </LATEX>
      <LATEX language="de">
        <![CDATA[
          Nun geben wir das Axiomensystem für die Prädikatenlogik an und formulieren die Regeln um daraus neue Formeln zu gewinnen.
        ]]>
      </LATEX>
    </INTRODUCTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">
           Axioms\index{axioms!of predicate calculus}\index{predicate calculus!axioms}
        </LATEX>
        <LATEX language="de">
           Axiome\index{Axiome!der Prädikatenlogik}\index{Prädikatenlogik!Axiome der}
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            The language of our calculus bases on the formalizations of \emph{D.~Hilbert}, \emph{W.~Ackermann}\cite{hilback}, \emph{P.~Bernays} and \emph{P.~S.~Novikov}\cite{novikov}. New rules can be derived from the herein presented. Only these meta rules lead to a smooth flowing logical argumentation.
          
           \par
            We want to present the axioms, definitions and rules in an syntactical manner but to motivate the choosen form we already give some semantical \emph{interpretations}.

            \par
            The logical operators of propositional calculus \mbox{`$\neg$'}, \mbox{`$\vee$'}, \mbox{`$\wedge$'}, \mbox{`$\rightarrow$'} and \mbox{`$\leftrightarrow$'} combine arbitrary \emph{propositions} to new propositions.
            A proposition is a statement that affirms or denies something and is either {\glqq true\grqq} or {\glqq false\grqq} (but not both).\footnote{Later on we will define the symbols $\top$ and $\bot$ as truth values.}
          ]]>
        </LATEX>
        <LATEX language="de">
          <![CDATA[
            
            Die Grundlagen der bei \textbf{Hilbert II} verwendeten Logik werden hier zusammengestellt. Die folgende Kalkülsprache und ihre Axiome basieren auf den Formulierungen von \emph{D.~Hilbert}, \emph{W.~Ackermann}\cite{hilback}, \emph{P.~Bernays} und \emph{P.~S.~Novikov}\cite{novikov}. Aus den hier angegebenen logischen Axiomen und den elementaren Schlussregeln können weitere Gesetzmäßigkeiten abgeleitet werden. Erst diese neuen Metaregeln führen zu einer komfortablen logischen Argumentation.
            
            \par
            Die Axiome, Definitionen und Regeln werden in syntaktischer Weise vorgestellt, aber um die gewählte Form zu motivieren, geben wir bereits einige semantische \emph{Interpretationen}.
            
            \par
            Die aussagenlogischen Operatoren \mbox{`$\neg$'}, \mbox{`$\vee$'}, \mbox{`$\wedge$'}, \mbox{`$\rightarrow$'} und \mbox{`$\leftrightarrow$'} verknüpfen beliebige \emph{Aussagen} zu neuen Aussagen. 
            Dabei verstehen wir unter einer Aussage eine Größe, die nur den Wert {\glqq wahr\grqq} und {\glqq falsch\grqq} annehmen kann.\footnote{Später werden wir für die Wahrheitswerte die Symbole $\top$ und $\bot$ definieren.}
          ]]>
        </LATEX>
      </INTRODUCTION>
      <SUBSECTIONS>

        <SUBSECTION>
          <TEXT>
            <LATEX language="en">
              <![CDATA[
                The binary operator \mbox{`$\vee$'} (logical disjunction) combines the two propositions $\alpha$ and $\beta$ into the new proposition $\alpha \vee \beta$. It results in true if at least one of its operands is true.

                \par
                The unary operator \mbox{`$\neg$'} (logical negation) changes the truth value of a proposition $\alpha$. $\neg \alpha$ has a value of true when its operand is false and a value of false when its operand is true. 

                \par
                The \emph{logical implication} (\emph{if \ldots then}) the, \emph{logical conjunction} (\emph{and}) and the \emph{logical equivalence} (\emph{logical biconditional}) are defined as abbreviations.\footnote{Actually the symbols $\wedge, \rightarrow, 
                \leftrightarrow$ are defined later on and are a syntax extension. But for convenience these symbols are already part of the logical language.}
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Der zweistellige Operator \mbox{`$\vee$'} (Oder-Verknüpfung) legt für die Aussagen $\alpha$ und $\beta$ die neue Aussage 
                $\alpha \vee \beta$ fest. Sie ist dann und nur dann wahr, wenn wenigstens eine der ursprünglichen Aussagen wahr ist.

                \par
                Durch den einstelligen Operator \mbox{`$\neg$'} wird zu einer Aussage $\alpha$ ihre \emph{Negation} definiert. $\neg \alpha$ ist falsch, wenn $\alpha$ wahr ist und wahr wenn $\alpha$ falsch ist.
            
                \par
                Die Implikation, die Und-Verknüpfung und die logische Äquivalenz werden als Abkürzungen definiert.\footnote{Eigentlich werden die Abkürzungssymbole $\wedge, \rightarrow, \leftrightarrow$ erst an dieser Stelle definiert und erweitern die Sprachsyntax. Aus Bequemlichkeitsgründen wurden diese Symbole bereits als logische Symbole angegeben.}
              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>
        <SUBSECTION>
          <TEXT>
            <LATEX language="en">
              <![CDATA[
                The logical implication (`if \ldots then') could be defined as follows.
                $$\alpha \rightarrow \beta\ :\leftrightarrow \ \neg \alpha\ \lor\ \beta$$
                
                \par
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Die logische Implikation ({\glqq wenn \ldots dann\glqq}) kann wie folgt definiert werden.
                $$\alpha \rightarrow \beta\ :\leftrightarrow \ \neg \alpha\ \lor\ \beta$$
              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>

        <SUBSECTION>
          <TEXT>
            <LATEX language="en">
              <![CDATA[
                The logical conjunction (`and') could be defined with de Morgan.
                $$\alpha \land \beta\ :\leftrightarrow \ \neg (\neg \alpha\ \lor\ \neg \beta)$$
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Definition der Und-Verknüpfung mittels De-Morgan.
                $$\alpha \land \beta\ :\leftrightarrow \ \neg (\neg \alpha\ \lor\ \neg \beta)$$
              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>

        <SUBSECTION>
          <TEXT>
            <LATEX language="en">
              <![CDATA[
                The logical equivalence (`iff') is defined as usual.
                $$\alpha \leftrightarrow \beta\ :\leftrightarrow \ (\alpha\ \rightarrow\ \beta)\ \land\ (\beta\ \rightarrow\ \alpha)$$
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Die logische Äquivalenz ({\glqq genau dann, wenn\grqq}) wird wie 
                üblich definiert.
                $$\alpha \leftrightarrow \beta\ :\leftrightarrow \ (\alpha\ \rightarrow\ \beta)\ \land\ (\beta\ \rightarrow\ \alpha)$$
              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>

        <NODE id="axiom:disjunction_idempotence">
          <NAME>
            <LATEX language="en">axiom of disjunction idempotence</LATEX>
            <LATEX language="de">Axiom der Oder-Kürzung</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Disjunction Idempotence\index{axiom!of disjunction idempotence}</LATEX>
            <LATEX language="de">Oder-Kürzung\index{Axiom!der Oder-Kürzung}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
                <![CDATA[
              Now we come to the first axiom of propositional calculus. This axiom 
              enables us to get rid of an unnecessary disjunction. 
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Nun folgt unser erstes Axiom der Aussagenlogik. Mithilfe dieses 
                Axioms können überflüssige Oder-Verknüpfungen entfernt werden.
              ]]>
            </LATEX>
          </PRECEDING>
          <AXIOM>
            <FORMULA>
              <IMPL>
                <OR>
                  <PREDVAR id="A" />
                  <PREDVAR id="A" />
                </OR>
                <PREDVAR id="A" />
              </IMPL>
            </FORMULA>
          </AXIOM>
        </NODE>
        <NODE id="axiom:disjunction_weakening">
          <NAME>
            <LATEX language="en">axiom of weakening</LATEX>
            <LATEX language="de">Axiom der Oder-Verdünnung</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Axiom of Weakening\index{axiom!of weakening}</LATEX>
            <LATEX language="de">Oder-Verdünnung\index{Axiom!der Oder-Verdünnung}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                If a proposition is true, any alternative may be added without making it false.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Wenn eine Aussage wahr ist, dann kann eine beliebige weitere Aussage mittels Oder-Verknüpfung hinzugefügt werden, ohne dass die Aussage falsch wird.
              ]]>
            </LATEX>
          </PRECEDING>
          <AXIOM>
            <FORMULA>
              <IMPL>
                <PREDVAR id="A" />
                <OR>
                  <PREDVAR id="A" />
                  <PREDVAR id="B" />
                </OR>
              </IMPL>
            </FORMULA>
          </AXIOM>
        </NODE>
        
        <NODE id="axiom:disjunction_commutative">
          <NAME>
            <LATEX language="en">commutativity of the disjunction</LATEX>
            <LATEX language="de">Kommutativgesetz der Oder-Verknüpfung</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Commutativity of the Disjunction\index{axiom!of weakening}</LATEX>
            <LATEX language="de">Oder-Vertauschung\index{Axiom!der Oder-Vertauschung}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                 The disjunction should be commutative.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Die Oder-Verknüpfung soll kommutativ sein.
              ]]>
            </LATEX>
          </PRECEDING>
          <AXIOM>
            <FORMULA>
              <IMPL>
                <OR>
                  <PREDVAR id="A" />
                  <PREDVAR id="B" />
                </OR>
                <OR>
                  <PREDVAR id="B" />
                  <PREDVAR id="A" />
                </OR>
              </IMPL>
            </FORMULA>
          </AXIOM>
        </NODE>
        
        <NODE id="axiom:disjunction_addition">
          <NAME>
            <LATEX language="en">axiom of disunctive addition</LATEX>
            <LATEX language="de">Axiom der Oder-Vorsehung</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Disjunctive Addition\index{axiom!of disjunctive addition}</LATEX>
            <LATEX language="de">Oder-Vorsehung\index{Axiom!der Oder-Vorsehung}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                 An disjunction could be added at both side of an implication.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Eine Oder-Verknüpfung kann auf beiden Seiten einer Implikation hinzugefügt werden.
              ]]>
            </LATEX>
          </PRECEDING>
          <AXIOM>
            <FORMULA>
              <IMPL>
                <IMPL>
                  <PREDVAR id="A" />
                  <PREDVAR id="B" />
                </IMPL>
                <IMPL>
                  <OR>
                    <PREDVAR id="C" />
                    <PREDVAR id="A" />
                  </OR>
                  <OR>
                    <PREDVAR id="C" />
                    <PREDVAR id="B" />
                  </OR>
                </IMPL>
              </IMPL>
            </FORMULA>
          </AXIOM>
        </NODE>

        <NODE id="axiom:universalInstantiation">
          <NAME>
            <LATEX language="en">axiom of universal instantiation</LATEX>
            <LATEX language="de">Axiom der Spezialisierung</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Universal Instantiation\index{axiom!of universal instantiation}</LATEX>
            <LATEX language="de">Spezialisierung\index{Axiom!der Spezialisierung}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                If something is true for all $x$, it is true for any specific $y$.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Wenn ein Prädikat auf alle $x$ zutrifft, so trifft es auch auf ein beliebiges $y$ zu.
              ]]>
            </LATEX>
          </PRECEDING>
          <AXIOM>
            <FORMULA>
              <IMPL>
                <FORALL>
                  <VAR id="x" />
                  <PREDVAR id="\phi">
                    <VAR id="x" />
                  </PREDVAR>
                </FORALL>
                <PREDVAR id="\phi">
                  <VAR id="y" />
                </PREDVAR>
              </IMPL>
            </FORMULA>
          </AXIOM>
        </NODE>

        <NODE id="axiom:existencialGeneralization">
          <NAME>
            <LATEX language="en">axiom of existential generalization</LATEX>
            <LATEX language="de">Axiom der Existenz</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Existential Generalization\index{axiom!of existential generalization}</LATEX>
            <LATEX language="de">Existenz\index{Axiom!der Existenz}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                If a predicate holds for some particular $y$, then there is an $x$ for which the predicate holds.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Wenn ein Prädikat auf irgend ein $y$ zutrifft, so gibt es ein $x$, auf das es zutrifft.
              ]]>
            </LATEX>
          </PRECEDING>
          <AXIOM>
            <FORMULA>
              <IMPL>
                <PREDVAR id="\phi">
                  <VAR id="y" />
                </PREDVAR>
                <EXISTS>
                  <VAR id="x" />
                  <PREDVAR id="\phi">
                    <VAR id="x" />
                  </PREDVAR>
                </EXISTS>
              </IMPL>
            </FORMULA>
          </AXIOM>
        </NODE>

      </SUBSECTIONS>
    </SECTION>

    <SECTION>
      <TITLE>
        <LATEX language="en">
          Rules of Inference\index{rules!of predicate calculus}\index{rules!of inference}
        </LATEX>
        <LATEX language="de">
          Ableitungsregeln\index{Regeln!predikatenlogische}
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            The following rules of inference enable us to obtain new true formulas from the axioms that are assumed to be true. From these new formulas we derive further formulas. So we can successively extend the set of true formulas.
          ]]>
        </LATEX>
        <LATEX language="de">
          <![CDATA[
            Die im folgenden angegebenen Regeln ermöglichen uns aus den wahr angesehenen Axiomen neue wahre Formeln zu gewinnen. Aus diesen können wiederum weitere Formeln abgeleitet werden, so dass sich die Menge der wahren Formeln sukzessive erweitern lässt. 
          ]]>
        </LATEX>
      </INTRODUCTION>
      <SUBSECTIONS>

        <NODE id="rule:modusPonens">
          <NAME>
            <LATEX language="en">modus ponens</LATEX>
            <LATEX language="de">Modus Ponens</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Modus Ponens\index{Modus Ponens}</LATEX>
            <LATEX language="de">Abtrennung, Modus Ponens\index{Modus Ponens}\index{Abtrennungsregel}</LATEX>
          </TITLE>
          <RULE name="modusPonens">
            <DESCRIPTION>
              <LATEX language="en">
                <![CDATA[
                  If both formulas $\alpha$ and $\alpha \rightarrow \beta$ are true, then we can conclude that $\beta$ is true as well.  
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  Wenn $\alpha$ und $\alpha \rightarrow \beta$ wahre Formeln sind, dann ist auch $\beta$ eine wahre Formel.
                ]]>
              </LATEX>
            </DESCRIPTION>
          </RULE>
        </NODE>


        <NODE id="rule:replaceFree">
          <NAME>
            <LATEX language="en">replace free subject variable</LATEX>
            <LATEX language="de">Ersetzung für freie Subjektvariable</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Replace Free Subject Variable</LATEX>
            <LATEX language="de">Ersetzung für freie Subjektvariable</LATEX>
          </TITLE>
          <RULE name="replaceFree">
            <DESCRIPTION>
              <LATEX language="en">
                <![CDATA[
                  We start with a true formula.
                  A free subject variable may be replaced by an arbitrary term, provided that the substituted term contains no subject variable that have a bound occurrence in the original formula. All occurrences of the free variable must be simultaneously replaced.
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  Ausgehend von einer wahren Formel kann jede freie Subjektvariable durch einen Term ersetzt werden, der keine in der Formel bereits gebundenen Subjektvariablen enthält. Die Ersetzung muss durchgängig in der gesamten Formel erfolgen.
                ]]>
              </LATEX>
            </DESCRIPTION>
          </RULE>
          <SUCCEEDING>
            <LATEX language="en">
              <![CDATA[
                The prohibition to use subject variables within the term that occur bound in the original formula has two reasons. First it ensures that the resulting formula is well-formed. Secondly it preserves the validity of the formula. Let us look at the following derivation.
                
                \par
                \begin{tabularx}{\linewidth}{rclX}
                  $\forall x \ \exists y \ \phi(x, y)$ & $\rightarrow$ & $\exists y \ \phi(z,y)$ 
                    & with \qref{axiom:universalInstantiation} \\
                  $\forall x \ \exists y \ \phi(x, y)$ & $\rightarrow$ & $\exists y \ \phi(y,y)$ 
                    & forbidden replacement: $z$ in $y$, despite $y$ is already bound \\
                  $\forall x \ \exists y \ x \neq y$ & $\rightarrow$ & $\exists y \ \neq y$ 
                    & replace $\neq$ for $\phi$
                \end{tabularx}
                
                \par
                This last proposition is not valid in many models.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Das Verbot in dem Term Subjektvariablen zu verwenden, welche in der Originalformel gebunden vorkommen, dient nicht nur der Absicherung der Wohlgeformtheit, sondern besitzt auch eine inhaltliche Bedeutung. Dazu betrachten wir die folgende Ableitung.
                
                \par
                \begin{tabularx}{\linewidth}{rclX}
                  $\forall x \ \exists y \ \phi(x, y)$ & $\rightarrow$ & $\exists y \ \phi(z,y)$ 
                    & mit \qref{axiom:universalInstantiation} \\
                  $\forall x \ \exists y \ \phi(x, y)$ & $\rightarrow$ & $\exists y \ \phi(y,y)$ 
                    & verbotene Ersetzung: $z$ durch $y$, obwohl $y$ bereits gebunden \\
                  $\forall x \ \exists y \ x \neq y$ & $\rightarrow$ & $\exists y \ \neq y$ 
                    &  Einsetzung von $\neq$ für $\phi$
                \end{tabularx}
                
                \par
                Diese letzte Aussage ist in vielen Modellen nicht gültig.
              ]]>
            </LATEX>
          </SUCCEEDING>
        </NODE>

        <NODE id="rule:renameBound">
          <NAME>
            <LATEX language="en">rename bound subject variable</LATEX>
            <LATEX language="de">Umbenennung für gebundene Subjektvariable</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Rename Bound Subject Variable</LATEX>
            <LATEX language="de">Umbenennung für gebundene Subjektvariable</LATEX>
          </TITLE>
          <RULE name="renameBound">
            <DESCRIPTION>
              <LATEX language="en">
                <![CDATA[
                  We may replace a bound subject variable occurring in a formula by any other subject variable, provided that the new variable occurs not free in the original formula. If the variable to be replaced occurs in more than one scope, then the replacement needs to be made in one scope only.
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  Jede gebundene Subjektvariable kann in eine andere, nicht bereits frei vorkommende, Subjektvariable umbenannt werden. Falls über umzubenennende Variable mehrfach quantifiziert wird, dann braucht die Umbenennung nur im Wirkungsbereich eines bestimmten Quantors zu erfolgen.
                ]]>
              </LATEX>
            </DESCRIPTION>
          </RULE>
        </NODE>

        <NODE id="rule:replacePred">
          <NAME>
            <LATEX language="en">replace predicate variable</LATEX>
            <LATEX language="de">Einsetzung für Prädikatenvariable</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Replace Predicate Variable</LATEX>
            <LATEX language="de">Einsetzung für Prädikatenvariable</LATEX>
          </TITLE>
          <RULE name="replacePred">
            <DESCRIPTION>
            
              <LATEX language="en">
                <![CDATA[
                  Let $\alpha$ be a true formula that contains a predicate variable $p$ of arity $n$, let $x_1$, \ldots, $x_n$ be pairwise different subject variables and let $\beta(x_1, \ldots, x_n)$ be a formula where $x_1$, \ldots, $x_n$ are not bound. The formula $\beta(x_1, \ldots, x_n)$ must not contain all $x_1$, \ldots, $x_n$ as free subject variables. Furthermore it can also have other subject variables either free or bound.
                  
                  If the following conditions are fulfilled, then a replacement of all occurrences of $p(t_1, \ldots, t_n)$ each with appropriate terms $t_1$, \ldots, $t_n$ in $\alpha$ by $\beta(t_1, \ldots, t_n)$ results in another true formula.

                  \begin{itemize}

                  \item
                  the free variables of $\beta(x_1, \ldots, x_n)$ without $x_1$, \ldots, $x_n$ do not occur as bound variables in $\alpha$ 
                  
                  \item 
                  each occurrence of $p(t_1, \ldots, t_n)$ in $\alpha$ contains no bound variable of $\beta(x_1, \ldots, x_n)$ 

                  \item
                  the result of the substitution is a well-formed formula

                  \end{itemize}
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  Es sei $\alpha$ eine wahre Formel, die die $n$-stellige Prädikatenvariable $p$ enthält, $x_1$, \ldots, $x_n$ seien paarweise verschiedene Subjektvariable und $\beta(x_1, \ldots, x_n)$ eine beliebige Formel in der die Variablen $x_1$, \ldots, $x_n$ nicht gebunden sind. In der Formel $\beta(x_1, \ldots, x_n)$ müssen jedoch nicht alle $x_1$, \ldots, $x_n$ als freie Subjektvariable vorkommen. 
                  Weiterhin können auch noch weitere Variable frei oder gebunden vorkommen. 
                  
                  Wenn die folgenden Bedingungen erfüllt sind, dann kann durch die Ersetzung jedes Vorkommens von $p(t_1, \ldots, t_n)$ mit jeweils passenden Termen $t_1$, \ldots, $t_n$ in $\alpha$ durch $\beta(t_1, \ldots, t_n)$ eine weitere wahre Formel gewonnen werden.

                  \begin{itemize}

                  \item 
                  die freien Variablen von $\beta(x_1, \ldots, x_n)$ ohne $x_1$, \ldots, $x_n$ kommen nicht in $\alpha$ als gebundene Variablen vor
                  
                  \item
                  jedes Vorkommen von $p(t_1, \ldots, t_n)$ in $\alpha$ enthält keine gebundene Variable von $\beta(x_1, \ldots, x_n)$
                  
                  \item
                  das Ergebnis der Substitution ist eine wohlgeformte Formel

                  \end{itemize}
                ]]>
              </LATEX>

              <!-- TODO remove the following two entries -->
              
              <LATEX language="enold">
                <![CDATA[

                  Let $\alpha$ be a true formula that contains an predicate variable $p$ of arity $n$ and let $\beta(x_1, \ldots, x_n)$ be a formula with the free subject variables $x_1$, \ldots, $x_n$, that doesn't occur in $\alpha$.\footnote{The formula $\beta(x_1, \ldots, x_n)$ can have other free subject variables beside $x_1$, \ldots, $x_n$ .} If the following conditions are fulfilled, then a replacement of all occurrences of $p(t_1, \ldots, t_n)$ each with appropriate terms $t_1$, \ldots, $t_n$ in $\alpha$ by $\beta(t_1, \ldots, t_n)$ leads to another true formula.

                  \begin{itemize}

                  \item the free variables of $\alpha$ are disjoint with the bound variables of $\beta(x_1, \ldots, x_n)$ and the bound variables of $\alpha$ are disjoint with the free variables of $\beta(x_1, \ldots, x_n)$ 

                  \item if the occurrence of $p(t_1, \ldots, t_n)$ in $\alpha$ falls within the scope of a quantifier, then the variable it quantifies doesn't occur in $\beta(x_1, \ldots, x_n)$
                  
                  \end{itemize}
                ]]>
              </LATEX>
              <LATEX language="deold">
                <![CDATA[

                  Es sei $\alpha$ eine wahre Formel, die die $n$-stellige Prädikatenvariable $p$ enthält und $\beta(x_1, \ldots, x_n)$ eine beliebige Formel mit den freien Variablen $x_1$, \ldots, $x_n$, welche nicht in $\alpha$ vorkommen.\footnote{In der Formel $\beta(x_1, \ldots, x_n)$ können ausser den $n$ Subjektvariablen $x_1$, \ldots, $x_n$ noch weitere Variablen frei vorkommen.} Wenn die folgenden Bedingungen erfüllt sind, dann kann durch die Ersetzung jedes Vorkommens von $p(t_1, \ldots, t_n)$
                  mit jeweils passenden Termen $t_1$, \ldots, $t_n$ in $\alpha$ durch $\beta(t_1, \ldots, t_n)$ eine weitere wahre Formel gewonnen werden.

                  \begin{itemize}

                  \item die freien Variablen von $\alpha$ sind disjunkt zu den gebundenen Variablen von $\beta(x_1, \ldots, x_n)$ und die gebundenen Variablen von $\alpha$ disjunkt zu den freien Variablen von $\beta(x_1, \ldots, x_n)$ 

                  \item liegt das zu ersetzende $p(t_1, \ldots, t_n)$ in $\alpha$ im Wirkungsbereich eines Quantors, so kommt die
                  zugehörige Subjektvariable in $\beta(x_1, \ldots, x_n)$ nicht vor

                  \end{itemize}

                ]]>
              </LATEX>
            </DESCRIPTION>
          </RULE>
          <SUCCEEDING>
            <LATEX language="en">
              <![CDATA[
                See III \S 5 in \cite{hilback}.
                
                \par
                The prohibition to use additional subject variables within the replacement formula that occur bound in the original formula assurs that the resulting formula is well-formed. Furthermore it preserves the validity of the formla. Take a look at the following derivation.
                
                \par
                \begin{tabularx}{\linewidth}{rclX}
                  $ \phi(x)$                             & $\rightarrow$ & $\exists y \ \phi(y)$  
                    & with \qref{axiom:existencialGeneralization} \\
                  $ (\exists y \ y = y) \land \phi(x)$   & $\rightarrow$ & $\exists y \ \phi(y)$  
                    &  \\
                  $ \exists y \ (y = y \land \phi(x))$   & $\rightarrow$ & $\exists y \ \phi(y)$  
                    &  \\
                  $ \exists y \ (y = y \land x \neq y)$  & $\rightarrow$ & $\exists y \ y \neq y$  
                    & forbidden replacment: $\phi(x)$ by $x \neq y$, despite $y$ is already bound \\
                  $ \exists y \  x \neq y$  & $\rightarrow$ & $\exists y \ y \neq y$  
                    &
                \end{tabularx}
                
                \par
                The last proposition is not valid in many models.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
              
                Siehe III \S 5 in \cite{hilback}.
                
                \par
                Das Verbot in der Ersetzungsformel keine zusätzliche Subjektvariable zu verwenden, welche in der Originalformel gebunden vorkommt, hat nicht nur die Absicherung der Wohlgeformtheit zum Zweck. Es bewahrt auch die inhaltliche Gültigkeit. Dazu betrachten wir die folgende Ableitung.
                
                \par
                \begin{tabularx}{\linewidth}{rclX}
                  $ \phi(x)$                             & $\rightarrow$ & $\exists y \ \phi(y)$  
                    & mit \qref{axiom:existencialGeneralization} \\
                  $ (\exists y \ y = y) \land \phi(x)$   & $\rightarrow$ & $\exists y \ \phi(y)$  
                    &  \\
                  $ \exists y \ (y = y \land \phi(x))$   & $\rightarrow$ & $\exists y \ \phi(y)$  
                    &  \\
                  $ \exists y \ (y = y \land x \neq y)$  & $\rightarrow$ & $\exists y \ y \neq y$  
                    & verbotene Ersetzung: $\phi(x)$ durch $x \neq y$, obwohl $y$ bereits gebunden \\
                  $ \exists y \  x \neq y$  & $\rightarrow$ & $\exists y \ y \neq y$  
                    &
                \end{tabularx}
                
                \par
                Diese letzte Aussage ist in vielen Modellen nicht gültig.
              ]]>
            </LATEX>
          </SUCCEEDING>
        </NODE>

        <NODE id="rule:replaceFunct">
          <NAME>
            <LATEX language="en">replace function variable</LATEX>
            <LATEX language="de">Einsetzung für Funktionsvariable</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Replace Function Variable</LATEX>
            <LATEX language="de">Einsetzung für Funktionsvariable</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                Analogous to \qref{rule:replacePred} we can replace function variables too.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Analog zu Regel~\qref{rule:replacePred} können wir auch Funktionsvariablen ersetzen.
              ]]>
            </LATEX>
          </PRECEDING>
          <RULE name="replaceFunct">
            <DESCRIPTION>
              <LATEX language="en">
                <![CDATA[
                  Let $\alpha$ be an already proved formula that contains a function variable $\sigma$ of arity $n$, let $x_1$, \ldots, $x_n$ be pairwise different subject variables and let $\tau(x_1, \ldots, x_n)$ be an arbitrary term where $x_1$, \ldots, $x_n$ are not bound. 
                  The term $\tau(x_1, \ldots, x_n)$ must not contain all $x_1$, \ldots, $x_n$ as free subject variables. Furthermore it can also have other subject variables either free or bound. 
                  
                  If the following conditions are fulfilled we can obtain a new true formula by replacing each occurrence of $\sigma(t_1, \ldots, t_n)$ with appropriate terms $t_1$, \ldots, $t_n$ in $\alpha$ by $\tau(t_1, \ldots, t_n)$.
                  
                  \begin{itemize}
                  
                  \item 
                  the free variables of $\tau(x_1, \ldots, x_n)$ without $x_1$, \ldots, $x_n$ do not occur as bound variables in $\alpha$
                  
                  \item
                  each occurrence of $\sigma(t_1, \ldots, t_n)$ in $\alpha$ contains no bound variable of $\tau(x_1, \ldots, x_n)$
                  
                  \item
                  the result of the substitution is a well-formed formula
                                    
                  \end{itemize}
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                
                  Es sei $\alpha$ eine bereits bewiesene Formel, die die $n$-stellige Funktionsvariable $\sigma$ enthält, $x_1$, \ldots, $x_n$ seien paarweise verschiedene Subjektvariable und $\tau(x_1, \ldots, x_n)$ ein beliebiger Term in dem die Subjektvariablen $x_1$, \ldots, $x_n$ nicht gebunden sind. In dem Term $\tau(x_1, \ldots, x_n)$ müssen nicht alle $x_1$, \ldots, $x_n$ als freie Subjektvariable vorkommen. Weiterhin können auch noch  noch weitere Variable frei oder gebunden vorkommen.
                  
                  Wenn die folgenden Bedingungen erfüllt sind, dann kann durch die Ersetzung jedes Vorkommens von $\sigma(t_1, \ldots, t_n)$ mit jeweils passenden Termen $t_1$, \ldots, $t_n$ in $\alpha$ durch $\tau(t_1, \ldots, t_n)$ eine weitere wahre Formel gewonnen 
                  werden.
                  
                  \begin{itemize}
                  
                  \item
                  die freien Variablen von $\tau(x_1, \ldots, x_n)$ ohne $x_1$, \ldots, $x_n$ kommen in $\alpha$ nicht als gebundene Variablen vor
                  
                  \item
                  jedes Vorkommen von $\sigma(t_1, \ldots, t_n)$ in $\alpha$ enthält keine gebundene Variable von $\tau(x_1, \ldots, x_n)$
                  
                  \item
                  das Ergebnis der Substitution ist eine wohlgeformte Formel

                  \end{itemize}
                ]]>
              </LATEX>
            </DESCRIPTION>
          </RULE>
        </NODE>

        <NODE id="rule:universalGeneralization">
          <NAME>
            <LATEX language="en">universal generalization</LATEX>
            <LATEX language="de">Hintere Generalisierung</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Universal Generalization</LATEX>
            <LATEX language="de">Hintere Generalisierung\index{Generalisierung!hintere}</LATEX>
          </TITLE>
          <RULE name="universalGeneralization">
            <DESCRIPTION>
              <LATEX language="en">
                <![CDATA[
                  If $\alpha \rightarrow \beta(x_1)$ is a true formula and $\alpha$ does not contain the subject variable $x_1$, then $\alpha \rightarrow (\forall x_1~(\beta(x_1)))$ is a true 
                  formula too.
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  Wenn $\alpha \rightarrow \beta(x_1)$ eine wahre Formel ist und $\alpha$ die Subjektvariable $x_1$ nicht enthält, dann ist auch $\alpha \rightarrow (\forall x_1~(\beta(x_1)))$ 
                  eine wahre Formel.
                ]]>
              </LATEX>
            </DESCRIPTION>
          </RULE>
        </NODE>

        <NODE id="rule:existentialGeneralization">
          <NAME>
            <LATEX language="en">existential generalization</LATEX>
            <LATEX language="de">Vordere Partikularisierung</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Existential Generalization</LATEX>
            <LATEX language="de">Vordere Partikularisierung\index{Partikularisierung!vordere}</LATEX>
          </TITLE>
          <RULE name="existentialGeneralization">
            <DESCRIPTION>
              <LATEX language="en">
                <![CDATA[
                  If $\alpha(x_1) \rightarrow \beta$ is already proved to be true and $\beta$ does not contain the subject variable $x_1$, then $(\exists x_1~\alpha(x_1)) \rightarrow \beta$ is also a true formula.
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                
                  Wenn $\alpha(x_1) \rightarrow \beta$ eine wahre Formel ist und $\beta$ die Subjektvariable $x_1$ nicht enthält, dann ist auch $(\exists x_1~\alpha(x_1)) \rightarrow \beta$ eine wahre Formel.
                  
                ]]>
              </LATEX>
            </DESCRIPTION>
          </RULE>
        </NODE>

        <SUBSECTION>
          <TEXT>
            <LATEX language="en">
              <![CDATA[
                The usage and elimination of abbreviations and constants is also an inference rule. In many texts about mathematical logic these rules are not explicitly stated and this text is no exception. But in the exact QEDEQ format corresponding rules exist.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Die Auflösung und der Einsatz von Abkürzungen und Konstanten ist auch mit der Anwendung von Regeln verbunden. In vielen Texten zur mathematischen Logik werden diese Regeln nicht explizit formuliert, auch dieser Text geht darauf nicht weiter ein. In dem exakten QEDEQ-Format gibt es jedoch entsprechende Regeln.
              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>
      </SUBSECTIONS>
    </SECTION>

  </CHAPTER>

  <CHAPTER>
    <TITLE>
      <LATEX language="en">
         Derived Propositions
      </LATEX>
      <LATEX language="de">
         Abgeleitete Sätze
      </LATEX>
    </TITLE>
    <INTRODUCTION>
      <LATEX language="en">
        <![CDATA[
          Now we derive elementary propositions with the axioms and rules of inference of chapter~\ref{chapter4}.
        ]]>
      </LATEX>
      <LATEX language="de">
        <![CDATA[
          Mit den im Kapitel~\ref{chapter4} angegebenen Axiomen und Schlussregeln lassen sich elementare logische Gesetzmäßigkeiten ableiten.
        ]]>
      </LATEX>
    </INTRODUCTION>

    <SECTION>
      <TITLE>
        <LATEX language="en">
           Propositional Calculus
        </LATEX>
        <LATEX language="de">
           Aussagenlogik
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            At first we look at the propositional calculus.
          ]]>
        </LATEX>
        <LATEX language="de">
          <![CDATA[
            Zunächst behandeln wir die Aussagenlogik.
          ]]>
        </LATEX>
      </INTRODUCTION>
      <SUBSECTIONS>

        <NODE id="definition:True">
          <NAME>
            <LATEX language="en">true</LATEX>
            <LATEX language="de">wahr</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">True\index{true}</LATEX>
            <LATEX language="de">Wahr\index{wahr}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                To define the predicate \emph{true} we just combine a predicate and its negation.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Um das Prädikat \emph{wahr} zu definieren, kombinieren wir einfach ein Prädikat und seine Negation.
              ]]>
            </LATEX>
          </PRECEDING>
          <DEFINITION_PREDICATE arguments="0" name="TRUE">
            <LATEXPATTERN>\top</LATEXPATTERN>
            <FORMULA>
              <EQUI>
                <PREDCON ref="TRUE"/>
                <OR>
                  <PREDVAR id="A"/>
                  <NOT>
                    <PREDVAR id="A"/>
                  </NOT>
                </OR>
              </EQUI>
            </FORMULA>
          </DEFINITION_PREDICATE>
          <SUCCEEDING>
            <LATEX language="en">
              <![CDATA[
                For a precise definition we should have written something like $p^0_0 = \top$ and $\top :\leftrightarrow (A \wedge \not A)$.\footnote{In the deeper laying (see  \url{http://www.qedeq.org/current/doc/project/qedeq_logic_language_en.pdf}) formal language this predicate has the name \emph{TRUE} and zero arguments. So we just have to map names to natural numbers to fulfill the exact definition.} In the future we only write the symbol itself. It's arity should be evident from the formula.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Für eine exakte Definiton hätten wir eigentlich so etwas wie $p^0_0 = \top$ und $\top :\leftrightarrow (A \wedge \not A)$ schreiben müssen.\footnote{In der noch tiefer liegenden formalen Sprache (siehe  \url{http://www.qedeq.org/current/doc/project/qedeq_logic_language_en.pdf}) hat dieses Prädikat den Namen \emph{TRUE} und besitzt keine Argumente. Daher müssten wir nur die Namen auf die natürlichen Zahlen abbilden um der exakten Definition gerecht zu werden.} In Zukunft schreiben wir jedoch nur das Symbol. Die Stellenzahl sollte aus der Formel ersichtlich sein.
              ]]>
            </LATEX>
          </SUCCEEDING>
        </NODE>

        <NODE id="definition:False">
          <NAME>
            <LATEX language="en">false</LATEX>
            <LATEX language="de">falsch</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">False\index{false}</LATEX>
            <LATEX language="de">Falsch\index{falsch}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                For the predicate \emph{false} we just negate \emph{true}.\footnote{Analogous to the preceeding definition we can set $p^0_1 = \bot$}
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Für das Prädikat \emph{falsch} negieren wir einfach \emph{wahr}.\footnote{Analog zu der vorhergehenden Definition können wir festlegen $p^0_1 = \bot$}
              ]]>
            </LATEX>
          </PRECEDING>
          <DEFINITION_PREDICATE arguments="0" name="FALSE">
            <LATEXPATTERN>\bot</LATEXPATTERN>
            <FORMULA>
              <EQUI>
                <PREDCON ref="FALSE"/>
                <NOT>
                  <PREDCON ref="TRUE"/>
                </NOT>
              </EQUI>
            </FORMULA>
          </DEFINITION_PREDICATE>
        </NODE>

        <NODE id="theorem:propositionalCalculus">
          <NAME>
            <LATEX language="en">basic propositions</LATEX>
            <LATEX language="de">Elementare Sätze</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Basic Propositions\index{propositions!of propositional calculus}</LATEX>
            <LATEX language="de">Elementare Sätze\index{Sätze!der Aussagenlogik}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                We have the following basic propositions.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Wir haben die folgenden elementaren Aussagen.
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <AND>

                <PREDCON ref="TRUE" />

                <NOT>
                  <PREDCON ref="FALSE" />
                </NOT>

                <IMPL>
                  <PREDVAR id="A" />
                  <PREDVAR id="A" />
                </IMPL>

                <EQUI>
                  <PREDVAR id="A" />
                  <PREDVAR id="A" />
                </EQUI>

                <EQUI>
                  <OR>
                    <PREDVAR id="A" />
                    <PREDVAR id="B" />
                  </OR>
                  <OR>
                    <PREDVAR id="B" />
                    <PREDVAR id="A" />
                  </OR>
                </EQUI>

                <EQUI>
                  <AND>
                    <PREDVAR id="A" />
                    <PREDVAR id="B" />
                  </AND>
                  <AND>
                    <PREDVAR id="B" />
                    <PREDVAR id="A" />
                  </AND>
                </EQUI>

                <IMPL>
                  <AND>
                    <PREDVAR id="A" />
                    <PREDVAR id="B" />
                  </AND>
                  <PREDVAR id="A" />
                </IMPL>

                <EQUI>
                  <EQUI>
                    <PREDVAR id="A" />
                    <PREDVAR id="B" />
                  </EQUI>
                  <EQUI>
                    <PREDVAR id="B" />
                    <PREDVAR id="A" />
                  </EQUI>
                </EQUI>

                <EQUI>
                  <OR>
                    <PREDVAR id="A" />
                    <OR>
                      <PREDVAR id="B" />
                      <PREDVAR id="C" />
                    </OR>
                  </OR>
                  <OR>
                    <OR>
                      <PREDVAR id="A" />
                      <PREDVAR id="B" />
                    </OR>
                    <PREDVAR id="C" />
                  </OR>
                </EQUI>

                <EQUI>
                  <AND>
                    <PREDVAR id="A" />
                    <AND>
                      <PREDVAR id="B" />
                      <PREDVAR id="C" />
                    </AND>
                  </AND>
                  <AND>
                    <AND>
                      <PREDVAR id="A" />
                      <PREDVAR id="B" />
                    </AND>
                    <PREDVAR id="C" />
                  </AND>
                </EQUI>

                <EQUI>
                  <PREDVAR id="A" />
                  <OR>
                    <PREDVAR id="A" />
                    <PREDVAR id="A" />
                  </OR>
                </EQUI>

                <EQUI>
                  <PREDVAR id="A" />
                  <AND>
                    <PREDVAR id="A" />
                    <PREDVAR id="A" />
                  </AND>
                </EQUI>

                <EQUI>
                  <PREDVAR id="A" />
                  <NOT>
                    <NOT>
                      <PREDVAR id="A" />
                    </NOT>
                  </NOT>
                </EQUI>

                <EQUI>
                  <IMPL>
                    <PREDVAR id="A" />
                    <PREDVAR id="B" />
                  </IMPL>
                  <IMPL>
                    <NOT>
                      <PREDVAR id="B" />
                    </NOT>
                    <NOT>
                      <PREDVAR id="A" />
                    </NOT>
                  </IMPL>
                </EQUI>

                <EQUI>
                  <EQUI>
                    <PREDVAR id="A" />
                    <PREDVAR id="B" />
                  </EQUI>
                  <EQUI>
                    <NOT>
                      <PREDVAR id="A" />
                    </NOT>
                    <NOT>
                      <PREDVAR id="B" />
                    </NOT>
                  </EQUI>
                </EQUI>

                <EQUI>
                  <IMPL>
                    <PREDVAR id="A" />
                    <IMPL>
                      <PREDVAR id="B" />
                      <PREDVAR id="C" />
                    </IMPL>
                  </IMPL>
                  <IMPL>
                    <PREDVAR id="B" />
                    <IMPL>
                      <PREDVAR id="A" />
                      <PREDVAR id="C" />
                    </IMPL>
                  </IMPL>
                </EQUI>

                <EQUI>
                  <NOT>
                    <OR>
                      <PREDVAR id="A" />
                      <PREDVAR id="B" />
                    </OR>
                  </NOT>
                  <AND>
                    <NOT>
                      <PREDVAR id="A" />
                    </NOT>
                    <NOT>
                      <PREDVAR id="B" />
                    </NOT>
                  </AND>
                </EQUI>

                <EQUI>
                  <NOT>
                    <AND>
                      <PREDVAR id="A" />
                      <PREDVAR id="B" />
                    </AND>
                  </NOT>
                  <OR>
                    <NOT>
                      <PREDVAR id="A" />
                    </NOT>
                    <NOT>
                      <PREDVAR id="B" />
                    </NOT>
                  </OR>
                </EQUI>

                <EQUI>
                  <OR>
                    <PREDVAR id="A" />
                    <AND>
                      <PREDVAR id="B" />
                      <PREDVAR id="C" />
                    </AND>
                  </OR>
                  <AND>
                    <OR>
                      <PREDVAR id="A" />
                      <PREDVAR id="B" />
                    </OR>
                    <OR>
                      <PREDVAR id="A" />
                      <PREDVAR id="C" />
                    </OR>
                  </AND>
                </EQUI>

                <EQUI>
                  <AND>
                    <PREDVAR id="A" />
                    <OR>
                      <PREDVAR id="B" />
                      <PREDVAR id="C" />
                    </OR>
                  </AND>
                  <OR>
                    <AND>
                      <PREDVAR id="A" />
                      <PREDVAR id="B" />
                    </AND>
                    <AND>
                      <PREDVAR id="A" />
                      <PREDVAR id="C" />
                    </AND>
                  </OR>
                </EQUI>

                <EQUI>
                  <AND>
                    <PREDVAR id="A" />
                    <PREDCON ref="TRUE" />
                  </AND>
                  <PREDVAR id="A" />
                </EQUI>

                <EQUI>
                  <AND>
                    <PREDVAR id="A" />
                    <PREDCON ref="FALSE" />
                  </AND>
                  <PREDCON ref="FALSE" />
                </EQUI>

                <EQUI>
                  <OR>
                    <PREDVAR id="A" />
                    <PREDCON ref="TRUE" />
                  </OR>
                  <PREDCON ref="TRUE" />
                </EQUI>

                <EQUI>
                  <OR>
                    <PREDVAR id="A" />
                    <PREDCON ref="FALSE" />
                  </OR>
                  <PREDVAR id="A" />
                </EQUI>

                <EQUI>
                  <OR>
                    <PREDVAR id="A" />
                    <NOT>
                      <PREDVAR id="A" />
                    </NOT>
                  </OR>
                  <PREDCON ref="TRUE" />
                </EQUI>

                <EQUI>
                  <AND>
                    <PREDVAR id="A" />
                    <NOT>
                      <PREDVAR id="A" />
                    </NOT>
                  </AND>
                  <PREDCON ref="FALSE" />
                </EQUI>

                <EQUI>
                  <IMPL>
                    <PREDCON ref="TRUE" />
                    <PREDVAR id="A" />
                  </IMPL>
                  <PREDVAR id="A" />
                </EQUI>

                <EQUI>
                  <IMPL>
                    <PREDCON ref="FALSE" />
                    <PREDVAR id="A" />
                  </IMPL>
                  <PREDCON ref="TRUE" />
                </EQUI>

                <EQUI>
                  <IMPL>
                    <PREDVAR id="A" />
                    <PREDCON ref="FALSE" />
                  </IMPL>
                  <NOT>
                    <PREDVAR id="A" />
                  </NOT>
                </EQUI>

                <EQUI>
                  <IMPL>
                    <PREDVAR id="A" />
                    <PREDCON ref="TRUE" />
                  </IMPL>
                  <PREDCON ref="TRUE" />
                </EQUI>

                <EQUI>
                  <EQUI>
                    <PREDVAR id="A" />
                    <PREDCON ref="TRUE" />
                  </EQUI>
                  <PREDVAR id="A" />
                </EQUI>
                
                <IMPL>
                  <AND>
                    <IMPL>
                      <PREDVAR id="A" />
                      <PREDVAR id="B" />
                    </IMPL>
                    <IMPL>
                      <PREDVAR id="B" />
                      <PREDVAR id="C" />
                    </IMPL>
                  </AND>
                  <IMPL>
                    <PREDVAR id="A" />
                    <PREDVAR id="C" />
                  </IMPL>
                </IMPL>

                <IMPL>
                  <AND>
                    <EQUI>
                      <PREDVAR id="A" />
                      <PREDVAR id="B" />
                    </EQUI>
                    <EQUI>
                      <PREDVAR id="C" />
                      <PREDVAR id="B" />
                    </EQUI>
                  </AND>
                  <EQUI>
                    <PREDVAR id="A" />
                    <PREDVAR id="C" />
                  </EQUI>
                </IMPL>

                <EQUI>
                  <EQUI>
                    <AND>
                      <PREDVAR id="A" />
                      <PREDVAR id="B" />
                    </AND>
                    <AND>
                      <PREDVAR id="A" />
                      <PREDVAR id="C" />
                    </AND>
                  </EQUI>
                  <IMPL>
                    <PREDVAR id="A" />
                    <EQUI>
                      <PREDVAR id="B" />
                      <PREDVAR id="C" />
                    </EQUI>
                  </IMPL>
                </EQUI>

                <EQUI>
                  <EQUI>
                    <AND>
                      <PREDVAR id="A" />
                      <PREDVAR id="B" />
                    </AND>
                    <AND>
                      <PREDVAR id="A" />
                      <NOT>
                        <PREDVAR id="B" />
                      </NOT>
                    </AND>
                  </EQUI>
                  <NOT>
                    <PREDVAR id="A" />
                  </NOT>
                </EQUI>

                <EQUI>
                  <EQUI>
                    <PREDVAR id="A" />
                    <AND>
                      <PREDVAR id="A" />
                      <PREDVAR id="B" />
                    </AND>
                  </EQUI>
                  <IMPL>
                    <PREDVAR id="A" />
                    <PREDVAR id="B" />
                  </IMPL>
                </EQUI>

                <IMPL>
                  <IMPL>
                    <PREDVAR id="A" />
                    <PREDVAR id="B" />
                  </IMPL>
                  <IMPL>
                    <AND>
                      <PREDVAR id="A" />
                      <PREDVAR id="C" />
                    </AND>
                    <AND>
                      <PREDVAR id="B" />
                      <PREDVAR id="C" />
                    </AND>
                  </IMPL>
                </IMPL>

                <IMPL>
                  <EQUI>
                    <PREDVAR id="A" />
                    <PREDVAR id="B" />
                  </EQUI>
                  <EQUI>
                    <AND>
                      <PREDVAR id="A" />
                      <PREDVAR id="C" />
                    </AND>
                    <AND>
                      <PREDVAR id="B" />
                      <PREDVAR id="C" />
                    </AND>
                  </EQUI>
                </IMPL>

                <IMPL>
                  <AND>
                    <PREDVAR id="A" />
                    <IMPL>
                      <PREDVAR id="A" />
                      <PREDVAR id="B" />
                    </IMPL>
                  </AND>
                  <PREDVAR id="B" />
                </IMPL>

                <EQUI>
                  <AND>
                    <PREDVAR id="A" />
                    <IMPL>
                      <PREDVAR id="A" />
                      <PREDVAR id="B" />
                    </IMPL>
                  </AND>
                  <AND>
                    <PREDVAR id="A" />
                    <PREDVAR id="B" />
                  </AND>
                </EQUI>

              </AND>
            </FORMULA>
          </THEOREM>
        </NODE>
      </SUBSECTIONS>
      
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">
           Predicate Calculus
        </LATEX>
        <LATEX language="de">
           Prädikatenlogik
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            For predicate calculus we achieve the following propositions.
          ]]>
        </LATEX>
        <LATEX language="de">
          <![CDATA[
            Für die Prädikatenlogik ergeben sich die folgenden Sätze.
          ]]>
        </LATEX>
      </INTRODUCTION>
      <SUBSECTIONS>
        <NODE id="theorem:predicateCalculus">
          <NAME>
            <LATEX language="en">basic propositions</LATEX>
            <LATEX language="de">Elementare Sätze</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Basic Propositions\index{propositions!of predicate calculus}</LATEX>
            <LATEX language="de">Elementare Sätze\index{Sätze!der Prädikaten}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                We have the following basic propositions.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Wir haben die folgenden elementaren Aussagen.
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <AND>

                <IMPL>
                  <FORALL>
                    <VAR id="x" />
                    <IMPL>
                      <PREDVAR id="\phi">
                        <VAR id="x" />
                      </PREDVAR>
                      <PREDVAR id="\psi">
                        <VAR id="x" />
                      </PREDVAR>
                    </IMPL>
                  </FORALL>
                  <IMPL>
                    <FORALL>
                      <VAR id="x" />
                      <PREDVAR id="\phi">
                        <VAR id="x" />
                      </PREDVAR>
                    </FORALL>
                    <FORALL>
                      <VAR id="x" />
                      <PREDVAR id="\psi">
                        <VAR id="x" />
                      </PREDVAR>
                    </FORALL>
                  </IMPL>
                </IMPL>

                <IMPL>
                  <FORALL>
                    <VAR id="x" />
                    <IMPL>
                      <PREDVAR id="\phi">
                        <VAR id="x" />
                      </PREDVAR>
                      <PREDVAR id="\psi">
                        <VAR id="x" />
                      </PREDVAR>
                    </IMPL>
                  </FORALL>
                  <IMPL>
                    <EXISTS>
                      <VAR id="x" />
                      <PREDVAR id="\phi">
                        <VAR id="x" />
                      </PREDVAR>
                    </EXISTS>
                    <EXISTS>
                      <VAR id="x" />
                      <PREDVAR id="\psi">
                        <VAR id="x" />
                      </PREDVAR>
                    </EXISTS>
                  </IMPL>
                </IMPL>

                <IMPL>
                  <FORALL>
                    <VAR id="x" />
                    <EQUI>
                      <PREDVAR id="\phi">
                        <VAR id="x" />
                      </PREDVAR>
                      <PREDVAR id="\psi">
                        <VAR id="x" />
                      </PREDVAR>
                    </EQUI>
                  </FORALL>
                  <EQUI>
                    <FORALL>
                      <VAR id="x" />
                      <PREDVAR id="\phi">
                        <VAR id="x" />
                      </PREDVAR>
                    </FORALL>
                    <FORALL>
                      <VAR id="x" />
                      <PREDVAR id="\psi">
                        <VAR id="x" />
                      </PREDVAR>
                    </FORALL>
                  </EQUI>
                </IMPL>

                <IMPL>
                  <EXISTS>
                    <VAR id="x" />
                    <AND>
                      <PREDVAR id="\phi">
                        <VAR id="x" />
                      </PREDVAR>
                      <PREDVAR id="\psi">
                        <VAR id="x" />
                      </PREDVAR>
                    </AND>
                  </EXISTS>
                  <AND>
                    <EXISTS>
                      <VAR id="x" />
                      <PREDVAR id="\phi">
                        <VAR id="x" />
                      </PREDVAR>
                    </EXISTS>
                    <EXISTS>
                      <VAR id="x" />
                      <PREDVAR id="\psi">
                        <VAR id="x" />
                      </PREDVAR>
                    </EXISTS>
                  </AND>
                </IMPL>

                <IMPL>
                  <OR>
                    <FORALL>
                      <VAR id="x" />
                      <PREDVAR id="\psi">
                        <VAR id="x" />
                      </PREDVAR>
                    </FORALL>
                    <FORALL>
                      <VAR id="x" />
                      <PREDVAR id="\psi">
                        <VAR id="x" />
                      </PREDVAR>
                    </FORALL>
                  </OR>
                  <FORALL>
                    <VAR id="x" />
                    <OR>
                      <PREDVAR id="\phi">
                        <VAR id="x" />
                      </PREDVAR>
                      <PREDVAR id="\psi">
                        <VAR id="x" />
                      </PREDVAR>
                    </OR>
                  </FORALL>
                </IMPL>

                <EQUI>
                  <EXISTS>
                    <VAR id="x" />
                    <OR>
                      <PREDVAR id="\phi">
                        <VAR id="x" />
                      </PREDVAR>
                      <PREDVAR id="\psi">
                        <VAR id="x" />
                      </PREDVAR>
                    </OR>
                  </EXISTS>
                  <OR>
                    <EXISTS>
                      <VAR id="x" />
                      <PREDVAR id="\phi">
                        <VAR id="x" />
                      </PREDVAR>
                    </EXISTS>
                    <EXISTS>
                      <VAR id="x" />
                      <PREDVAR id="\psi">
                        <VAR id="x" />
                      </PREDVAR>
                    </EXISTS>
                  </OR>
                </EQUI>

                <EQUI>
                  <FORALL>
                    <VAR id="x" />
                    <AND>
                      <PREDVAR id="\phi">
                        <VAR id="x" />
                      </PREDVAR>
                      <PREDVAR id="\psi">
                        <VAR id="x" />
                      </PREDVAR>
                    </AND>
                  </FORALL>
                  <AND>
                    <FORALL>
                      <VAR id="x" />
                      <PREDVAR id="\phi">
                        <VAR id="x" />
                      </PREDVAR>
                    </FORALL>
                    <FORALL>
                      <VAR id="x" />
                      <PREDVAR id="\psi">
                        <VAR id="x" />
                      </PREDVAR>
                    </FORALL>
                  </AND>
                </EQUI>

                <EQUI>
                  <FORALL>
                    <VAR id="x" />
                    <FORALL>
                      <VAR id="y" />
                      <PREDVAR id="\phi">
                        <VAR id="x" />
                        <VAR id="y" />
                      </PREDVAR>
                    </FORALL>
                  </FORALL>
                  <FORALL>
                    <VAR id="y" />
                    <FORALL>
                      <VAR id="x" />
                      <PREDVAR id="\phi">
                        <VAR id="x" />
                        <VAR id="y" />
                      </PREDVAR>
                    </FORALL>
                  </FORALL>
                </EQUI>

                <EQUI>
                  <EXISTS>
                    <VAR id="x" />
                    <EXISTS>
                      <VAR id="y" />
                      <PREDVAR id="\phi">
                        <VAR id="x" />
                        <VAR id="y" />
                      </PREDVAR>
                    </EXISTS>
                  </EXISTS>
                  <EXISTS>
                    <VAR id="y" />
                    <EXISTS>
                      <VAR id="x" />
                      <PREDVAR id="\phi">
                        <VAR id="x" />
                        <VAR id="y" />
                      </PREDVAR>
                    </EXISTS>
                  </EXISTS>
                </EQUI>

                <IMPL>
                  <FORALL>
                    <VAR id="x" />
                    <IMPL>
                      <PREDVAR id="\phi">
                        <VAR id="x" />
                      </PREDVAR>
                      <PREDVAR id="A" />
                    </IMPL>
                  </FORALL>
                  <IMPL>
                    <FORALL>
                      <VAR id="x" />
                      <PREDVAR id="\phi">
                        <VAR id="x" />
                      </PREDVAR>
                    </FORALL>
                    <PREDVAR id="A" />
                  </IMPL>
                </IMPL>

                <EQUI>
                  <FORALL>
                    <VAR id="x" />
                    <IMPL>
                      <PREDVAR id="A" />
                      <PREDVAR id="\phi">
                        <VAR id="x" />
                      </PREDVAR>
                    </IMPL>
                  </FORALL>
                  <IMPL>
                    <PREDVAR id="A" />
                    <FORALL>
                      <VAR id="x" />
                      <PREDVAR id="\phi">
                        <VAR id="x" />
                      </PREDVAR>
                    </FORALL>
                  </IMPL>
                </EQUI>

                <EQUI>
                  <FORALL>
                    <VAR id="x" />
                    <AND>
                      <PREDVAR id="\phi">
                        <VAR id="x" />
                      </PREDVAR>
                      <PREDVAR id="A" />
                    </AND>
                  </FORALL>
                  <AND>
                    <FORALL>
                      <VAR id="x" />
                      <PREDVAR id="\phi">
                        <VAR id="x" />
                      </PREDVAR>
                    </FORALL>
                    <PREDVAR id="A" />
                  </AND>
                </EQUI>

                <EQUI>
                  <FORALL>
                    <VAR id="x" />
                    <OR>
                      <PREDVAR id="\phi">
                        <VAR id="x" />
                      </PREDVAR>
                      <PREDVAR id="A" />
                    </OR>
                  </FORALL>
                  <OR>
                    <FORALL>
                      <VAR id="x" />
                      <PREDVAR id="\phi">
                        <VAR id="x" />
                      </PREDVAR>
                    </FORALL>
                    <PREDVAR id="A" />
                  </OR>
                </EQUI>

                <IMPL>
                  <FORALL>
                    <VAR id="x" />
                    <EQUI>
                      <PREDVAR id="\phi">
                        <VAR id="x" />
                      </PREDVAR>
                      <PREDVAR id="A" />
                    </EQUI>
                  </FORALL>
                  <EQUI>
                    <FORALL>
                      <VAR id="x" />
                      <PREDVAR id="\phi">
                        <VAR id="x" />
                      </PREDVAR>
                    </FORALL>
                    <PREDVAR id="A" />
                  </EQUI>
                </IMPL>

                <IMPL>
                  <FORALL>
                    <VAR id="x" />
                    <EQUI>
                      <PREDVAR id="\phi">
                        <VAR id="x" />
                      </PREDVAR>
                      <PREDVAR id="\psi">
                        <VAR id="x" />
                      </PREDVAR>
                    </EQUI>
                  </FORALL>
                  <EQUI>
                    <FORALL>
                      <VAR id="x" />
                      <PREDVAR id="\phi">
                        <VAR id="x" />
                      </PREDVAR>
                    </FORALL>
                    <FORALL>
                      <VAR id="x" />
                      <PREDVAR id="\psi">
                        <VAR id="x" />
                      </PREDVAR>
                    </FORALL>
                  </EQUI>
                </IMPL>

              </AND>
            </FORMULA>
          </THEOREM>
        </NODE>
      </SUBSECTIONS>
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">
           Derived Rules
        </LATEX>
        <LATEX language="de">
           Abgeleitete Regeln
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            Beginning with the logical basis logical propositions and metarules can be derived an enable a convenient argumentation. Only with these metarules and additional definitions and abbreviations the mathematical world is unfolded. Every additional syntax is \emph{conservative}\index{conservativ}. That means:            within extended system no formulas can be derived, that are written in the old syntax but can not be derived in the old system. In the following such conservative extensions are introduced.
          ]]>
        </LATEX>
        <LATEX language="de">
          <![CDATA[
            Aus den logischen Grundlagen lassen sich logische Sätze und Metaregeln ableiten, die eine bequemere Argumentation ermöglichen. Erst mit diesem Regelwerk und zusätzlichen Definitionen und Abkürzungen wird die restliche Mathematik entwickelt. Dabei wird stets nur eine \emph{konservative}\index{konservativ} Erweiterung der bisherigen Syntax vorgenommen. D.~h. in dem erweiterten System lassen sich keine Formeln ableiten, die in der alten Syntax formuliert, aber dort nicht ableitbar sind. Im Folgenden werden solche konservativen Erweiterungen vorgestellt.
          ]]>
        </LATEX>
      </INTRODUCTION>
      <SUBSECTIONS>
        <NODE id="rule:replaceEquiFormula">
          <NAME>
            <LATEX language="en">replace by logical equivalent formula</LATEX>
            <LATEX language="de">Ersetzung durch logisch äquivalente Formel</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Replace by Logical Equivalent Formula</LATEX>
            <LATEX language="de">Ersetzung durch logisch äquivalente Formeln</LATEX>
          </TITLE>
          <RULE name="replaceEquiFormula">
            <DESCRIPTION>
              <LATEX language="en">
                <![CDATA[
                  Let the formula $\alpha \leftrightarrow \beta$ be true. If in a formula $\delta$ we replace an arbitrary occurence of $\alpha$ by $\beta$ and the result $\gamma$ is also a formula\footnote{During that substitution it might be necessary to rename bound variables of $\beta$.} and contains all the free subject variables of $\delta$, then $\delta \leftrightarrow \gamma$ is a true formula.
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  Sei die Aussage $\alpha \leftrightarrow \beta$ bereits bewiesen. Wird dann aus der Formel $\delta$ eine neue Formel $\gamma$ dadurch gewonnen, dass ein beliebiges Vorkommen von $\alpha$ durch $\beta$ ersetzt\footnote{Bei dieser Ersetzung kann es erforderlich sein, dass gebundene Variablen von $\beta$ umbenannt werden müssen, damit sich wieder eine Formel ergibt.} wird und besitzt $\gamma$ zumindest die freien Variablen von $\delta$, dann gilt $\delta \leftrightarrow \gamma$.
                ]]>
              </LATEX>
            </DESCRIPTION>
          </RULE>
        </NODE>

        <NODE id="rule:replaceTrueByTrueFormula">
          <NAME>
            <LATEX language="en">replace $\top$ by true formula</LATEX>
            <LATEX language="de">Ersetzung von $\top$ durch wahre Formel</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Replacement of $\top$ by already derived formula</LATEX>
            <LATEX language="de">Ersetzung von $\top$ durch bereits abgeleitete Formel</LATEX>
          </TITLE>
          <RULE name="replaceTrueByTrueFormula">
            <DESCRIPTION>
              <LATEX language="en">
                <![CDATA[

                  Let $\alpha$ be an already derived true formula and $\beta$ a formula that contains $\top$. If we get a well formed formula $\gamma$ by replacing an arbitray occurence of $\top$ in $\beta$ with $\alpha$ then the following formula is also true: $\beta \leftrightarrow \gamma$

                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[

                  Sei $\alpha$ eine bereits abgeleitete wahre Formel und $\beta$ eine Formel, die $\top$ enthält. Falls wir durch Ersetzung eines beliebigen Vorkommens von $\top$ in $\beta$ durch $\alpha$ eine wohlgeformte Formel $\gamma$ erhalten, dann ist die folgende Formel ebenfalls wahr: $\beta \leftrightarrow \gamma$

                ]]>
              </LATEX>
            </DESCRIPTION>
          </RULE>
        </NODE>

        <NODE id="rule:replaceTrueFormulaByTrue">
          <NAME>
            <LATEX language="en">replace true formula by $\top$</LATEX>
            <LATEX language="de">Ersetzung von wahrer Formel durch $\top$</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Replacement of already derived formula by $\top$</LATEX>
            <LATEX language="de">Ersetzung von bereits abgeleiteter Formel durch $\top$</LATEX>
          </TITLE>
          <RULE name="replaceTrueFormulaByTrue">
            <DESCRIPTION>
              <LATEX language="en">
                <![CDATA[

                  Let $\alpha$ be an already derived true formula and $\beta$ a formula that contains $\alpha$. If we get a well formed formula $\gamma$ by replacing an arbitray occurence of $\alpha$ in $\beta$ by $\top$ then the following formula is also true: $\beta \leftrightarrow \gamma$

                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[

                  Sei $\alpha$ eine bereits abgeleitete wahre Formel und $\beta$ eine Formel, die $\alpha$ enthält. Falls wir durch Ersetzung eines beliebigen Vorkommens von $\alpha$ in $\beta$ durch $\top$ eine wohlgeformte Formel $\gamma$ erhalten, dann ist die folgende Formel ebenfalls wahr: $\beta \leftrightarrow \gamma$

                ]]>
              </LATEX>
            </DESCRIPTION>
          </RULE>
        </NODE>

        <NODE id="rule:derivedQuantification">
          <NAME>
            <LATEX language="en">derived quantification</LATEX>
            <LATEX language="de">abgeleitete Quantifizierung</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Derived Quantification</LATEX>
            <LATEX language="de">Abgeleitete Quantifizierung</LATEX>
          </TITLE>
          <RULE name="derivedQuantification">
            <DESCRIPTION>
              <LATEX language="en">
                <![CDATA[

                  If we have already derived the true formula $\alpha(x)$ and $x$ is not bound in $\alpha(x)$ then the formula $\forall x \ \alpha(x)$ is also true.

                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[

                  Falls wir die wahre Formel $\alpha(x)$ bereits abgeleitet haben und $x$ in $\alpha(x)$ nicht gebunden vorkommt, dann ist die Formel $\forall x \ \alpha(x)$ ebenfalls wahr.
                ]]>
              </LATEX>

            </DESCRIPTION>
          </RULE>
        </NODE>

        <NODE id="rule:generalAssociativity">
          <NAME>
            <LATEX language="en">general associativity</LATEX>
            <LATEX language="de">allgemeine Assoziativität</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">General Associativity</LATEX>
            <LATEX language="de">Allgemeine Assoziativität</LATEX>
          </TITLE>
          <RULE name="generalAssociativity">
            <DESCRIPTION>
              <LATEX language="en">
                <![CDATA[
                  If an operator of arity two fulfills the associative law it also fulfills the general associative law. The operator can be extended to an operator of arbitrary arity greater one. For example: instead of $(a + b) + (c + d)$ we simply write $a + b + c + d$.\footnote{The operator of arity $n$ is defined with a certain bracketing, but every other bracketing gives the same result.}
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  Falls ein zweistelliger Operator das Assoziativitätsgesetz erfüllt, so erfüllt er auch das allgemeine Assoziativitätsgesetz. Dem Operator kann dann eine beliebige Stellenanzahl größer eins zugeschrieben werden. So wird beispielsweise anstelle für $(a + b) + (c + d)$ einfach $a + b + c + d$ geschrieben.\footnote{Der $n$-stellig Operator wird mit einer bestimmten Klammerung definiert, jede andere Klammerreihenfolge liefert jedoch dasselbe Ergebnis.}
                ]]>
              </LATEX>

            </DESCRIPTION>
          </RULE>
        </NODE>

        <NODE id="rule:generalCommutativity">
          <NAME>
            <LATEX language="en">allgemeine Kommutativität</LATEX>
            <LATEX language="de">general commutativity</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">General Commutativity</LATEX>
            <LATEX language="de">Allgemeine Kommutativität</LATEX>
          </TITLE>
          <RULE name="generalCommutativity">
            <DESCRIPTION>
              <LATEX language="en">
                <![CDATA[
                  If an operator fulfills the general associative law and is commutative then all permutations of parameters are equal or equivalent.\footnote{That depends on the operator type: term or formula operator.} For example we have: $a + b + c + d  = c + a + d + b$.
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  Falls ein Operator das allgemeine Assoziativitätsgesetz erfüllt und kommutativ ist, so sind alle Permutationen von Parameterreihenfolgen einander gleich oder äquivalent.\footnote{Je nachdem ob es sich um einen Termoperator oder einen Formeloperator handelt.} So gilt beispielsweise $a + b + c + d  = c + a + d + b$.
                ]]>
              </LATEX>

            </DESCRIPTION>
          </RULE>
        </NODE>

        <NODE id="rule:definitionDeductionFromFormula">
          <NAME>
            <LATEX language="en">Ableitbarkeit aus einer Formel</LATEX>
            <LATEX language="de">deducible from formula</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Deducible from Formula\index{deducible}</LATEX>
            <LATEX language="de">Ableitbarkeit aus einer Formel\index{ableitbar}</LATEX>
          </TITLE>
          <RULE name="definitionDeducibleFromFormula">
            <DESCRIPTION>
              <LATEX language="en">
                <![CDATA[
                  We shall say that the formula $\beta$ is \emph{deducible from the formula $\alpha$} if the formula $\beta$ from the totality of all true formulas of the predicate calculus and the formula $\alpha$ by means of application of all the rules of the predicate calculus, in which connection both rules for binding by a quantifier, the rules for substitution in place of predicate variables and in place of free subject variables must be applied only to predicate variables or subject variables which do not occur in the formula $\alpha$ and $\alpha \rightarrow \beta$ is a formula. 
                  
                  \par
                  Notation: $\alpha \vdash \beta$.
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  Eine Formel $\beta$ heißt \emph{aus der Formel $\alpha$ ableitbar}, wenn sich $\beta$ mit Hilfe aller Regeln des Prädikatenkalküls und der um $\alpha$ vermehrten Gesamtheit aller wahren Formeln des Prädikatenkalküls herleitbar und $\alpha \rightarrow \beta$ eine Formel ist. Dabei dürfen die beiden Quantifizierungsregeln, die Einsetzungsregel für Prädikatenvariable und die Umbenennungsregel für freie Subjektvariable nur auf solche Variablen angewendet werden, die in der Formel $\alpha$ nicht auftreten.
                  
                  \par
                  Schreibweise: $\alpha \vdash \beta$.
                ]]>
              </LATEX>
            </DESCRIPTION>
          </RULE>
          <SUCCEEDING>
            <LATEX language="en">
              <![CDATA[
                That a formula $\beta$ is deducible from the formula $\alpha$ must be strictly distinguished from the deduction of a true formula from the axioms of the predicate calculus. In the second case more derivation rules are available. For example if $A$ is added to the axioms then the formula $B$ can be derived. But $B$ is not deducible from $A$.\footnote{We must make this distinction due to possible substitution rule usages.}
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Die Ableitbarkeit einer Formel $\beta$ aus der Formel $\alpha$ ist streng zu unterscheiden von der Ableitbarkeit einer wahren Formel aus den Axiomen des Kalküls, denn im zweiten Fall stehen mehr Ableitungsregeln zur Verfügung. Falls beispielsweise die Formel $A$ als Axiom aufgenommen wird, so ist die Formel $A$ herleitbar. Hingegen läßt sich aus $A$ nicht $B$ ableiten.\footnote{Die Unterscheidung ist der möglichen Anwendung der verschiedenen Substitionsregeln geschuldet.}
              ]]>
            </LATEX>
          </SUCCEEDING>
        </NODE>


        <NODE id="rule:deductionTheorem">
          <NAME>
            <LATEX language="en">allgemeine Kommutativität</LATEX>
            <LATEX language="de">Deduktionstheorem</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Deduction Theorem\index{deduction theorem}</LATEX>
            <LATEX language="de">Deduktionstheorem\index{Deduktionstheorem}</LATEX>
          </TITLE>
          <RULE name="generalCommutativity">
            <DESCRIPTION>
              <LATEX language="en">
                <![CDATA[
                  If the formula $\beta$ is deducible from the formula $\alpha$, then the formula $\alpha \rightarrow \beta$ can be derived from the predicate calculus.
                ]]>
              </LATEX>
              <LATEX language="de">
                <![CDATA[
                  Wenn eine Formel $\beta$ aus einer Formel $\alpha$ ableitbar ist, so ist die Formel $\alpha \rightarrow \beta$ im Prädikatenkalkül herleitbar.
                ]]>
              </LATEX>
            </DESCRIPTION>
          </RULE>
        </NODE>

      </SUBSECTIONS>
    </SECTION>
    
  </CHAPTER>

  <CHAPTER>
    <TITLE>
      <LATEX language="en">
         Identity
      </LATEX>
      <LATEX language="de">
         Identität
      </LATEX>
    </TITLE>
    <INTRODUCTION>
      <LATEX language="en">
        <![CDATA[
          Everything that exists has a specific nature. Each entity exists as something in particular and it has characteristics that are a part of what it is.
          Identity is whatever makes an entity definable and recognizable, in terms of possessing a set of qualities or characteristics that distinguish it from entities of a different type. An entity can have more than one characteristic, but any characteristic it has is a part of its identity.
        ]]>
      </LATEX>
      <LATEX language="de">
        <![CDATA[
          Alles was existiert besitzt eine spezifische Natur. Jede Entität existiert als etwas besonderes und besitzt charakterisierende Merkmale. Identität ist etwas, das eine Entität definierbar und erkennbar macht im Sinne einer Menge von Eigenschaften oder Merkmalen, welche sie von anderen Entitiäten unterscheiden. Eine Entität kann mehrere Merkmale besitzen, aber alle Merkmale die sie besitzt ist Teil ihrer Identität.
        ]]>
      </LATEX>
    </INTRODUCTION>
    
    <SECTION>
      <TITLE>
        <LATEX language="en">
           Identity Axioms
        </LATEX>
        <LATEX language="de">
           Axiome der Identität
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            We start with the identy axioms.
          ]]>
        </LATEX>
        <LATEX language="de">
          <![CDATA[
            Wir starten mit den Identitätsaxiomen.
          ]]>
        </LATEX>
      </INTRODUCTION>
      <SUBSECTIONS>
        <NODE id="definition:identity">
          <NAME>
            <LATEX language="en">identity definition</LATEX>
            <LATEX language="de">Definition der Identität</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Identity\index{identity}\index{definition!of identity}</LATEX>
            <LATEX language="de">Identität\index{Identität}\index{Definition!der Identität}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                We define a predicate constant of arity two that shall stand for the identity of subjects.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Es wird eine zweistellige Prädikatskonstante festgelegt, welche in der Interpretation die Identität von Subjekten ausdrücken soll.
              ]]>
            </LATEX>
          </PRECEDING>
          <DEFINITION_PREDICATE_INITIAL arguments="2" name="equal">
            <LATEXPATTERN>#1 \ =  \ #2</LATEXPATTERN>
            <PREDCON ref="equal">
              <VAR id="x"/>
              <VAR id="y"/>
            </PREDCON>
          </DEFINITION_PREDICATE_INITIAL>
        </NODE>
        
        <NODE id="definition:notEqual">
          <NAME>
            <LATEX language="en">not identical definition</LATEX>
            <LATEX language="de">Definition der Verschiedenheit</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Not Identical\index{identical!is not}</LATEX>
            <LATEX language="de">Verschiedenheit\index{Verschiedenheit}\index{Definition!der Verschiedenheit}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                For convenience we also define the negation of the identity a predicate constant.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Aus Bequemlichkeit definieren wir auch die Negation der Identitätskonstante.
              ]]>
            </LATEX>
          </PRECEDING>
          <DEFINITION_PREDICATE arguments="2" name="notEqual">
            <LATEXPATTERN>#1 \ \neq \ #2</LATEXPATTERN>
            <FORMULA>
              <EQUI>
                <PREDCON ref="notEqual">
                  <VAR id="x"/>
                  <VAR id="y"/>
                </PREDCON>
                <NOT>
                  <PREDCON ref="equal">
                    <VAR id="x"/>
                    <VAR id="y"/>
                  </PREDCON>
                 </NOT>
               </EQUI>
            </FORMULA>
          </DEFINITION_PREDICATE>
        </NODE>
        
        <NODE id="axiom:identityIsReflexive">
          <NAME>
            <LATEX language="en">reflexivity of identity</LATEX>
            <LATEX language="de">Reflexivität der Identität</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Reflexivity of Identity\index{reflexivity!of identity}\index{identy!reflexivity of}</LATEX>
            <LATEX language="de">Reflexivität der Identität\index{Reflexivität!der Identität}\index{Identität!Reflexivität der}</LATEX>
          </TITLE>
          <AXIOM>
            <FORMULA>
              <PREDCON ref="equal">
                <VAR id="x" />
                <VAR id="x" />
              </PREDCON>
            </FORMULA>
          </AXIOM>
        </NODE>

        <NODE id="axiom:leibnizReplacement">
          <NAME>
            <LATEX language="en">Leibniz' replacement</LATEX>
            <LATEX language="de">Leibnizsche Ersetzbarkeit</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Leibniz' replacement\index{Leibniz' replacement}</LATEX>
            <LATEX language="de">Leibnizsche Ersetzbarkeit\index{Leibnizsche Ersetzbarkeit}</LATEX>
          </TITLE>
          <AXIOM>
            <FORMULA>
              <IMPL>
                <PREDCON ref="equal">
                  <VAR id="x" />
                  <VAR id="y" />
                </PREDCON>
                <IMPL>
                  <PREDVAR id="\phi">
                    <VAR id="x" />
                  </PREDVAR>
                  <PREDVAR id="\phi">
                    <VAR id="y" />
                  </PREDVAR>
                </IMPL>
              </IMPL>
            </FORMULA>
          </AXIOM>
        </NODE>

        <NODE id="axiom:symmetryOfIdentity">
          <NAME>
            <LATEX language="en">symmetry of identity</LATEX>
            <LATEX language="de">Symmetrie der Identität</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Symmetrie of identity\index{identity!symmetry of}</LATEX>
            <LATEX language="de">Symmetrie der Identität\index{Identität!Symmetrie der}</LATEX>
          </TITLE>
          <AXIOM>
            <FORMULA>
              <IMPL>
                <PREDCON ref="equal">
                  <VAR id="x" />
                  <VAR id="y" />
                </PREDCON>
                <PREDCON ref="equal">
                  <VAR id="y" />
                  <VAR id="x" />
                </PREDCON>
              </IMPL>
            </FORMULA>
          </AXIOM>
        </NODE>

        <NODE id="axiom:transitivityOfIdentity">
          <NAME>
            <LATEX language="en">transetivity of identity</LATEX>
            <LATEX language="de">Transitivität der Identität</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Transitivity of identity\index{identity!transetivity of}</LATEX>
            <LATEX language="de">Transitivität der Identität\index{Identität!Transitivität der}</LATEX>
          </TITLE>
          <AXIOM>
            <FORMULA>
              <IMPL>
                <AND>
                  <PREDCON ref="equal">
                    <VAR id="x" />
                    <VAR id="y" />
                  </PREDCON>
                  <PREDCON ref="equal">
                    <VAR id="y" />
                    <VAR id="z" />
                  </PREDCON>
                </AND>
                <PREDCON ref="equal">
                  <VAR id="x" />
                  <VAR id="z" />
                </PREDCON>
              </IMPL>
            </FORMULA>
          </AXIOM>
        </NODE>
        
        <NODE id="theorem:leibnizEquivalence" level="formal">
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                We can reverse the second implication in the Leibniz replacement.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Bei der Leibnizschen Ersetzbarkeit können wir die zweite Implikation umkehren.
              ]]>
            </LATEX>
          </PRECEDING>
          <THEOREM>
            <FORMULA>
              <IMPL>
                <PREDCON ref="equal">
                  <VAR id="x" />
                  <VAR id="y" />
                </PREDCON>
                <EQUI>
                  <PREDVAR id="\phi">
                    <VAR id="x" />
                  </PREDVAR>
                  <PREDVAR id="\phi">
                    <VAR id="y" />
                  </PREDVAR>
                </EQUI>
              </IMPL>
            </FORMULA>
          </THEOREM>
       </NODE>

        <NODE id="theorem:identyImpliesFunctionalEquality" level="formal">
          <THEOREM>
            <FORMULA>
              <IMPL>
                <PREDCON ref="equal">
                  <VAR id="x" />
                  <VAR id="y" />
                </PREDCON>
                <PREDCON ref="equal">
                  <FUNVAR id="f">
                    <VAR id="x" />
                  </FUNVAR>
                  <FUNVAR id="f">
                    <VAR id="y" />
                  </FUNVAR>
                </PREDCON>
              </IMPL>
            </FORMULA>
          </THEOREM>
        </NODE>

      </SUBSECTIONS>
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">
           Restricted Quantifiers\index{quantifiers!restriced}
        </LATEX>
        <LATEX language="de">
           Eingeschränkte Quantoren\index{Quantor!eingeschränkter}
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            Every quantification involves one specific subject variable and a domain of discourse or range of quantification of that variable. Until now we assumed a fixed domain of discourse for every quantification. Specification of the range of quantification allows us to express that a predicate holds only for a restricted domain.
          ]]>
        </LATEX>
        <LATEX language="de">
          <![CDATA[
            Jede Quantifizierung benötigt eine Subjektvariable und einen Bereich über den die Quantifizierung läuft. Bis jetzt haben wir einen festen Bereich für jede Quantifizierung vorausgesetzt. Die Angabe eines Bereichs ermöglicht uns auszudrücken, dass ein Prädikat nur für einen eingeschränkten Bereich gültig ist.
          ]]>
        </LATEX>
      </INTRODUCTION>
      <SUBSECTIONS>

        <NODE id="axiom:restrictedUniversalQuantifier">
          <NAME>
            <LATEX language="en">definition restricted universal quantifier</LATEX>
            <LATEX language="de">Definition eingeschränker Allquantor</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Restricted Universal Quantifier\index{universal quantifier, restricted}</LATEX>
            <LATEX language="de">Eingeschränkter Allquantor\index{Allquantor!eingeschränkter}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                At the following definition the replacement formula for $\alpha(x)$ must {\glqq reveal\grqq} its quantification subject variable. This is usually the first following subject variable.\footnote{For example: in the following formula we identify the subject variable $m$ for the second quantification: $\forall \ n \in \mathbb{N} \ \forall \ m \in n \ m < n $.} In the exact syntax of the QEDEQ format\footnote{Again see \url{http://www.qedeq.org/current/xml/qedeq/}.} the quantification subject variable is always given.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Bei der folgenden Definition muss die für $\alpha(x)$ eingesetzte Formel {\glqq erkennen lassen\grqq}, über welche Subjektvariable quantifiziert wird. Das ist in der Regel darüber zu entscheiden, welche freie Subjektvariable als erstes in der Formel vorkommt.\footnote{Beispielsweise ist in der folgenden Formel erkennbar, dass die zweite Quantifikation über die Subjektvariable $m$ läuft: $\forall \ n \in \mathbb{N} \ \forall \ m \in n \ m < n $.} In der exakten Syntax des QEDEQ-Formats\footnote{Siehe wieder unter \url{http://www.qedeq.org/current/xml/qedeq/}.} ist die Subjektvariable immer angegeben.
              ]]>
            </LATEX>
          </PRECEDING>
          <AXIOM definedOperator="FORALL">
            <FORMULA>
              <EQUI>
                <FORALL>
                  <VAR id="x"/>
                  <PREDVAR id="\alpha">
                    <VAR id="x"/>
                  </PREDVAR>
                  <PREDVAR id="\beta">
                    <VAR id="x"/>
                  </PREDVAR>
                </FORALL>
                <FORALL>
                  <VAR id="x"/>
                  <IMPL>
                    <PREDVAR id="\alpha">
                      <VAR id="x"/>
                    </PREDVAR>
                    <PREDVAR id="\beta">
                      <VAR id="x"/>
                    </PREDVAR>
                  </IMPL>
                </FORALL>
              </EQUI>
            </FORMULA>
          </AXIOM>
        </NODE>

        <NODE id="axiom:restrictedExistentialQuantifier">
          <NAME>
            <LATEX language="en">definition restricted existential quantifier</LATEX>
            <LATEX language="de">Definition eingeschränker Existenzquantor</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Restricted Existential Quantifier\index{existential quantifier, restricted}</LATEX>
            <LATEX language="de">Eingeschränkter Existenz\index{Existenzquantor!eingeschränkter}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                A matching definiton for the restricted existential quantifier is the following.\footnote{Matching because of $\neg \forall \ \psi(x) \ (\phi(x)) \leftrightarrow \exists \ x \ \neg (\psi(x) \rightarrow \phi(x)) \leftrightarrow \exists \ x \ (\psi(x) \land \neg\phi(x)) \leftrightarrow \exists \ \psi(x) \ (\neg\phi(x))$.}
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Dazu passt die folgende Definition für den eingeschränkten Existenzquantor.\footnote{Passend, da $\neg \forall \ \psi(x) \ (\phi(x)) \leftrightarrow \exists \ x \ \neg (\psi(x) \rightarrow \phi(x)) \leftrightarrow \exists \ x \ (\psi(x) \land \neg\phi(x)) \leftrightarrow \exists \ \psi(x) \ (\neg\phi(x))$.}
              ]]>
            </LATEX>
          </PRECEDING>
          <AXIOM definedOperator="EXISTS">
            <FORMULA>
              <EQUI>
                <EXISTS>
                  <VAR id="x"/>
                  <PREDVAR id="\alpha">
                    <VAR id="x"/>
                  </PREDVAR>
                  <PREDVAR id="\beta">
                    <VAR id="x"/>
                  </PREDVAR>
                </EXISTS>
                <EXISTS>
                  <VAR id="x"/>
                  <AND>
                    <PREDVAR id="\alpha">
                      <VAR id="x"/>
                    </PREDVAR>
                    <PREDVAR id="\beta">
                      <VAR id="x"/>
                    </PREDVAR>
                  </AND>
                </EXISTS>
              </EQUI>
            </FORMULA>
          </AXIOM>
        </NODE>

        <SUBSECTION>
          <TEXT>
            <LATEX language="en">
              <![CDATA[
                For restricted quantifiers we find formulas according to Proposition \qref{theorem:predicateCalculus}.
                \\
                +++
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Für eingeschränkte Quantoren gelten analog zu Proposition \qref{theorem:predicateCalculus} entsprechende Formeln.
                \\
                +++
              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>
        

        <NODE id="axiom:restrictedUniquenessQuantifier">
          <NAME>
            <LATEX language="en">definition restricted uniqueness quantifier</LATEX>
            <LATEX language="de">Definition eingeschränker Existenzquantor für genau ein Individuum</LATEX>
          </NAME>
          <TITLE>
            <LATEX language="en">Restricted Uniqueness Quantifier\index{uniqueness quantifier, restricted}</LATEX>
            <LATEX language="de">Eingeschränkter Existenz für genau ein Individuum\index{Existenzquantor!eingeschränkter für ein Individuum}</LATEX>
          </TITLE>
          <PRECEDING>
            <LATEX language="en">
              <![CDATA[
                To express the existence of only one individuum with a certain property we introduce a new quantifier.
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                Für die Existenz genau eines Individuums mit einer bestimmten Eigenschaft wird nun ein gesonderter Quantor eingeführt.
              ]]>
            </LATEX>
          </PRECEDING>
          <AXIOM definedOperator="EXISTSU">
            <FORMULA>
              <EQUI>
                <EXISTSU>
                  <VAR id="x"/>
                  <PREDVAR id="\alpha">
                    <VAR id="x"/>
                  </PREDVAR>
                  <PREDVAR id="\beta">
                    <VAR id="x"/>
                  </PREDVAR>
                </EXISTSU>
                <EXISTS>
                  <VAR id="x"/>
                  <PREDVAR id="\alpha">
                    <VAR id="x"/>
                  </PREDVAR>
                  <AND>
                    <PREDVAR id="\beta">
                      <VAR id="x"/>
                    </PREDVAR>
                    <FORALL>
                      <VAR id="y"/>
                      <PREDVAR id="\alpha">
                        <VAR id="y"/>
                      </PREDVAR>
                      <IMPL>
                        <PREDVAR id="\beta">
                          <VAR id="y"/>
                        </PREDVAR>
                        <PREDCON ref="equal">
                          <VAR id="x"/>
                          <VAR id="y"/>
                        </PREDCON>
                      </IMPL>
                    </FORALL>
                  </AND>
                </EXISTS>
              </EQUI>
            </FORMULA>
          </AXIOM>
        </NODE>

        <SUBSECTION>
          <TEXT>
            <LATEX language="en">
              <![CDATA[
                \begin{rul}[Term Definition by Formula]\hypertarget{rule:termdef}{}
                If the formula $\exists! x \ \alpha(x)$ holds, we can expand the term syntax by $D(x, \alpha(x))$. May the formula $alpha(x)$ doesn't contain the variable $y$ and let $\beta(y)$ be a formula that doesn't contain the variable $x$. Then we define a new formula $\beta(D(x, \alpha(x)))$ by $\beta(y) \land \exists! x \ (\alpha(x) \land x = y)$. Also in this abbreviate notation the subject variable $x$ counts as bound, the subject variable $y$ is arbitrary (if it fulfills the given conditions) and will be ignored in the abbreviation. Changes in $\alpha$ that lead to another formula $\alpha'$ because of variable collision with $\beta$ must also be done in the abbreviation. All term building rules are extended accordingly. The expression is also replaceble by $\exists! y \ (\beta(y) \land \alpha(y)$ or by $\beta(y) \land \alpha(y)$.
                \end{rul}
              ]]>
            </LATEX>
            <LATEX language="de">
              <![CDATA[
                \begin{rul}[Termdefinition durch Formel]\hypertarget{rule:termdef}{}
                Falls die Formel $\exists! x \ \alpha(x)$ gilt, dann kann die Termsyntax durch $D(x, \alpha(x))$ erweitert werden. Die Formel $alpha(x)$ möge die Variable $y$ nicht enthalten und $\beta(y)$ sei eine Formel, welche die Variable $x$ nicht enthält. Dann wird durch $\beta(D(x, \alpha(x)))$ eine
                Formel definiert durch $\beta(y) \land \exists! x \ (\alpha(x) \land x = y)$. Auch in der abkürzenden Schreibweise gilt die Subjektvariable $x$ als gebunden, die Subjektvariable $y$ ist mit den obigen Einschränkungen frei wählbar und wird in der Abkürzung nicht weiter beachtet. Veränderungen von $\alpha$ in eine andere Formel $\alpha'$, die eventuell erforderlich sind, damit keine Variablenkollisionen mit Variablen aus $\beta$ entstehen, müssen jedoch auch in der Abkürzung durchgeführt werden. Alle Termbildungsregeln werden entsprechend erweitert. Der Ausdruck ist auch ersetzbar durch $\exists! y \ (\beta(y) \land \alpha(y)$ oder durch $\beta(y) \land \alpha(y)$.
                \end{rul}
              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>
        
      </SUBSECTIONS>
    </SECTION>
  </CHAPTER>
  <BIBLIOGRAPHY>
    <ITEM label="witheruss">
      <LATEX language="en">
        <![CDATA[
           \emph{A.N. Whitehead, B. Russell}, Principia Mathematica, Cambridge University Press, London 1910
        ]]>
      </LATEX>
      <LATEX language="de">
        <![CDATA[
          \emph{A.N. Whitehead, B. Russell}, Principia Mathematica, Cambridge University Press, London 1910
        ]]>
      </LATEX>
    </ITEM>
    <ITEM label="bernays">
      <LATEX language="en">
        <![CDATA[
           \emph{P. Bernays}, Axiomatische Untersuchung des Aussagen-Kalkuls der {\glqq Principia Mathematica\grqq}, Math. Zeitschr. 25 (1926), 305-320
        ]]>
      </LATEX>
      <LATEX language="de">
        <![CDATA[
          \emph{P. Bernays}, Axiomatische Untersuchung des Aussagen-Kalkuls der {\glqq Principia Mathematica\grqq}, Math. Zeitschr. 25 (1926), 305-320
        ]]>
      </LATEX>
    </ITEM>
    <ITEM label="hilback">
      <LATEX language="en">
        <![CDATA[
           \emph{D. Hilbert, W. Ackermann}, Grundzüge der theoretischen Logik, 2nd ed., Berlin: Springer, 1938. English version: Principles of Mathematical Logic, Chelsea, New York 1950, ed. by R.~E.~Luce.
           See also \url{http://www.math.uwaterloo.ca/~snburris/htdocs/scav/hilbert/hilbert.html}
        ]]>
      </LATEX>
      <LATEX language="de">
        <![CDATA[
          \emph{D. Hilbert, W. Ackermann}, Grundzüge der theoretischen Logik, 2. Ed., Springer, Berlin 1938. Siehe auch \url{http://www.math.uwaterloo.ca/~snburris/htdocs/scav/hilbert/hilbert.html}
        ]]>
      </LATEX>
    </ITEM>
    <ITEM label="novikov">
      <LATEX language="en">
        <![CDATA[
           \emph{P.S. Novikov}, Elements of Mathematical Logic, Edinburgh: Oliver and Boyd, 1964.
        ]]>
      </LATEX>
      <LATEX language="de">
        <![CDATA[
          \emph{P.S. Novikov}, Grundzüge der mathematischen Logik, VEB Deutscher Verlag der Wissenschaften, Berlin 1973
        ]]>
      </LATEX>
    </ITEM>
    <ITEM label="mendelson">
      <LATEX language="en">
        <![CDATA[
           \emph{E. Mendelson}, Introduction to Mathematical Logic, 3rd. ed., Belmont, CA: Wadsworth, 1987.
        ]]>
      </LATEX>
      <LATEX language="de">
        <![CDATA[
          \emph{E. Mendelson}, Introduction to Mathematical Logic, 3. ed., Wadsworth, Belmont, CA 1987
        ]]>
      </LATEX>
    </ITEM>
    <ITEM label="guenter">
      <LATEX language="en">
        <![CDATA[
           \emph{V.~Günther}, Lecture {\glqq Mathematik und Logik\grqq}, given at the University of Hamburg, 1994/1995.
        ]]>
      </LATEX>
      <LATEX language="de">
        <![CDATA[
          \emph{V.~Günther}, Vorlesung {\glqq Mathematik und Logik\grqq}, gehalten an der Universität Hamburg, Wintersemester 1994/1995
        ]]>
      </LATEX>
    </ITEM>
    <ITEM label="meyling">
      <LATEX language="en">
        <![CDATA[
           \emph{M. Meyling}, Hilbert II, Presentation of Formal Correct Mathematical Knowledge, Basic Concept,
           \url{http://www.qedeq.org/current/doc/project/qedeq_basic_concept_en.pdf}.
        ]]>
      </LATEX>
      <LATEX language="de">
        <![CDATA[
          \emph{M. Meyling}, Hilbert II, Darstellung von formal korrektem mathematischen Wissen, Grobkonzept, \url{http://www.qedeq.org/current/doc/project/qedeq_basic_concept_de.pdf}
        ]]>
      </LATEX>
    </ITEM>
  </BIBLIOGRAPHY>
</QEDEQ>
