<?xml version="1.0" encoding="UTF-8"?>
<QEDEQ
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="http://www.qedeq.org/0_04_07/xml/qedeq.xsd">
  <HEADER email="mime@qedeq.org">
    <SPECIFICATION name="qedeq_logic_language" ruleVersion="0.00.00">
      <LOCATIONS>
        <LOCATION value="http://wwww.qedeq.org/0_04_07/doc/project"/>
      </LOCATIONS>
    </SPECIFICATION>
    <TITLE>
      <LATEX language="en">
         \textbf{Hilbert~II} \\
         \vspace*{1cm} 
         Presentation of \\ 
         Formal Correct \\
         Mathematical Knowledge \\
         \vspace*{1cm} Logical Language
      </LATEX>
    </TITLE>
    <ABSTRACT>
      <LATEX language="en">
         The project \textbf{Hilbert~II} includes formal correct mathematical knowledge. Here we introduce the underlying formal language for the mathematical formulas. This is done in an informal way.
      </LATEX>
    </ABSTRACT>
    <AUTHORS>
      <AUTHOR email="michael@meyling.com">
        <NAME>
          <LATEX language="en">
            Michael Meyling
          </LATEX>
        </NAME>
      </AUTHOR>
    </AUTHORS>
  </HEADER>
  <CHAPTER noNumber="true">
    <TITLE>
      <LATEX language="en">
        Description
      </LATEX>
    </TITLE>
    <INTRODUCTION>
      <LATEX language="en">
        <![CDATA[
          The project \textbf{Hilbert~II} includes formal correct mathematical knowledge. Here we introduce the underlying formal language for the mathematical formulas. This is done in an informal way. Important theorems (e.g.: universal decomposition, and any proofs) are left out.

          \par
          All we will do is manipulate symbols. We build lists of symbol strings and use certain simple rules to get new lists. So by starting with a few basic lists we create a whole universe of derived symbol lists. 
          It turns out that these lists could be interpreted as a view to the incredible world of mathematics.
        ]]>
      </LATEX>
    </INTRODUCTION>
  </CHAPTER>
  <CHAPTER>
    <TITLE>
      <LATEX language="en">Entities</LATEX>
    </TITLE>
    <INTRODUCTION>
      <LATEX language="en">
        <![CDATA[
          To describe the logical language we firstly deal with a more basic notation. This notation enables us to formulate the syntax of formulas and terms later on.
        ]]>
      </LATEX>
    </INTRODUCTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">Elements, Atoms and Lists</LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            The basic structure we have to deal with is an element. An element is either an atom or a list. 

            \par
            An atom carries textual data, atoms are just strings.      

            \par
            Each list has an operator and can contain elements again. An operator is also nothing more than a simple string. A list has a size: the number of elements it contains.  Their elements can be accessed by their position number. An atom has no operator, no size and no subelements in the previous sense.
          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">List Notation</LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            Lists and atoms can be written in the following manner.
            We write down string atoms quoted with {\tt "} and the lists as the contents of the operator string followed by {\tt (} and a comma separated list of elements and an closing {\tt )}.

          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">Examples</LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[

            In this syntax we can write down the following element examples.

            \begin{verbatim}
            "I am a string atom"

            EMPTY_LIST()

            THIS_LIST("contains", "three", "atoms")

            OPERATOR("argument 1", "argument 2")

            FUNCTION_A(FUNCTION_B("1", "2"), "3")
            \end{verbatim}
            
            In the last example we have a list that has the operator \verb#FUNCTION_A# and contains two elements. The first element is \verb#FUNCTION_B("1", "2")# which is a list too. The second element is the atom \verb#"3"#.

          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
  </CHAPTER>

  <CHAPTER>
    <TITLE>
      <LATEX language="en">Logical Language</LATEX>
    </TITLE>
    <INTRODUCTION>
      <LATEX language="en">
        <![CDATA[
          There are different basic things we have to do with. These are predicates, functions, subject variables and logical connectives. In the following all of them are named and described.
        ]]>
      </LATEX>
    </INTRODUCTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">Logical Operator Overview</LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            Lists are categorized according to their operators. 
            Before we introduce the formal language in detail the used operators are briefly listed. 

            \par
            \begin{tabularx}{\columnwidth}{lll}
              \multicolumn{2}{l@{}}{\qquad\emph{logical}} \vspace*{1mm} \\
              \emph{AND}  & logical conjunction operator    & $\land$ \\
              \emph{OR}   & logical disjunction operator    & $\lor$ \\
              \emph{IMPL} & logical implication operator    & $\rightarrow$ \\
              \emph{EQUI} & logical biconditional operator  & $\leftrightarrow$ \\
              \emph{NOT}  & logical negation operator       & $\neg$ \\
              \\
              \multicolumn{2}{l@{}}{\qquad\emph{logical quantifiers}} \vspace*{1mm} \\
              \emph{FORLL}   & universal quantifier          & $\forall$ \\
              \emph{EXISTS}  & existential quantifier        & $\exists$ \\
              \emph{EXISTSU} & unique existential quantifier & $\exists !$ \\
              \\
              \multicolumn{2}{l@{}}{\qquad\emph{variables}} \vspace*{1mm} \\
              \emph{VAR}      & subject variables           & $x, y, z, \ldots$ \\
              \emph{PREDVAR}  & predicate variables         & $A, B, R, \ldots$ \\
              \emph{FUNVAR}   & function variables          & $f, g, h, \ldots$ \\
              \\
              \multicolumn{2}{l@{}}{\qquad\emph{constants}} \vspace*{1mm} \\
              \emph{PREDCON}  & predicate constants         & $=, \in, \subseteq, \ldots$ \\
              \emph{FUNCON }  & function constants          & $\emptyset, \mathfrak{P}, \ldots$  \\
              \emph{CLASS}    & class term                  & $ \{ x | \phi(x) \}$ 
            \end{tabularx}


          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>

    <SECTION>
      <TITLE>
        <LATEX language="en">Terms and Formulas</LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            Now we define recursivly our formal language. We call some elements \emph{subject variables}, \emph{terms} and some other \emph{formulas}. We also define the relations a subject variable \emph{is free in} and \emph{is bound in} a term or a formula. If something is not according to the formal rules errors occur. The error codes are also described.
          ]]>
        </LATEX>
      </INTRODUCTION>
      <SUBSECTIONS>
        <SUBSECTION>
          <TITLE>
            <LATEX language="en">General Error Codes</LATEX>
          </TITLE>
          <TEXT>
            <LATEX language="en">
              <![CDATA[
              
                The atoms and lists that build up a formula or term are subject to restrictions.  The following errors occur if an atom has no content or has content with length of $0$ or an list has no operator or one of its sub-elements does not exist.
                These are mainly technical error codes, only the error code 30470 shows an semantical error.
                
                \begin{tabularx}{\linewidth}{llX}
                  30400  & no element         & an element doesn't exist - it is null \\
                  30410  & no atom            & an atom doesn't exist - it is null \\
                  30420  & no list            & a list doesn't exist - it is null \\
                  30430  & no atom content    & an atom has no content - it is null \\
                  30440  & atom content empty & an atom has content with $0$ length \\
                  30450  & no operator        & a list has no operator - it is null \\
                  30460  & operator empty     & a list has an operator with $0$ length \\
                  30470  & list expected      & list element expected but not found
                \end{tabularx}
                                
              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>
        <SUBSECTION>
          <TITLE>
            <LATEX language="en">Subject Variable</LATEX>
          </TITLE>
          <TEXT>
            <LATEX language="en">
              <![CDATA[
              
                We call an element \emph{subject variable} iff it has the operator \emph{VAR} and its list size is $1$ with an atom as its only argument.
                
                \par
                Each subject variable is also called a \emph{term}. Only the subject variable itself is free in itself. No subject variable is bound in a subject variable.

                \begin{tabularx}{\linewidth}{llX}
                  30710  & not exactly one argument & list has not exactly one element \\
                  30730  & atom element expected    & the first and only list element must be an atom 
                \end{tabularx}
                
              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>
        <SUBSECTION>
          <TITLE>
            <LATEX language="en">Function Term</LATEX>
          </TITLE>
          <TEXT>
            <LATEX language="en">
              <![CDATA[
              
                If an element has the operator \emph{FUNVAR} or \emph{FUNCON} and its list size is greater than or equal to $1$ with an atom as its first argument and the remaining arguments are all terms then it is called a term too.
                
                \par
                Iff a subject variable is free in any sub-element it is also free in the new term. No other subject variables are free. Analogous for bound subject variables. 
                

                \begin{tabularx}{\linewidth}{llX}
                  30720  & argument(s) missing      & if operator is \emph{FUNCON} the list must have at least one element \\
                  30730  & atom element expected    & the first list element must be an atom \\ 
                  30740  & argument(s) missing      & if operator is \emph{FUNVAR} the list must have more than one element \\
                  30770  & free bound mixed         & found a bound subject variable that is already free in a previous list element \\
                  30780  & free bound mixed         & found a free subject variable that is already bound in a previous list element \\
                  30690  & undefined constant       & the operator is \emph{FUNCON} and this function constant has not been defined for this argument number
                \end{tabularx}
                
                \par
                Any other error for term checks may occur due to the fact that all (but the first) sub-elements must be terms too.
                
              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>
        <SUBSECTION>
          <TITLE>
            <LATEX language="en">Predicate Formula</LATEX>
          </TITLE>
          <TEXT>
            <LATEX language="en">
              <![CDATA[
              
                If an element has the operator \emph{PREDVAR} or \emph{PREDCON} and its list size is greater than or equal to $1$ with an atom as its first argument and the remaining arguments are all terms and no errors occur then it is called a \emph{formula}.
                
                \par
                Iff a subject variable is free in any sub-element it is also free in the new formula. No other subject variables are free. Analogous for bound subject variables. 
                
                \begin{tabularx}{\linewidth}{llX}
                  30720  & argument(s) missing      & list must have at least one element \\
                  30730  & atom element expected    & the first list element must be an atom \\ 
                  30770  & free bound mixed         & found a bound subject variable that is already free in a previous list element \\
                  30780  & free bound mixed         & found a free subject variable that is already bound in a previous list element \\
                  30590  & undefined constant       & the operator is \emph{PREDCON} and this predicate constant has not been defined for this argument number
                \end{tabularx}
                
                \par
                Any other error for formula checks may occur due to the fact that all (but the first) sub-elements must be terms.
                
              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>
        <SUBSECTION>
          <TITLE>
            <LATEX language="en">Logical Connectives</LATEX>
          </TITLE>
          <TEXT>
            <LATEX language="en">
              <![CDATA[
              
                If an element has the operator \emph{AND}, \emph{OR}, \emph{IMPL} or \emph{EQUI} and its list size is greater than or equal to $2$ and the remaining arguments are all formulas and no errors occur then it is called a formula too.
                
                \par
                Iff a subject variable is free in any sub-element it is also free in the new formula. No other subject variables are free. Analogous for bound subject variables. 

                \begin{tabularx}{\linewidth}{llX}
                  30740  & argument(s) missing      & list must have more than one element \\
                  30760  & exactly $2$ elements expected & the operator is \emph{IMPL} and this list size is not equal to $2$ \\
                  30770  & free bound mixed         & found a bound subject variable that is already free in a previous list element \\
                  30780  & free bound mixed         & found a free subject variable that is already bound in a previous list element
                \end{tabularx}
                
                \par
                Any other error for formula checks may occur due to the fact that all sub-elements must be formulas.
                
              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>
        <SUBSECTION>
          <TITLE>
            <LATEX language="en">Negation</LATEX>
          </TITLE>
          <TEXT>
            <LATEX language="en">
              <![CDATA[
              
                If an element has the operator \emph{NOT}, its list size is exactly $1$ and its  only sub-element arguments is a formula then it is called a formula too.
                
                \par
                Iff a subject variable is free in the sub-element it is also free in the new formula. No other subject variables are free. Analogous for bound subject variables. 
                
                \begin{tabularx}{\linewidth}{llX}
                  30710  & exactly $1$ argument expected & list must have exactly than one element \\
                \end{tabularx}

                \par
                Any other error for formula checks may occur due to the fact that the sub-element must be a formula.
                
              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>
        <SUBSECTION>
          <TITLE>
            <LATEX language="en">Quantifiers</LATEX>
          </TITLE>
          <TEXT>
            <LATEX language="en">
              <![CDATA[
              
                If an element has the operator \emph{FORALL}, \emph{EXISTS} or \emph{EXISTSU} its first sub-element is a subject variable and its second and perhaps its third sub-element is a formula then the element is called a \emph{formula} too.
                
                \par
                Iff a subject variable is free in the sub-element it is also free in the new formula. No other subject variables are free. Analogous for bound subject variables. 
                
                \begin{tabularx}{\linewidth}{llX}
                  30760  & $2$ or $3$ arguments expected & list must have exactly $2$ or $3$ elements \\
                  30540  & subject variable expected & first sub-element must be a subject variable \\
                  30550  & already bound             & subject variable already bound in second or third sub-element \\
                  30770  & free bound mixed          & found a bound subject variable that is already free in a previous list element \\
                  30780  & free bound mixed          & found a free subject variable that is already bound in a previous list element 
                \end{tabularx}

                \par
                Any other error for formula checks may occur due to the fact that the sub-element must be a formula.
                
              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>
        <SUBSECTION>
          <TITLE>
            <LATEX language="en">Class Term</LATEX>
          </TITLE>
          <TEXT>
            <LATEX language="en">
              <![CDATA[
              
                An list element with the operator \emph{CLASS}, containing an subject variable and an formula is a term.
                
                \par
                Iff a subject variable is free in the formula and is not equal to the first sub-element (which is a subject variable) it is also free in the new term. No other subject variables are free. If a subject variable is bound in the formula it is bound in the new term. Also the first sub-element is bound. No other subject variables are bound.


                \begin{tabularx}{\linewidth}{llX}
                  30760  & $2$ arguments expected & the list must contain exactly two arguments \\
                  30540  & subject variable expected & the first sub-element must be a subject variable \\
                  30550  & already bound & the subject variable is already bound in the formula \\
                  30680  & undefined class operator & the class operator is still unknown
                \end{tabularx}

                \par
                Any other error for formula checks may occur due to the fact that the second sub-element must be a formula.
                
              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>
        <SUBSECTION>
          <TITLE>
            <LATEX language="en">Term</LATEX>
          </TITLE>
          <TEXT>
            <LATEX language="en">
              <![CDATA[
              
                When checking an element for beeing a term the element must have the operator for a \emph{Subject Variable}, \emph{Function Term} or \emph{Class Term}.

                \begin{tabularx}{\linewidth}{llX}
                  30620  & unknown term operator & element has no operator that is known as a term operator
                \end{tabularx}

                \par
                Any other error for the accordant operator checks may occur.
                
              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>
        <SUBSECTION>
          <TITLE>
            <LATEX language="en">Formula</LATEX>
          </TITLE>
          <TEXT>
            <LATEX language="en">
              <![CDATA[
              
                When checking an element for beeing a formul the element must have the operator for a \emph{Predicate Formula}, \emph{Logical Connective}, \emph{Negation} or \emph{Quantifier}.

                \begin{tabularx}{\linewidth}{llX}
                  30530  & unknown logical operator & element has no known logical operator
                \end{tabularx}

                \par
                Any other error for the accordant operator checks may occur.
                
              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>
      </SUBSECTIONS>
    </SECTION>
  </CHAPTER>
  <CHAPTER>
    <TITLE>
      <LATEX language="en">Representations</LATEX>
    </TITLE>
    <INTRODUCTION>
      <LATEX language="en">
        <![CDATA[
          The representation of elements differ according to the viewpoint. Lets take the following formula for example.

          $$y \ =  \ \{ x \ | \ \phi(x) \} \ \leftrightarrow \ \forall z\ (z \in y\ \leftrightarrow \ z \in \{ x \ | \ \phi(x) \} )$$
          
          The predicate constant $\in$ must have been defined in previous sections.
          
        ]]>
      </LATEX>
    </INTRODUCTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">List Notation</LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            In list notation the above formula looks like the following.
            
            \begin{verbatim}
            EQUI(
              PREDCON(
                "equal",
                VAR("y"),
                CLASS(
                  VAR("x"),
                  PREDVAR(
                    "\phi",
                    VAR("x")
                  )
                )
              ),
              FORALL(
                VAR("z"),
                EQUI(
                  PREDCON(
                    "in",
                    VAR("z"),
                    VAR("y")
                  ),
                  PREDCON(
                    "in",
                    VAR("z"),
                    CLASS(
                      VAR("x"),
                      PREDVAR(
                        "\phi",
                        VAR("x")
                      )
                    )
                  )
                )
              )
            )
            \end{verbatim}

          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">Java</LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            The list notation leads directly to the following Java code.
            \begin{verbatim}
            Element el = new ElementListImpl("EQUI", new Element[] {
                new ElementListImpl("PREDCON", new Element[] {
                    new AtomImpl("equal"), 
                    new ElementListImpl("VAR", new Element[] {
                        new AtomImpl("y"), 
                    }),
                    new ElementListImpl("CLASS", new Element[] {
                        new ElementListImpl("VAR", new Element[] {
                            new AtomImpl("x"), 
                        }),
                        new ElementListImpl("PREDVAR", new Element[] {
                            new AtomImpl("\\phi"), 
                            new ElementListImpl("VAR", new Element[] {
                                new AtomImpl("x"), 
                            })
                        })
                    })
                }),
                new ElementListImpl("FORALL", new Element[] {
                    new ElementListImpl("VAR", new Element[] {
                        new AtomImpl("z"), 
                    }),
                    new ElementListImpl("EQUI", new Element[] {
                        new ElementListImpl("PREDCON", new Element[] {
                            new AtomImpl("in"), 
                            new ElementListImpl("VAR", new Element[] {
                                new AtomImpl("z"), 
                            }),
                            new ElementListImpl("VAR", new Element[] {
                                new AtomImpl("y"), 
                            })
                        }),
                        new ElementListImpl("PREDCON", new Element[] {
                            new AtomImpl("in"), 
                            new ElementListImpl("VAR", new Element[] {
                                new AtomImpl("z"), 
                            }),
                            new ElementListImpl("CLASS", new Element[] {
                                new ElementListImpl("VAR", new Element[] {
                                    new AtomImpl("x"), 
                                }),
                                new ElementListImpl("PREDVAR", new Element[] {
                                    new AtomImpl("\\phi"), 
                                    new ElementListImpl("VAR", new Element[] {
                                        new AtomImpl("x"), 
                                    })
                                })
                            })
                        })
                    })
                })
            });

            \end{verbatim}
          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">XML</LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            The XML representation within an QEDEQ module looks a little bit different. Here all first list atoms are represented as the attribute {\tt ref} or {\tt id}.
            So the above formula may look like the following.
            
            \begin{verbatim}
            <EQUI>
              <PREDCON ref="equal">
                <VAR id="y"/>
                <CLASS>
                  <VAR id="x"/>
                  <PREDVAR id="\phi">
                    <VAR id="x"/>
                  </PREDVAR>
                </CLASS>
              </PREDCON>
              <FORALL>
                <VAR id="z"/>
                <EQUI>
                  <PREDCON ref="in">
                    <VAR id="z"/>
                    <VAR id="y"/>
                  </PREDCON>
                  <PREDCON ref="in">
                    <VAR id="z"/>
                    <CLASS>
                      <VAR id="x"/>
                      <PREDVAR id="\phi">
                        <VAR id="x"/>
                      </PREDVAR>
                    </CLASS>
                  </PREDCON>
                </EQUI>
              </FORALL>
            </EQUI>
            \end{verbatim}
            
            Due to XSD restrictions for the XML document some error codes listed in Chapter~\ref{chapter2} will not occur. Instead the XML will be classified as invalid.
            
          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
  </CHAPTER>
  <CHAPTER>
    <TITLE>
      <LATEX language="en">Document structure</LATEX>
    </TITLE>
    <INTRODUCTION>
      <LATEX language="en">
        <![CDATA[
          In this chapter we make some remarks about the QEDEQ XML format.
          ]]>
      </LATEX>
    </INTRODUCTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">Basic structure</LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            The mathematical knowledge of this project is organized in so called QEDEQ modules. Such a module can be read and edited with a simple text editor. It could contain references to other QEDEQ modules which lay anywhere in the world wide web.
            \par
            A QEDEQ module is build like a mathematical text book. It's main structure looks like an \LaTeX{} book file. It contains chapters which are composed of sections and sections are composed of subsections. A subsection may be pure text or an so called \emph{node}. A node is either an axiom, definition, proposition or rule. Every node has an id and could be referenced by that. Essential formal elements of a node are formulas.
            \par
            The formal definition of an QEDEQ XML document can be found here: \url{http://www.qedeq.org/0_04_07/xml/qedeq/noNamespace/element/QEDEQ.html}.
            
          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">References</LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            In QEDEQ documents reference links are used very often. There exist four goals for references: modules, nodes, sub formulas and proof lines. 
            \par
            If you want to address an external module you have to know its import \emph{label}. See \url{http://www.qedeq.org/0_04_07/xml/qedeq/noNamespace/element/QEDEQ.HEADER.IMPORTS.IMPORT.html}.
            \par
            A reference to a node needs the \emph{id} of that node. See \url{http://www.qedeq.org/0_04_07/xml/qedeq/noNamespace/element/NODE.html}.
            \par
            In certain cases it is also possible to reference a subformula of a proposition formula.
            This is only possible if the proposition formula is a conjunction (e.g. the top level logical operation is a conjunction). For each parameter a label is automatically generated. If the number of conjunction parameters is below 27 the label is simply the n'th alphabet character. If the number is greater 26 the label is written in the 26 system with alphabet characters as digits. To reference to a subformula of an external node the syntax is {\tt importLabel.nodeId/subRef}.
            \par
            You can also reference to a fromal proof line \emph{label}, see \url{http://www.qedeq.org/0_04_07/xml/qedeq/noNamespace/element/L.html}. Within the node you just need to link to the label. Outside the node context (but within the same module) the syntax is {\tt nodeId!lineLabel}.
            \par
            Here follows a reference summary.
            \par
            \begin{tabularx}{\linewidth}{ll}
              external module                  & {\tt importLabel}                      \\
              (external) node reference        & {\tt [importLabel.]nodeId}             \\
              (external) node sub formula ref. & {\tt [importLabel.]nodeId/subRef}      \\
              (external) node proof line ref.  & {\tt [[importLabel].nodeId!]lineLabel}
            \end{tabularx}
          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
  </CHAPTER>
  <CHAPTER>
    <TITLE>
      <LATEX language="en">Basic Rules of Inference\index{0.01.00}</LATEX>
    </TITLE>
    <INTRODUCTION>
      <LATEX language="en">
        <![CDATA[
          To get new formulas from already proven or given ones we introduce \emph{proof rules}. We can call a formula \emph{proposition} if we can write down a sequence of formulas that derive it from axioms, definitions and propositions by applying proof methods. Such a sequence is called a \emph{proof}. It is made of \emph{proof lines}. A proof line is a formula and a proof rule usage with its parameters. Each proof line has a label. The last formula of a proof must be the proposition formula itself. 

          
          \par
          We will introduce the following proof rules. 

          \par
          \begin{tabularx}{\columnwidth}{ll}
            \emph{Add}         & add already proven formula  \\
            \emph{MP}          & modus ponens  \\
            \emph{Rename}      & rename bound subject variable  \\
            \emph{SubstFree}   & substitute free subject variable by term  \\
            \emph{SubstFun}    & substitute function variable by term  \\
            \emph{SubstPred}   & substitute predicate variable by formula \\
            \emph{Universal}   & universal generalization  \\
            \emph{Existential} & existential generalization
          \end{tabularx}

          \par
          These basic rules get the rule version number $0.01.00$. The rules might get extended in higher rule versions.\footnote{For example we want to allow modus ponens also with a formula like $A \leftrightarrow B$.}

          \par
          TODO 20110612 m31: add error code description for rules

        ]]>
      </LATEX>
    </INTRODUCTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">Addition</LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            Addition of an axiom, definition or already proven formula. We have to reference to the location of a true formula.
            
            \par
            \begin{tabularx}{\columnwidth}{lll}
              \emph{name}        & \tt{Add}  & name of proof rule \\
              \emph{parameter 1} & \tt{ref}  & reference to axiom, definition or proposition
            \end{tabularx}

            \par
            See \url{http://www.qedeq.org/0_04_07/xml/qedeq/noNamespace/element/ADD.html}.
          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">Modus Ponens</LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            Modus Ponens (Conditional Elimination)

            \par
            \begin{eqnarray*}
             & A & \\
             & A \rightarrow B& \\
             \cline{2-3}
             & B &
            \end{eqnarray*}

            This rule states that if each of $A$ and $A \rightarrow B$ are already true formulas then $B$ is also a true formula.
            
            \par
            \begin{tabularx}{\columnwidth}{lll}
              \emph{name}        & \tt{MP}   & name of proof rule \\
              \emph{parameter 1} & \tt{ref1} & reference to a proof line label with a formula like $A$\\
              \emph{parameter 2} & \tt{ref2} & reference to a another proof line label with a formula like $A \rightarrow B$ \\
            \end{tabularx}

            \par
            See \url{http://www.qedeq.org/0_04_07/xml/qedeq/noNamespace/element/MP.html}.
          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">Rename bound subject variable</LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            We may replace a bound subject variable occurring in a formula by any other subject variable, provided that the new variable occurs not free in the original formula. If the variable to be replaced occurs in more than one scope, then the replacement needs to be made in one scope only.
            For example in this case we replace x by y at the first occurrence.

            \par
            \begin{eqnarray*}
             & \ldots \forall x A(x) \ldots & \\
             \cline{2-3}
             & \ldots \forall y A(y) \ldots & \\
            \end{eqnarray*}

            \par
            \begin{tabularx}{\columnwidth}{lll}
              \emph{name}        & \tt{Rename}      & name of proof rule \\
              \emph{parameter 1} & \tt{ref}         & reference to a proof line label \\
              \emph{parameter 2} & \tt{original}    & bound subject variable that should be renamed \\
              \emph{parameter 3} & \tt{replacement} & new name for subject variable \\
              \emph{parameter 4} & \tt{occurrence}  & bound occurence where we want to replace
            \end{tabularx}
          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">Substitute free subject variable by term.</LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            A free subject variable may be replaced by an arbitrary term, provided that the substituted term contains no subject variable that have a bound occurrence in the original formula. All occurrences of the free variable must be simultaneously replaced.

            \par
            \begin{eqnarray*}
             & A(x) & \\
             \cline{2-3}
             & A(t) & \\
            \end{eqnarray*}

            \par
            \begin{tabularx}{\columnwidth}{lll}
              \emph{name}        & \tt{SubstFree}   & name of proof rule \\
              \emph{parameter 1} & \tt{ref}         & reference to a proof line label \\
              \emph{parameter 2} & \tt{original}    & free subject variable that should be replaced \\
              \emph{parameter 3} & \tt{replacement} & replacement term 
            \end{tabularx}

            \par
            See \url{http://www.qedeq.org/0_04_07/xml/qedeq/noNamespace/element/SUBST_FREE.html}.
          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">Substitute predicate variable by formula</LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            Let $\alpha$ be a true formula that contains a predicate variable $p$ of arity $n$, let $x_1$, \ldots, $x_n$ be pairwise different subject variables and let $\beta(x_1, \ldots, x_n)$ be a formula where $x_1$, \ldots, $x_n$ are not bound. The formula $\beta(x_1, \ldots, x_n)$ must not contain all $x_1$, \ldots, $x_n$ as free subject variables. Furthermore it can also have other subject variables either free or bound.
            
            If the following conditions are fulfilled, then a replacement of all occurrences of $p(t_1, \ldots, t_n)$ each with appropriate terms $t_1$, \ldots, $t_n$ in $\alpha$ by $\beta(t_1, \ldots, t_n)$ results in another true formula.

            \begin{itemize}

            \item
            the free variables of $\beta(x_1, \ldots, x_n)$ without $x_1$, \ldots, $x_n$ do not occur as bound variables in $\alpha$ 
            
            \item 
            each occurrence of $p(t_1, \ldots, t_n)$ in $\alpha$ contains no bound variable of $\beta(x_1, \ldots, x_n)$ 

            \item
            the result of the substitution is a well-formed formula

            \end{itemize}

            \par
            \begin{eqnarray*}
             & A(\sigma) & \\
             \cline{2-3}
             & A(\tau) & \\
            \end{eqnarray*}

            \par
            \begin{tabularx}{\columnwidth}{lll}
              \emph{name}        & \tt{SubstPred}   & name of proof rule \\
              \emph{parameter 1} & \tt{ref}         & reference to a proof line label \\
              \emph{parameter 2} & \tt{original}    & predicate variable that should be replaced \\
              \emph{parameter 3} & \tt{replacement} & replacement formula 
            \end{tabularx}

            \par
            See \url{http://www.qedeq.org/0_04_07/xml/qedeq/noNamespace/element/SUBST_PREDVAR.html}.
          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">Substitute function variable by term</LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            Let $\alpha$ be an already proved formula that contains a function variable $\sigma$ of arity $n$, let $x_1$, \ldots, $x_n$ be pairwise different subject variables and let $\tau(x_1, \ldots, x_n)$ be an arbitrary term where $x_1$, \ldots, $x_n$ are not bound. 
            The term $\tau(x_1, \ldots, x_n)$ must not contain all $x_1$, \ldots, $x_n$ as free subject variables. Furthermore it can also have other subject variables either free or bound. 
            
            If the following conditions are fulfilled we can obtain a new true formula by replacing each occurrence of $\sigma(t_1, \ldots, t_n)$ with appropriate terms $t_1$, \ldots, $t_n$ in $\alpha$ by $\tau(t_1, \ldots, t_n)$.
            
            \begin{itemize}
            
            \item 
            the free variables of $\tau(x_1, \ldots, x_n)$ without $x_1$, \ldots, $x_n$ do not occur as bound variables in $\alpha$
            
            \item
            each occurrence of $\sigma(t_1, \ldots, t_n)$ in $\alpha$ contains no bound variable of $\tau(x_1, \ldots, x_n)$
            
            \item
            the result of the substitution is a well-formed formula
             
            \end{itemize}
        
            \par
            \begin{eqnarray*}
             & A(\sigma) & \\
             \cline{2-3}
             & A(\tau) & \\
            \end{eqnarray*}

            \par
            \begin{tabularx}{\columnwidth}{lll}
              \emph{name}        & \tt{SubstFun}    & name of proof rule \\
              \emph{parameter 1} & \tt{ref}         & reference to a proof line label \\
              \emph{parameter 2} & \tt{original}    & function variable that should be replaced \\
              \emph{parameter 3} & \tt{replacement} & replacement term 
            \end{tabularx}

            \par
            See \url{http://www.qedeq.org/0_04_07/xml/qedeq/noNamespace/element/SUBST_FUNVAR.html}.
          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">Universal Generalization</LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            If $\alpha \rightarrow \beta(x_1)$ is a true formula and $\alpha$ does not contain the subject variable $x_1$, then $\alpha \rightarrow (\forall x_1~(\beta(x_1)))$ is a true formula too.

            \par
            \begin{eqnarray*}
             & \alpha \rightarrow \beta(x_1) & \\
             \cline{2-3}
             & \alpha \rightarrow (\forall x_1~(\beta(x_1))) & \\
            \end{eqnarray*}

            \par
            \begin{tabularx}{\columnwidth}{lll}
              \emph{name}        & \tt{Universal}   & name of proof rule \\
              \emph{parameter 1} & \tt{ref}         & reference to a proof line label \\
              \emph{parameter 2} & \tt{var}         & subject variable we want to quantify with
            \end{tabularx}

            \par
            See \url{http://www.qedeq.org/0_04_07/xml/qedeq/noNamespace/element/UNIVERSAL.html}.
          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">Existential Generalization</LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            If $\alpha(x_1) \rightarrow \beta$ is already proved to be true and $\beta$ does not contain the subject variable $x_1$, then $(\exists x_1~\alpha(x_1)) \rightarrow \beta$ is also a true formula.

            \par
            \begin{eqnarray*}
             & \alpha(x_1) \rightarrow \beta & \\
             \cline{2-3}
             & (\exists x_1~\alpha(x_1)) \rightarrow \beta & \\
            \end{eqnarray*}

            \par
            \begin{tabularx}{\columnwidth}{lll}
              \emph{name}        & \tt{Existential} & name of proof rule \\
              \emph{parameter 1} & \tt{ref}         & reference to a proof line label \\
              \emph{parameter 2} & \tt{var}         & subject variable we want to quantify with
            \end{tabularx}

            \par
            See \url{http://www.qedeq.org/0_04_07/xml/qedeq/noNamespace/element/EXISTENTIAL.html}.
          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
  </CHAPTER>
  <CHAPTER>
    <TITLE>
      <LATEX language="en">Derived Rules\index{0.02.00}</LATEX>
    </TITLE>
    <INTRODUCTION>
      <LATEX language="en">
        <![CDATA[
          We can use derived rules that can be completely replaced by the old rules but enable us shorter proofs. We introduce a new rule that allows us to make an assumption and derive from that hypothesis. All previous rules get also slightly modified.

          \par
          \begin{tabularx}{\columnwidth}{ll}
            \emph{CP}          & conditional proof  \\
          \end{tabularx}
  
          \par
          These basic rules get the rule version number $0.02.00$.
  
        ]]>
      </LATEX>
    </INTRODUCTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">
          <![CDATA[
            Conditional Proof
          ]]>
        </LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            We have the well-formed formula $\alpha$ and add it as a new proof line. We assume this formula as hypothesis. Now we modify the existing inference rules. We can add a further proof line $\beta$ if $\alpha \rightarrow \beta$ is a well-formed formula and the usage of a previous inference rule with the following restrictions justifies the addition: any substitution of a free subject variable, a predicate variable or a function variable is only allowed, if the variable doesn't occur in $\alpha$.

            \par
            This rule can be used recursive. The conjunction of all hypothesis formulas is called a \emph{condition} for the proof line we want to check.

            \par
            \begin{tabularx}{\columnwidth}{lll}
              \emph{name}        & \tt{CP}          & name of proof rule \\
              \emph{parameter 1} & \tt{HYPOTHESIS}  & hypothesis \\
              \emph{parameter 2} & \tt{LINES}       & formal proof that uses the hypothesis\\
              \emph{parameter 2} & \tt{CONCLUSION}  & implication with hypothesis and last proof line
            \end{tabularx}

            \par
            See \url{http://www.qedeq.org/0_04_07/xml/qedeq/noNamespace/element/CP.html}.
          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
  </CHAPTER>
</QEDEQ>
