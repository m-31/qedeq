<?xml version="1.0" encoding="UTF-8"?>
<QEDEQ
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="http://www.qedeq.org/0_04_01/xml/qedeq.xsd">
  <HEADER email="mime@qedeq.org">
    <SPECIFICATION name="qedeq_logic_language" ruleVersion="0.00.00">
      <LOCATIONS>
        <LOCATION value="http://wwww.qedeq.org/0_04_01/doc/project"/>
      </LOCATIONS>
    </SPECIFICATION>
    <TITLE>
      <LATEX language="en">
         \textbf{Hilbert~II} \\
         \vspace*{1cm} 
         Presentation of \\ 
         Formal Correct \\
         Mathematical Knowledge \\
         \vspace*{1cm} Logical Language
      </LATEX>
    </TITLE>
    <ABSTRACT>
      <LATEX language="en">
         The project \textbf{Hilbert~II} includes formal correct mathematical knowledge. Here we introduce the underlying formal language for the mathematical formulas. This is done in an informal way.
      </LATEX>
    </ABSTRACT>
    <AUTHORS>
      <AUTHOR email="michael@meyling.com">
        <NAME>
          <LATEX language="en">
            Michael Meyling
          </LATEX>
        </NAME>
      </AUTHOR>
    </AUTHORS>
  </HEADER>
  <CHAPTER noNumber="true">
    <TITLE>
      <LATEX language="en">
        Description
      </LATEX>
    </TITLE>
    <INTRODUCTION>
      <LATEX language="en">
        <![CDATA[
          The project \textbf{Hilbert~II} includes formal correct mathematical knowledge. Here we introduce the underlying formal language for the mathematical formulas. This is done in an informal way. Important theorems (e.g.: universal decomposition, and any proofs) are left out.

          \par
          All we will do is manipulate symbols. We build lists of symbol strings and use certain simple rules to get new lists. So by starting with a few basic lists we create a whole universe of derived symbol lists. 
          It turns out that these lists could be interpreted as a view to the incredible world of mathematics.
        ]]>
      </LATEX>
    </INTRODUCTION>
  </CHAPTER>
  <CHAPTER>
    <TITLE>
      <LATEX language="en">Entities</LATEX>
    </TITLE>
    <INTRODUCTION>
      <LATEX language="en">
        <![CDATA[
          To describe the logical language we firstly deal with a more basic notation. This notation enables us to formulate the syntax of formulas and terms later on.
        ]]>
      </LATEX>
    </INTRODUCTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">Elements, Atoms and Lists</LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            The basic structure we have to deal with is an element. An element is either an atom or a list. 

            \par
            An atom carries textual data, atoms are just strings.      

            \par
            Each list has an operator and can contain elements again. An operator is also nothing more than a simple string. A list has a size: the number of elements it contains.  Their elements can be accessed by their position number. An atom has no operator, no size and no subelements in the previous sense.
          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">List Notation</LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            Lists and atoms can be written in the following manner.
            We write down string atoms quoted with {\tt "} and the lists as the contents of the operator string followed by {\tt (} and a comma separated list of elements and an closing {\tt )}.

          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">Examples</LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[

            In this syntax we can write down the following element examples.

            \begin{verbatim}
            "I am a string atom"

            EMPTY_LIST()

            THIS_LIST("contains", "three", "atoms")

            OPERATOR("argument 1", "argument 2")

            FUNCTION_A(FUNCTION_B("1", "2"), "3")
            \end{verbatim}
            
            In the last example we have a list that has the operator \verb#FUNCTION_A# and contains two elements. The first element is \verb#FUNCTION_B("1", "2")# which is a list too. The second element is the atom \verb#"3"#.

          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
  </CHAPTER>

  <CHAPTER>
    <TITLE>
      <LATEX language="en">Logical Language</LATEX>
    </TITLE>
    <INTRODUCTION>
      <LATEX language="en">
        <![CDATA[
          There are different basic things we have to do with. These are predicates, functions, subject variables and logical connectives. In the following all of them are named and described.
        ]]>
      </LATEX>
    </INTRODUCTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">Logical Operator Overview</LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            Lists are categorized according to their operators. 
            Before we introduce the formal language in detail the used operators are briefly listed. 

            \par
            \begin{tabularx}{\columnwidth}{lll}
              \multicolumn{2}{l@{}}{\qquad\emph{logical}} \vspace*{1mm} \\
              \emph{AND}  & logical conjunction operator    & $\land$ \\
              \emph{OR}   & logical disjunction operator    & $\lor$ \\
              \emph{IMPL} & logical implication operator    & $\rightarrow$ \\
              \emph{EQUI} & logical biconditional operator  & $\leftrightarrow$ \\
              \emph{NOT}  & logical negation operator       & $\neg$ \\
              \\
              \multicolumn{2}{l@{}}{\qquad\emph{logical quantifiers}} \vspace*{1mm} \\
              \emph{FORLL}   & universal quantifier           & $\forall$ \\
              \emph{EXISTS}  & existential quantifier         & $\exists$ \\
              \emph{EXISTSU} & unique existential quantifier  & $\exists !$ \\
              \\
              \multicolumn{2}{l@{}}{\qquad\emph{variables}} \vspace*{1mm} \\
              \emph{VAR}      & subject variables           & $x, y, z, \ldots$ \\
              \emph{PREDVAR}  & predicate variables         & $A, B, R, \ldots$ \\
              \emph{FUNVAR}   & function variables          & $f, g, h, \ldots$ \\
              \\
              \multicolumn{2}{l@{}}{\qquad\emph{constants}} \vspace*{1mm} \\
              \emph{PREDCON}  & predicate constants         & $=, \in, \subseteq, \ldots$ \\
              \emph{FUNCON }  & function constants          & $\emptyset, \mathfrak{P}, \ldots$  \\
              \emph{CLASS}    & class term                  & $ \{ x | \phi(x) \}$ 
            \end{tabularx}


          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>

    <SECTION>
      <TITLE>
        <LATEX language="en">Terms and Formulas</LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            Now we define recursivly our formal language. We call some elements \emph{subject variables}, \emph{terms} and some other \emph{formulas}. We also define the relations a subject variable \emph{is free in} and \emph{is bound in} a term or a formula. If something is not according to the formal rules errors occur. The error codes are also described.
          ]]>
        </LATEX>
      </INTRODUCTION>
      <SUBSECTIONS>
        <SUBSECTION>
          <TITLE>
            <LATEX language="en">General Error Codes</LATEX>
          </TITLE>
          <TEXT>
            <LATEX language="en">
              <![CDATA[
              
                The atoms and lists that build up a formula or term are subject to restrictions.  The following errors occur if an atom has no content or has content with length of $0$ or an list has no operator or one of its sub-elements does not exist.
                These are mainly technical error codes, only the error code 30470 shows an semantical error.
                
                \begin{tabularx}{\linewidth}{llX}
                  30400  & no element         & an element doesn't exist - it is null \\
                  30410  & no atom            & an atom doesn't exist - it is null \\
                  30420  & no list            & a list doesn't exist - it is null \\
                  30430  & no atom content    & an atom has no content - it is null \\
                  30440  & atom content empty & an atom has content with $0$ length \\
                  30450  & no operator        & a list has no operator - it is null \\
                  30460  & operator empty     & a list has an operator with $0$ length \\
                  30470  & list expected      & list element expected but not found
                \end{tabularx}
                                
              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>
        <SUBSECTION>
          <TITLE>
            <LATEX language="en">Subject Variable</LATEX>
          </TITLE>
          <TEXT>
            <LATEX language="en">
              <![CDATA[
              
                We call an element \emph{subject variable} iff it has the operator \emph{VAR} and its list size is $1$ with an atom as its only argument.
                
                \par
                Each subject variable is also called a \emph{term}. Only the subject variable itself is free in itself. No subject variable is bound in a subject variable.

                \begin{tabularx}{\linewidth}{llX}
                  30710  & not exactly one argument & list has not exactly one element \\
                  30730  & atom element expected    & the first and only list element must be an atom 
                \end{tabularx}
                
              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>
        <SUBSECTION>
          <TITLE>
            <LATEX language="en">Function Term</LATEX>
          </TITLE>
          <TEXT>
            <LATEX language="en">
              <![CDATA[
              
                If an element has the operator \emph{FUNVAR} or \emph{FUNCON} and its list size is greater than or equal to $1$ with an atom as its first argument and the remaining arguments are all terms then it is called a term too.
                
                \par
                Iff a subject variable is free in any sub-element it is also free in the new term. No other subject variables are free. Analogous for bound subject variables. 
                

                \begin{tabularx}{\linewidth}{llX}
                  30720  & argument(s) missing      & if operator is \emph{FUNCON} the list must have at least one element \\
                  30730  & atom element expected    & the first list element must be an atom \\ 
                  30740  & argument(s) missing      & if operator is \emph{FUNVAR} the list must have more than one element \\
                  30770  & free bound mixed         & found a bound subject variable that is already free in a previous list element \\
                  30780  & free bound mixed         & found a free subject variable that is already bound in a previous list element \\
                  30690  & undefined constant       & the operator is \emph{FUNCON} and this function constant has not been defined for this argument number
                \end{tabularx}
                
                \par
                Any other error for term checks may occur due to the fact that all (but the first) sub-elements must be terms too.
                
              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>
        <SUBSECTION>
          <TITLE>
            <LATEX language="en">Predicate Formula</LATEX>
          </TITLE>
          <TEXT>
            <LATEX language="en">
              <![CDATA[
              
                If an element has the operator \emph{PREDVAR} or \emph{PREDCON} and its list size is greater than or equal to $1$ with an atom as its first argument and the remaining arguments are all terms and no errors occur then it is called a \emph{formula}.
                
                \par
                Iff a subject variable is free in any sub-element it is also free in the new formula. No other subject variables are free. Analogous for bound subject variables. 
                
                \begin{tabularx}{\linewidth}{llX}
                  30720  & argument(s) missing      & list must have at least one element \\
                  30730  & atom element expected    & the first list element must be an atom \\ 
                  30770  & free bound mixed         & found a bound subject variable that is already free in a previous list element \\
                  30780  & free bound mixed         & found a free subject variable that is already bound in a previous list element \\
                  30590  & undefined constant       & the operator is \emph{PREDCON} and this predicate constant has not been defined for this argument number
                \end{tabularx}
                
                \par
                Any other error for formula checks may occur due to the fact that all (but the first) sub-elements must be terms.
                
              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>
        <SUBSECTION>
          <TITLE>
            <LATEX language="en">Logical Connectives</LATEX>
          </TITLE>
          <TEXT>
            <LATEX language="en">
              <![CDATA[
              
                If an element has the operator \emph{AND}, \emph{OR}, \emph{IMPL} or \emph{EQUI} and its list size is greater than or equal to $2$ and the remaining arguments are all formulas and no errors occur then it is called a formula too.
                
                \par
                Iff a subject variable is free in any sub-element it is also free in the new formula. No other subject variables are free. Analogous for bound subject variables. 

                \begin{tabularx}{\linewidth}{llX}
                  30740  & argument(s) missing      & list must have more than one element \\
                  30760  & exactly $2$ elements expected & the operator is \emph{IMPL} and this list size is not equal to $2$ \\
                  30770  & free bound mixed         & found a bound subject variable that is already free in a previous list element \\
                  30780  & free bound mixed         & found a free subject variable that is already bound in a previous list element
                \end{tabularx}
                
                \par
                Any other error for formula checks may occur due to the fact that all sub-elements must be formulas.
                
              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>
        <SUBSECTION>
          <TITLE>
            <LATEX language="en">Negation</LATEX>
          </TITLE>
          <TEXT>
            <LATEX language="en">
              <![CDATA[
              
                If an element has the operator \emph{NOT}, its list size is exactly $1$ and its  only sub-element arguments is a formula then it is called a formula too.
                
                \par
                Iff a subject variable is free in the sub-element it is also free in the new formula. No other subject variables are free. Analogous for bound subject variables. 
                
                \begin{tabularx}{\linewidth}{llX}
                  30710  & exactly $1$ argument expected & list must have exactly than one element \\
                \end{tabularx}

                \par
                Any other error for formula checks may occur due to the fact that the sub-element must be a formula.
                
              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>
        <SUBSECTION>
          <TITLE>
            <LATEX language="en">Quantifiers</LATEX>
          </TITLE>
          <TEXT>
            <LATEX language="en">
              <![CDATA[
              
                If an element has the operator \emph{FORALL}, \emph{EXISTS} or \emph{EXISTSU} its first sub-element is a subject variable and its second and perhaps its third sub-element is a formula then the element is called a \emph{formula} too.
                
                \par
                Iff a subject variable is free in the sub-element it is also free in the new formula. No other subject variables are free. Analogous for bound subject variables. 
                
                \begin{tabularx}{\linewidth}{llX}
                  30760  & $2$ or $3$ arguments expected & list must have exactly $2$ or $3$ elements \\
                  30540  & subject variable expected & first sub-element must be a subject variable \\
                  30550  & already bound             & subject variable already bound in second or third sub-element \\
                  30770  & free bound mixed          & found a bound subject variable that is already free in a previous list element \\
                  30780  & free bound mixed          & found a free subject variable that is already bound in a previous list element 
                \end{tabularx}

                \par
                Any other error for formula checks may occur due to the fact that the sub-element must be a formula.
                
              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>
        <SUBSECTION>
          <TITLE>
            <LATEX language="en">Class Term</LATEX>
          </TITLE>
          <TEXT>
            <LATEX language="en">
              <![CDATA[
              
                An list element with the operator \emph{CLASS}, containing an subject variable and an formula is a term.
                
                \par
                Iff a subject variable is free in the formula and is not equal to the first sub-element (which is a subject variable) it is also free in the new term. No other subject variables are free. If a subject variable is bound in the formula it is bound in the new term. Also the first sub-element is bound. No other subject variables are bound.


                \begin{tabularx}{\linewidth}{llX}
                  30760  & $2$ arguments expected & the list must contain exactly two arguments \\
                  30540  & subject variable expected & the first sub-element must be a subject variable \\
                  30550  & already bound & the subject variable is already bound in the formula \\
                  30680  & undefined class operator & the class operator is still unknown
                \end{tabularx}

                \par
                Any other error for formula checks may occur due to the fact that the second sub-element must be a formula.
                
              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>
        <SUBSECTION>
          <TITLE>
            <LATEX language="en">Term</LATEX>
          </TITLE>
          <TEXT>
            <LATEX language="en">
              <![CDATA[
              
                When checking an element for beeing a term the element must have the operator for a \emph{Subject Variable}, \emph{Function Term} or \emph{Class Term}.

                \begin{tabularx}{\linewidth}{llX}
                  30620  & unknown term operator & element has no operator that is known as a term operator
                \end{tabularx}

                \par
                Any other error for the accordant operator checks may occur.
                
              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>
        <SUBSECTION>
          <TITLE>
            <LATEX language="en">Formula</LATEX>
          </TITLE>
          <TEXT>
            <LATEX language="en">
              <![CDATA[
              
                When checking an element for beeing a formul the element must have the operator for a \emph{Predicate Formula}, \emph{Logical Connective}, \emph{Negation} or \emph{Quantifier}.

                \begin{tabularx}{\linewidth}{llX}
                  30530  & unknown logical operator & element has no known logical operator
                \end{tabularx}

                \par
                Any other error for the accordant operator checks may occur.
                
              ]]>
            </LATEX>
          </TEXT>
        </SUBSECTION>
      </SUBSECTIONS>
    </SECTION>
  </CHAPTER>
  <CHAPTER>
    <TITLE>
      <LATEX language="en">Representations</LATEX>
    </TITLE>
    <INTRODUCTION>
      <LATEX language="en">
        <![CDATA[
          The representation of elements differ according to the viewpoint. Lets take the following formula for example.

          $$y \ =  \ \{ x \ | \ \phi(x) \} \ \leftrightarrow \ \forall z\ (z \in y\ \leftrightarrow \ z \in \{ x \ | \ \phi(x) \} )$$
          
          The predicate constant $\in$ must have been defined in previous sections.
          
        ]]>
      </LATEX>
    </INTRODUCTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">List Notation</LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            In list notation (see \ref{chapter1_section1}) the above formula looks like the following.
            
            \begin{verbatim}
            EQUI(
              PREDCON(
                "equal",
                VAR("y"),
                CLASS(
                  VAR("x"),
                  PREDVAR(
                    "\phi",
                    VAR("x")
                  )
                )
              ),
              FORALL(
                VAR("z"),
                EQUI(
                  PREDCON(
                    "in",
                    VAR("z"),
                    VAR("y")
                  ),
                  PREDCON(
                    "in",
                    VAR("z"),
                    CLASS(
                      VAR("x"),
                      PREDVAR(
                        "\phi",
                        VAR("x")
                      )
                    )
                  )
                )
              )
            )
            \end{verbatim}

          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">Java</LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            The list notation leads directly to the following Java code.
            \begin{verbatim}
            Element el = new ElementListImpl("EQUI", new Element[] {
                new ElementListImpl("PREDCON", new Element[] {
                    new AtomImpl("equal"), 
                    new ElementListImpl("VAR", new Element[] {
                        new AtomImpl("y"), 
                    }),
                    new ElementListImpl("CLASS", new Element[] {
                        new ElementListImpl("VAR", new Element[] {
                            new AtomImpl("x"), 
                        }),
                        new ElementListImpl("PREDVAR", new Element[] {
                            new AtomImpl("\\phi"), 
                            new ElementListImpl("VAR", new Element[] {
                                new AtomImpl("x"), 
                            })
                        })
                    })
                }),
                new ElementListImpl("FORALL", new Element[] {
                    new ElementListImpl("VAR", new Element[] {
                        new AtomImpl("z"), 
                    }),
                    new ElementListImpl("EQUI", new Element[] {
                        new ElementListImpl("PREDCON", new Element[] {
                            new AtomImpl("in"), 
                            new ElementListImpl("VAR", new Element[] {
                                new AtomImpl("z"), 
                            }),
                            new ElementListImpl("VAR", new Element[] {
                                new AtomImpl("y"), 
                            })
                        }),
                        new ElementListImpl("PREDCON", new Element[] {
                            new AtomImpl("in"), 
                            new ElementListImpl("VAR", new Element[] {
                                new AtomImpl("z"), 
                            }),
                            new ElementListImpl("CLASS", new Element[] {
                                new ElementListImpl("VAR", new Element[] {
                                    new AtomImpl("x"), 
                                }),
                                new ElementListImpl("PREDVAR", new Element[] {
                                    new AtomImpl("\\phi"), 
                                    new ElementListImpl("VAR", new Element[] {
                                        new AtomImpl("x"), 
                                    })
                                })
                            })
                        })
                    })
                })
            });

            \end{verbatim}
          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">XML</LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            The XML representation within an QEDEQ module looks a little bit different. Here all first list atoms are represented as the attribute {\tt ref} or {\tt id}.
            So the above formula may look like the following.
            
            \begin{verbatim}
            <EQUI>
              <PREDCON ref="equal">
                <VAR id="y"/>
                <CLASS>
                  <VAR id="x"/>
                  <PREDVAR id="\phi">
                    <VAR id="x"/>
                  </PREDVAR>
                </CLASS>
              </PREDCON>
              <FORALL>
                <VAR id="z"/>
                <EQUI>
                  <PREDCON ref="in">
                    <VAR id="z"/>
                    <VAR id="y"/>
                  </PREDCON>
                  <PREDCON ref="in">
                    <VAR id="z"/>
                    <CLASS>
                      <VAR id="x"/>
                      <PREDVAR id="\phi">
                        <VAR id="x"/>
                      </PREDVAR>
                    </CLASS>
                  </PREDCON>
                </EQUI>
              </FORALL>
            </EQUI>
            \end{verbatim}
            
            Due to XSD restrictions for the XML document some error codes listed in Chapter~\ref{chapter0} will not occur. Instead the XML will be classified as invalid.
            
          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
  </CHAPTER>

  <CHAPTER>
    <TITLE>
      <LATEX language="en">Rules of Inference</LATEX>
    </TITLE>
    <INTRODUCTION>
      <LATEX language="en">
        <![CDATA[
          To get new formulas from already proven or given ones we introduce proof rules. We prove a given formula (which we call proposition if we have a proof) we start writing a sequence of true formulas. Axioms, definitions and already proven formulas are the first formulas within such a sequence. We can also apply proof methods to formulas that are already in our sequence. Proof rules enable us to obtain new true formulas.
          
          \par
          We will introduce the following proof methods. 

            \par
            \begin{tabularx}{\columnwidth}{ll}
              \emph{MP}          & modus ponens  \\
              \emph{Add}         & add already proven formula  \\
              \emph{Rename}      & rename bound subject variable  \\
              \emph{SubstFree}   & substitute free subject variable by term  \\
              \emph{SubstFun}    & substitute function variable by term  \\
              \emph{SubstPred}   & substitute predicate variable by formula \\
              \emph{Universal}   & universal generalization  \\
              \emph{Existential} & existential generalization  \\
            \end{tabularx}

        ]]>
      </LATEX>
    </INTRODUCTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">Modus Ponens</LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            Modus Ponens (Conditional Elimination)

            \par
            \begin{eqnarray*}
             & A & \\
             & A \rightarrow B& \\
             \cline{2-3}
             & B &
            \end{eqnarray*}

            This rule states that if each of $A$ and $A \rightarrow B$ are already true formulas then $B$ is also a true formula.
          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
    <SECTION>
      <TITLE>
        <LATEX language="en">Add</LATEX>
      </TITLE>
      <INTRODUCTION>
        <LATEX language="en">
          <![CDATA[
            Addition of an axiom, definition or already proven formula. We have to reference to the location of a true formula.
          ]]>
        </LATEX>
      </INTRODUCTION>
    </SECTION>
  </CHAPTER>

</QEDEQ>
